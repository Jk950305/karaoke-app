{"ast":null,"code":"const PassThrough = require('stream').PassThrough;\n\nconst getInfo = require('./info');\n\nconst utils = require('./utils');\n\nconst formatUtils = require('./format-utils');\n\nconst urlUtils = require('./url-utils');\n\nconst sig = require('./sig');\n\nconst miniget = require('miniget');\n\nconst m3u8stream = require('m3u8stream');\n\nconst {\n  parseTimestamp\n} = require('m3u8stream');\n/**\n * @param {string} link\n * @param {!Object} options\n * @returns {ReadableStream}\n */\n\n\nconst ytdl = (link, options) => {\n  const stream = createStream(options);\n  ytdl.getInfo(link, options).then(info => {\n    downloadFromInfoCallback(stream, info, options);\n  }, stream.emit.bind(stream, 'error'));\n  return stream;\n};\n\nmodule.exports = ytdl;\nytdl.getBasicInfo = getInfo.getBasicInfo;\nytdl.getInfo = getInfo.getInfo;\nytdl.chooseFormat = formatUtils.chooseFormat;\nytdl.filterFormats = formatUtils.filterFormats;\nytdl.validateID = urlUtils.validateID;\nytdl.validateURL = urlUtils.validateURL;\nytdl.getURLVideoID = urlUtils.getURLVideoID;\nytdl.getVideoID = urlUtils.getVideoID;\nytdl.cache = {\n  sig: sig.cache,\n  info: getInfo.cache,\n  watch: getInfo.watchPageCache,\n  cookie: getInfo.cookieCache\n};\n\nconst createStream = options => {\n  const stream = new PassThrough({\n    highWaterMark: options && options.highWaterMark || 1024 * 512\n  });\n\n  stream._destroy = () => {\n    stream.destroyed = true;\n  };\n\n  return stream;\n};\n\nconst pipeAndSetEvents = (req, stream, end) => {\n  // Forward events from the request to the stream.\n  ['abort', 'request', 'response', 'error', 'redirect', 'retry', 'reconnect'].forEach(event => {\n    req.prependListener(event, stream.emit.bind(stream, event));\n  });\n  req.pipe(stream, {\n    end\n  });\n};\n/**\n * Chooses a format to download.\n *\n * @param {stream.Readable} stream\n * @param {Object} info\n * @param {Object} options\n */\n\n\nconst downloadFromInfoCallback = (stream, info, options) => {\n  options = options || {};\n  let err = utils.playError(info.player_response, ['UNPLAYABLE', 'LIVE_STREAM_OFFLINE', 'LOGIN_REQUIRED']);\n\n  if (err) {\n    stream.emit('error', err);\n    return;\n  }\n\n  if (!info.formats.length) {\n    stream.emit('error', Error('This video is unavailable'));\n    return;\n  }\n\n  let format;\n\n  try {\n    format = formatUtils.chooseFormat(info.formats, options);\n  } catch (e) {\n    stream.emit('error', e);\n    return;\n  }\n\n  stream.emit('info', info, format);\n\n  if (stream.destroyed) {\n    return;\n  }\n\n  let contentLength,\n      downloaded = 0;\n\n  const ondata = chunk => {\n    downloaded += chunk.length;\n    stream.emit('progress', chunk.length, downloaded, contentLength);\n  }; // Download the file in chunks, in this case the default is 10MB,\n  // anything over this will cause youtube to throttle the download\n\n\n  const dlChunkSize = options.dlChunkSize || 1024 * 1024 * 10;\n  let req;\n  let shouldEnd = true;\n\n  if (format.isHLS || format.isDashMPD) {\n    req = m3u8stream(format.url, {\n      chunkReadahead: +info.live_chunk_readahead,\n      begin: options.begin || format.isLive && Date.now(),\n      liveBuffer: options.liveBuffer,\n      requestOptions: options.requestOptions,\n      parser: format.isDashMPD ? 'dash-mpd' : 'm3u8',\n      id: format.itag\n    });\n    req.on('progress', (segment, totalSegments) => {\n      stream.emit('progress', segment.size, segment.num, totalSegments);\n    });\n    pipeAndSetEvents(req, stream, shouldEnd);\n  } else {\n    const requestOptions = Object.assign({}, options.requestOptions, {\n      maxReconnects: 6,\n      maxRetries: 3,\n      backoff: {\n        inc: 500,\n        max: 10000\n      }\n    });\n    let shouldBeChunked = dlChunkSize !== 0 && (!format.hasAudio || !format.hasVideo);\n\n    if (shouldBeChunked) {\n      let start = options.range && options.range.start || 0;\n      let end = start + dlChunkSize;\n      const rangeEnd = options.range && options.range.end;\n      contentLength = options.range ? (rangeEnd ? rangeEnd + 1 : parseInt(format.contentLength)) - start : parseInt(format.contentLength);\n\n      const getNextChunk = () => {\n        if (!rangeEnd && end >= contentLength) end = 0;\n        if (rangeEnd && end > rangeEnd) end = rangeEnd;\n        shouldEnd = !end || end === rangeEnd;\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${start}-${end || ''}`\n        });\n        req = miniget(format.url, requestOptions);\n        req.on('data', ondata);\n        req.on('end', () => {\n          if (stream.destroyed) {\n            return;\n          }\n\n          if (end && end !== rangeEnd) {\n            start = end + 1;\n            end += dlChunkSize;\n            getNextChunk();\n          }\n        });\n        pipeAndSetEvents(req, stream, shouldEnd);\n      };\n\n      getNextChunk();\n    } else {\n      // Audio only and video only formats don't support begin\n      if (options.begin) {\n        format.url += `&begin=${parseTimestamp(options.begin)}`;\n      }\n\n      if (options.range && (options.range.start || options.range.end)) {\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${options.range.start || '0'}-${options.range.end || ''}`\n        });\n      }\n\n      req = miniget(format.url, requestOptions);\n      req.on('response', res => {\n        if (stream.destroyed) {\n          return;\n        }\n\n        contentLength = contentLength || parseInt(res.headers['content-length']);\n      });\n      req.on('data', ondata);\n      pipeAndSetEvents(req, stream, shouldEnd);\n    }\n  }\n\n  stream._destroy = () => {\n    stream.destroyed = true;\n    req.destroy();\n    req.end();\n  };\n};\n/**\n * Can be used to download video after its `info` is gotten through\n * `ytdl.getInfo()`. In case the user might want to look at the\n * `info` object before deciding to download.\n *\n * @param {Object} info\n * @param {!Object} options\n * @returns {ReadableStream}\n */\n\n\nytdl.downloadFromInfo = (info, options) => {\n  const stream = createStream(options);\n\n  if (!info.full) {\n    throw Error('Cannot use `ytdl.downloadFromInfo()` when called ' + 'with info from `ytdl.getBasicInfo()`');\n  }\n\n  setImmediate(() => {\n    downloadFromInfoCallback(stream, info, options);\n  });\n  return stream;\n};","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/ytdl-core/lib/index.js"],"names":["PassThrough","require","getInfo","utils","formatUtils","urlUtils","sig","miniget","m3u8stream","parseTimestamp","ytdl","link","options","stream","createStream","then","info","downloadFromInfoCallback","emit","bind","module","exports","getBasicInfo","chooseFormat","filterFormats","validateID","validateURL","getURLVideoID","getVideoID","cache","watch","watchPageCache","cookie","cookieCache","highWaterMark","_destroy","destroyed","pipeAndSetEvents","req","end","forEach","event","prependListener","pipe","err","playError","player_response","formats","length","Error","format","e","contentLength","downloaded","ondata","chunk","dlChunkSize","shouldEnd","isHLS","isDashMPD","url","chunkReadahead","live_chunk_readahead","begin","isLive","Date","now","liveBuffer","requestOptions","parser","id","itag","on","segment","totalSegments","size","num","Object","assign","maxReconnects","maxRetries","backoff","inc","max","shouldBeChunked","hasAudio","hasVideo","start","range","rangeEnd","parseInt","getNextChunk","headers","Range","res","destroy","downloadFromInfo","full","setImmediate"],"mappings":"AAAA,MAAMA,WAAW,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,WAAtC;;AACA,MAAME,OAAO,GAAGD,OAAO,CAAC,QAAD,CAAvB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMG,WAAW,GAAGH,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAMK,GAAG,GAAGL,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMO,UAAU,GAAGP,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAM;AAAEQ,EAAAA;AAAF,IAAqBR,OAAO,CAAC,YAAD,CAAlC;AAGA;AACA;AACA;AACA;AACA;;;AACA,MAAMS,IAAI,GAAG,CAACC,IAAD,EAAOC,OAAP,KAAmB;AAC9B,QAAMC,MAAM,GAAGC,YAAY,CAACF,OAAD,CAA3B;AACAF,EAAAA,IAAI,CAACR,OAAL,CAAaS,IAAb,EAAmBC,OAAnB,EAA4BG,IAA5B,CAAiCC,IAAI,IAAI;AACvCC,IAAAA,wBAAwB,CAACJ,MAAD,EAASG,IAAT,EAAeJ,OAAf,CAAxB;AACD,GAFD,EAEGC,MAAM,CAACK,IAAP,CAAYC,IAAZ,CAAiBN,MAAjB,EAAyB,OAAzB,CAFH;AAGA,SAAOA,MAAP;AACD,CAND;;AAOAO,MAAM,CAACC,OAAP,GAAiBX,IAAjB;AAEAA,IAAI,CAACY,YAAL,GAAoBpB,OAAO,CAACoB,YAA5B;AACAZ,IAAI,CAACR,OAAL,GAAeA,OAAO,CAACA,OAAvB;AACAQ,IAAI,CAACa,YAAL,GAAoBnB,WAAW,CAACmB,YAAhC;AACAb,IAAI,CAACc,aAAL,GAAqBpB,WAAW,CAACoB,aAAjC;AACAd,IAAI,CAACe,UAAL,GAAkBpB,QAAQ,CAACoB,UAA3B;AACAf,IAAI,CAACgB,WAAL,GAAmBrB,QAAQ,CAACqB,WAA5B;AACAhB,IAAI,CAACiB,aAAL,GAAqBtB,QAAQ,CAACsB,aAA9B;AACAjB,IAAI,CAACkB,UAAL,GAAkBvB,QAAQ,CAACuB,UAA3B;AACAlB,IAAI,CAACmB,KAAL,GAAa;AACXvB,EAAAA,GAAG,EAAEA,GAAG,CAACuB,KADE;AAEXb,EAAAA,IAAI,EAAEd,OAAO,CAAC2B,KAFH;AAGXC,EAAAA,KAAK,EAAE5B,OAAO,CAAC6B,cAHJ;AAIXC,EAAAA,MAAM,EAAE9B,OAAO,CAAC+B;AAJL,CAAb;;AAQA,MAAMnB,YAAY,GAAGF,OAAO,IAAI;AAC9B,QAAMC,MAAM,GAAG,IAAIb,WAAJ,CAAgB;AAC7BkC,IAAAA,aAAa,EAAGtB,OAAO,IAAIA,OAAO,CAACsB,aAApB,IAAsC,OAAO;AAD/B,GAAhB,CAAf;;AAGArB,EAAAA,MAAM,CAACsB,QAAP,GAAkB,MAAM;AAAEtB,IAAAA,MAAM,CAACuB,SAAP,GAAmB,IAAnB;AAA0B,GAApD;;AACA,SAAOvB,MAAP;AACD,CAND;;AASA,MAAMwB,gBAAgB,GAAG,CAACC,GAAD,EAAMzB,MAAN,EAAc0B,GAAd,KAAsB;AAC7C;AACA,GACE,OADF,EACW,SADX,EACsB,UADtB,EACkC,OADlC,EAC2C,UAD3C,EACuD,OADvD,EACgE,WADhE,EAEEC,OAFF,CAEUC,KAAK,IAAI;AACjBH,IAAAA,GAAG,CAACI,eAAJ,CAAoBD,KAApB,EAA2B5B,MAAM,CAACK,IAAP,CAAYC,IAAZ,CAAiBN,MAAjB,EAAyB4B,KAAzB,CAA3B;AACD,GAJD;AAKAH,EAAAA,GAAG,CAACK,IAAJ,CAAS9B,MAAT,EAAiB;AAAE0B,IAAAA;AAAF,GAAjB;AACD,CARD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMtB,wBAAwB,GAAG,CAACJ,MAAD,EAASG,IAAT,EAAeJ,OAAf,KAA2B;AAC1DA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,MAAIgC,GAAG,GAAGzC,KAAK,CAAC0C,SAAN,CAAgB7B,IAAI,CAAC8B,eAArB,EAAsC,CAAC,YAAD,EAAe,qBAAf,EAAsC,gBAAtC,CAAtC,CAAV;;AACA,MAAIF,GAAJ,EAAS;AACP/B,IAAAA,MAAM,CAACK,IAAP,CAAY,OAAZ,EAAqB0B,GAArB;AACA;AACD;;AAED,MAAI,CAAC5B,IAAI,CAAC+B,OAAL,CAAaC,MAAlB,EAA0B;AACxBnC,IAAAA,MAAM,CAACK,IAAP,CAAY,OAAZ,EAAqB+B,KAAK,CAAC,2BAAD,CAA1B;AACA;AACD;;AAED,MAAIC,MAAJ;;AACA,MAAI;AACFA,IAAAA,MAAM,GAAG9C,WAAW,CAACmB,YAAZ,CAAyBP,IAAI,CAAC+B,OAA9B,EAAuCnC,OAAvC,CAAT;AACD,GAFD,CAEE,OAAOuC,CAAP,EAAU;AACVtC,IAAAA,MAAM,CAACK,IAAP,CAAY,OAAZ,EAAqBiC,CAArB;AACA;AACD;;AACDtC,EAAAA,MAAM,CAACK,IAAP,CAAY,MAAZ,EAAoBF,IAApB,EAA0BkC,MAA1B;;AACA,MAAIrC,MAAM,CAACuB,SAAX,EAAsB;AAAE;AAAS;;AAEjC,MAAIgB,aAAJ;AAAA,MAAmBC,UAAU,GAAG,CAAhC;;AACA,QAAMC,MAAM,GAAGC,KAAK,IAAI;AACtBF,IAAAA,UAAU,IAAIE,KAAK,CAACP,MAApB;AACAnC,IAAAA,MAAM,CAACK,IAAP,CAAY,UAAZ,EAAwBqC,KAAK,CAACP,MAA9B,EAAsCK,UAAtC,EAAkDD,aAAlD;AACD,GAHD,CAzB0D,CA8B1D;AACA;;;AACA,QAAMI,WAAW,GAAG5C,OAAO,CAAC4C,WAAR,IAAuB,OAAO,IAAP,GAAc,EAAzD;AACA,MAAIlB,GAAJ;AACA,MAAImB,SAAS,GAAG,IAAhB;;AAEA,MAAIP,MAAM,CAACQ,KAAP,IAAgBR,MAAM,CAACS,SAA3B,EAAsC;AACpCrB,IAAAA,GAAG,GAAG9B,UAAU,CAAC0C,MAAM,CAACU,GAAR,EAAa;AAC3BC,MAAAA,cAAc,EAAE,CAAC7C,IAAI,CAAC8C,oBADK;AAE3BC,MAAAA,KAAK,EAAEnD,OAAO,CAACmD,KAAR,IAAkBb,MAAM,CAACc,MAAP,IAAiBC,IAAI,CAACC,GAAL,EAFf;AAG3BC,MAAAA,UAAU,EAAEvD,OAAO,CAACuD,UAHO;AAI3BC,MAAAA,cAAc,EAAExD,OAAO,CAACwD,cAJG;AAK3BC,MAAAA,MAAM,EAAEnB,MAAM,CAACS,SAAP,GAAmB,UAAnB,GAAgC,MALb;AAM3BW,MAAAA,EAAE,EAAEpB,MAAM,CAACqB;AANgB,KAAb,CAAhB;AASAjC,IAAAA,GAAG,CAACkC,EAAJ,CAAO,UAAP,EAAmB,CAACC,OAAD,EAAUC,aAAV,KAA4B;AAC7C7D,MAAAA,MAAM,CAACK,IAAP,CAAY,UAAZ,EAAwBuD,OAAO,CAACE,IAAhC,EAAsCF,OAAO,CAACG,GAA9C,EAAmDF,aAAnD;AACD,KAFD;AAGArC,IAAAA,gBAAgB,CAACC,GAAD,EAAMzB,MAAN,EAAc4C,SAAd,CAAhB;AACD,GAdD,MAcO;AACL,UAAMW,cAAc,GAAGS,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBlE,OAAO,CAACwD,cAA1B,EAA0C;AAC/DW,MAAAA,aAAa,EAAE,CADgD;AAE/DC,MAAAA,UAAU,EAAE,CAFmD;AAG/DC,MAAAA,OAAO,EAAE;AAAEC,QAAAA,GAAG,EAAE,GAAP;AAAYC,QAAAA,GAAG,EAAE;AAAjB;AAHsD,KAA1C,CAAvB;AAMA,QAAIC,eAAe,GAAG5B,WAAW,KAAK,CAAhB,KAAsB,CAACN,MAAM,CAACmC,QAAR,IAAoB,CAACnC,MAAM,CAACoC,QAAlD,CAAtB;;AAEA,QAAIF,eAAJ,EAAqB;AACnB,UAAIG,KAAK,GAAI3E,OAAO,CAAC4E,KAAR,IAAiB5E,OAAO,CAAC4E,KAAR,CAAcD,KAAhC,IAA0C,CAAtD;AACA,UAAIhD,GAAG,GAAGgD,KAAK,GAAG/B,WAAlB;AACA,YAAMiC,QAAQ,GAAG7E,OAAO,CAAC4E,KAAR,IAAiB5E,OAAO,CAAC4E,KAAR,CAAcjD,GAAhD;AAEAa,MAAAA,aAAa,GAAGxC,OAAO,CAAC4E,KAAR,GACd,CAACC,QAAQ,GAAGA,QAAQ,GAAG,CAAd,GAAkBC,QAAQ,CAACxC,MAAM,CAACE,aAAR,CAAnC,IAA6DmC,KAD/C,GAEdG,QAAQ,CAACxC,MAAM,CAACE,aAAR,CAFV;;AAIA,YAAMuC,YAAY,GAAG,MAAM;AACzB,YAAI,CAACF,QAAD,IAAalD,GAAG,IAAIa,aAAxB,EAAuCb,GAAG,GAAG,CAAN;AACvC,YAAIkD,QAAQ,IAAIlD,GAAG,GAAGkD,QAAtB,EAAgClD,GAAG,GAAGkD,QAAN;AAChChC,QAAAA,SAAS,GAAG,CAAClB,GAAD,IAAQA,GAAG,KAAKkD,QAA5B;AAEArB,QAAAA,cAAc,CAACwB,OAAf,GAAyBf,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBV,cAAc,CAACwB,OAAjC,EAA0C;AACjEC,UAAAA,KAAK,EAAG,SAAQN,KAAM,IAAGhD,GAAG,IAAI,EAAG;AAD8B,SAA1C,CAAzB;AAIAD,QAAAA,GAAG,GAAG/B,OAAO,CAAC2C,MAAM,CAACU,GAAR,EAAaQ,cAAb,CAAb;AACA9B,QAAAA,GAAG,CAACkC,EAAJ,CAAO,MAAP,EAAelB,MAAf;AACAhB,QAAAA,GAAG,CAACkC,EAAJ,CAAO,KAAP,EAAc,MAAM;AAClB,cAAI3D,MAAM,CAACuB,SAAX,EAAsB;AAAE;AAAS;;AACjC,cAAIG,GAAG,IAAIA,GAAG,KAAKkD,QAAnB,EAA6B;AAC3BF,YAAAA,KAAK,GAAGhD,GAAG,GAAG,CAAd;AACAA,YAAAA,GAAG,IAAIiB,WAAP;AACAmC,YAAAA,YAAY;AACb;AACF,SAPD;AAQAtD,QAAAA,gBAAgB,CAACC,GAAD,EAAMzB,MAAN,EAAc4C,SAAd,CAAhB;AACD,OApBD;;AAqBAkC,MAAAA,YAAY;AACb,KA/BD,MA+BO;AACL;AACA,UAAI/E,OAAO,CAACmD,KAAZ,EAAmB;AACjBb,QAAAA,MAAM,CAACU,GAAP,IAAe,UAASnD,cAAc,CAACG,OAAO,CAACmD,KAAT,CAAgB,EAAtD;AACD;;AACD,UAAInD,OAAO,CAAC4E,KAAR,KAAkB5E,OAAO,CAAC4E,KAAR,CAAcD,KAAd,IAAuB3E,OAAO,CAAC4E,KAAR,CAAcjD,GAAvD,CAAJ,EAAiE;AAC/D6B,QAAAA,cAAc,CAACwB,OAAf,GAAyBf,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBV,cAAc,CAACwB,OAAjC,EAA0C;AACjEC,UAAAA,KAAK,EAAG,SAAQjF,OAAO,CAAC4E,KAAR,CAAcD,KAAd,IAAuB,GAAI,IAAG3E,OAAO,CAAC4E,KAAR,CAAcjD,GAAd,IAAqB,EAAG;AADL,SAA1C,CAAzB;AAGD;;AACDD,MAAAA,GAAG,GAAG/B,OAAO,CAAC2C,MAAM,CAACU,GAAR,EAAaQ,cAAb,CAAb;AACA9B,MAAAA,GAAG,CAACkC,EAAJ,CAAO,UAAP,EAAmBsB,GAAG,IAAI;AACxB,YAAIjF,MAAM,CAACuB,SAAX,EAAsB;AAAE;AAAS;;AACjCgB,QAAAA,aAAa,GAAGA,aAAa,IAAIsC,QAAQ,CAACI,GAAG,CAACF,OAAJ,CAAY,gBAAZ,CAAD,CAAzC;AACD,OAHD;AAIAtD,MAAAA,GAAG,CAACkC,EAAJ,CAAO,MAAP,EAAelB,MAAf;AACAjB,MAAAA,gBAAgB,CAACC,GAAD,EAAMzB,MAAN,EAAc4C,SAAd,CAAhB;AACD;AACF;;AAED5C,EAAAA,MAAM,CAACsB,QAAP,GAAkB,MAAM;AACtBtB,IAAAA,MAAM,CAACuB,SAAP,GAAmB,IAAnB;AACAE,IAAAA,GAAG,CAACyD,OAAJ;AACAzD,IAAAA,GAAG,CAACC,GAAJ;AACD,GAJD;AAKD,CAnHD;AAsHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA7B,IAAI,CAACsF,gBAAL,GAAwB,CAAChF,IAAD,EAAOJ,OAAP,KAAmB;AACzC,QAAMC,MAAM,GAAGC,YAAY,CAACF,OAAD,CAA3B;;AACA,MAAI,CAACI,IAAI,CAACiF,IAAV,EAAgB;AACd,UAAMhD,KAAK,CAAC,sDACV,sCADS,CAAX;AAED;;AACDiD,EAAAA,YAAY,CAAC,MAAM;AACjBjF,IAAAA,wBAAwB,CAACJ,MAAD,EAASG,IAAT,EAAeJ,OAAf,CAAxB;AACD,GAFW,CAAZ;AAGA,SAAOC,MAAP;AACD,CAVD","sourcesContent":["const PassThrough = require('stream').PassThrough;\nconst getInfo = require('./info');\nconst utils = require('./utils');\nconst formatUtils = require('./format-utils');\nconst urlUtils = require('./url-utils');\nconst sig = require('./sig');\nconst miniget = require('miniget');\nconst m3u8stream = require('m3u8stream');\nconst { parseTimestamp } = require('m3u8stream');\n\n\n/**\n * @param {string} link\n * @param {!Object} options\n * @returns {ReadableStream}\n */\nconst ytdl = (link, options) => {\n  const stream = createStream(options);\n  ytdl.getInfo(link, options).then(info => {\n    downloadFromInfoCallback(stream, info, options);\n  }, stream.emit.bind(stream, 'error'));\n  return stream;\n};\nmodule.exports = ytdl;\n\nytdl.getBasicInfo = getInfo.getBasicInfo;\nytdl.getInfo = getInfo.getInfo;\nytdl.chooseFormat = formatUtils.chooseFormat;\nytdl.filterFormats = formatUtils.filterFormats;\nytdl.validateID = urlUtils.validateID;\nytdl.validateURL = urlUtils.validateURL;\nytdl.getURLVideoID = urlUtils.getURLVideoID;\nytdl.getVideoID = urlUtils.getVideoID;\nytdl.cache = {\n  sig: sig.cache,\n  info: getInfo.cache,\n  watch: getInfo.watchPageCache,\n  cookie: getInfo.cookieCache,\n};\n\n\nconst createStream = options => {\n  const stream = new PassThrough({\n    highWaterMark: (options && options.highWaterMark) || 1024 * 512,\n  });\n  stream._destroy = () => { stream.destroyed = true; };\n  return stream;\n};\n\n\nconst pipeAndSetEvents = (req, stream, end) => {\n  // Forward events from the request to the stream.\n  [\n    'abort', 'request', 'response', 'error', 'redirect', 'retry', 'reconnect',\n  ].forEach(event => {\n    req.prependListener(event, stream.emit.bind(stream, event));\n  });\n  req.pipe(stream, { end });\n};\n\n\n/**\n * Chooses a format to download.\n *\n * @param {stream.Readable} stream\n * @param {Object} info\n * @param {Object} options\n */\nconst downloadFromInfoCallback = (stream, info, options) => {\n  options = options || {};\n\n  let err = utils.playError(info.player_response, ['UNPLAYABLE', 'LIVE_STREAM_OFFLINE', 'LOGIN_REQUIRED']);\n  if (err) {\n    stream.emit('error', err);\n    return;\n  }\n\n  if (!info.formats.length) {\n    stream.emit('error', Error('This video is unavailable'));\n    return;\n  }\n\n  let format;\n  try {\n    format = formatUtils.chooseFormat(info.formats, options);\n  } catch (e) {\n    stream.emit('error', e);\n    return;\n  }\n  stream.emit('info', info, format);\n  if (stream.destroyed) { return; }\n\n  let contentLength, downloaded = 0;\n  const ondata = chunk => {\n    downloaded += chunk.length;\n    stream.emit('progress', chunk.length, downloaded, contentLength);\n  };\n\n  // Download the file in chunks, in this case the default is 10MB,\n  // anything over this will cause youtube to throttle the download\n  const dlChunkSize = options.dlChunkSize || 1024 * 1024 * 10;\n  let req;\n  let shouldEnd = true;\n\n  if (format.isHLS || format.isDashMPD) {\n    req = m3u8stream(format.url, {\n      chunkReadahead: +info.live_chunk_readahead,\n      begin: options.begin || (format.isLive && Date.now()),\n      liveBuffer: options.liveBuffer,\n      requestOptions: options.requestOptions,\n      parser: format.isDashMPD ? 'dash-mpd' : 'm3u8',\n      id: format.itag,\n    });\n\n    req.on('progress', (segment, totalSegments) => {\n      stream.emit('progress', segment.size, segment.num, totalSegments);\n    });\n    pipeAndSetEvents(req, stream, shouldEnd);\n  } else {\n    const requestOptions = Object.assign({}, options.requestOptions, {\n      maxReconnects: 6,\n      maxRetries: 3,\n      backoff: { inc: 500, max: 10000 },\n    });\n\n    let shouldBeChunked = dlChunkSize !== 0 && (!format.hasAudio || !format.hasVideo);\n\n    if (shouldBeChunked) {\n      let start = (options.range && options.range.start) || 0;\n      let end = start + dlChunkSize;\n      const rangeEnd = options.range && options.range.end;\n\n      contentLength = options.range ?\n        (rangeEnd ? rangeEnd + 1 : parseInt(format.contentLength)) - start :\n        parseInt(format.contentLength);\n\n      const getNextChunk = () => {\n        if (!rangeEnd && end >= contentLength) end = 0;\n        if (rangeEnd && end > rangeEnd) end = rangeEnd;\n        shouldEnd = !end || end === rangeEnd;\n\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${start}-${end || ''}`,\n        });\n\n        req = miniget(format.url, requestOptions);\n        req.on('data', ondata);\n        req.on('end', () => {\n          if (stream.destroyed) { return; }\n          if (end && end !== rangeEnd) {\n            start = end + 1;\n            end += dlChunkSize;\n            getNextChunk();\n          }\n        });\n        pipeAndSetEvents(req, stream, shouldEnd);\n      };\n      getNextChunk();\n    } else {\n      // Audio only and video only formats don't support begin\n      if (options.begin) {\n        format.url += `&begin=${parseTimestamp(options.begin)}`;\n      }\n      if (options.range && (options.range.start || options.range.end)) {\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${options.range.start || '0'}-${options.range.end || ''}`,\n        });\n      }\n      req = miniget(format.url, requestOptions);\n      req.on('response', res => {\n        if (stream.destroyed) { return; }\n        contentLength = contentLength || parseInt(res.headers['content-length']);\n      });\n      req.on('data', ondata);\n      pipeAndSetEvents(req, stream, shouldEnd);\n    }\n  }\n\n  stream._destroy = () => {\n    stream.destroyed = true;\n    req.destroy();\n    req.end();\n  };\n};\n\n\n/**\n * Can be used to download video after its `info` is gotten through\n * `ytdl.getInfo()`. In case the user might want to look at the\n * `info` object before deciding to download.\n *\n * @param {Object} info\n * @param {!Object} options\n * @returns {ReadableStream}\n */\nytdl.downloadFromInfo = (info, options) => {\n  const stream = createStream(options);\n  if (!info.full) {\n    throw Error('Cannot use `ytdl.downloadFromInfo()` when called ' +\n      'with info from `ytdl.getBasicInfo()`');\n  }\n  setImmediate(() => {\n    downloadFromInfoCallback(stream, info, options);\n  });\n  return stream;\n};\n"]},"metadata":{},"sourceType":"script"}