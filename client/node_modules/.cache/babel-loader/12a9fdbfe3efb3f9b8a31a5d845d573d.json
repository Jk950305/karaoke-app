{"ast":null,"code":"/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\nfunction extend(a, b) {\n  for (var i in b) {\n    var g = b.__lookupGetter__(i),\n        s = b.__lookupSetter__(i);\n\n    if (g || s) {\n      if (g) a.__defineGetter__(i, g);\n      if (s) a.__defineSetter__(i, s);\n    } else a[i] = b[i];\n  }\n\n  return a;\n}\n\nfunction testFloatEqual(a, b) {\n  return (a > b ? a - b : b - a) > 1e-10;\n}\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n\nfunction AbstractFifoSamplePipe(createBuffers) {\n  if (createBuffers) {\n    this.inputBuffer = new FifoSampleBuffer();\n    this.outputBuffer = new FifoSampleBuffer();\n  } else {\n    this.inputBuffer = this.outputBuffer = null;\n  }\n}\n\n_c = AbstractFifoSamplePipe;\nAbstractFifoSamplePipe.prototype = {\n  get inputBuffer() {\n    return this._inputBuffer;\n  },\n\n  set inputBuffer(inputBuffer) {\n    this._inputBuffer = inputBuffer;\n  },\n\n  get outputBuffer() {\n    return this._outputBuffer;\n  },\n\n  set outputBuffer(outputBuffer) {\n    this._outputBuffer = outputBuffer;\n  },\n\n  clear: function () {\n    this._inputBuffer.clear();\n\n    this._outputBuffer.clear();\n  }\n};\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nfunction RateTransposer(createBuffers) {\n  AbstractFifoSamplePipe.call(this, createBuffers);\n\n  this._reset();\n\n  this.rate = 1;\n}\n\n_c2 = RateTransposer;\nextend(RateTransposer.prototype, AbstractFifoSamplePipe.prototype);\nextend(RateTransposer.prototype, {\n  set rate(rate) {\n    this._rate = rate; // TODO aa filter\n  },\n\n  _reset: function () {\n    this.slopeCount = 0;\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n  },\n  clone: function () {\n    var result = new RateTransposer();\n    result.rate = this._rate;\n    return result;\n  },\n  process: function () {\n    // TODO aa filter\n    var numFrames = this._inputBuffer.frameCount;\n\n    this._outputBuffer.ensureAdditionalCapacity(numFrames / this._rate + 1);\n\n    var numFramesOutput = this._transpose(numFrames);\n\n    this._inputBuffer.receive();\n\n    this._outputBuffer.put(numFramesOutput);\n  },\n  _transpose: function (numFrames) {\n    if (numFrames == 0) {\n      // no work\n      return 0;\n    }\n\n    var src = this._inputBuffer.vector;\n    var srcOffset = this._inputBuffer.startIndex;\n    var dest = this._outputBuffer.vector;\n    var destOffset = this._outputBuffer.endIndex;\n    var used = 0;\n    var i = 0;\n\n    while (this.slopeCount < 1.0) {\n      dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * this.prevSampleL + this.slopeCount * src[srcOffset];\n      dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * this.prevSampleR + this.slopeCount * src[srcOffset + 1];\n      i++;\n      this.slopeCount += this._rate;\n    }\n\n    this.slopeCount -= 1.0;\n\n    if (numFrames != 1) {\n      out: while (true) {\n        while (this.slopeCount > 1.0) {\n          this.slopeCount -= 1.0;\n          used++;\n\n          if (used >= numFrames - 1) {\n            break out;\n          }\n        }\n\n        var srcIndex = srcOffset + 2 * used;\n        dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * src[srcIndex] + this.slopeCount * src[srcIndex + 2];\n        dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * src[srcIndex + 1] + this.slopeCount * src[srcIndex + 3];\n        i++;\n        this.slopeCount += this._rate;\n      }\n    }\n\n    this.prevSampleL = src[srcOffset + 2 * numFrames - 2];\n    this.prevSampleR = src[srcOffset + 2 * numFrames - 1];\n    return i;\n  }\n});\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nfunction FifoSampleBuffer() {\n  this._vector = new Float32Array();\n  this._position = 0;\n  this._frameCount = 0;\n}\n\n_c3 = FifoSampleBuffer;\nFifoSampleBuffer.prototype = {\n  get vector() {\n    return this._vector;\n  },\n\n  get position() {\n    return this._position;\n  },\n\n  get startIndex() {\n    return this._position * 2;\n  },\n\n  get frameCount() {\n    return this._frameCount;\n  },\n\n  get endIndex() {\n    return (this._position + this._frameCount) * 2;\n  },\n\n  clear: function () {\n    this.receive(this._frameCount);\n    this.rewind();\n  },\n  put: function (numFrames) {\n    this._frameCount += numFrames;\n  },\n  putSamples: function (samples, position, numFrames) {\n    position = position || 0;\n    var sourceOffset = position * 2;\n\n    if (!(numFrames >= 0)) {\n      numFrames = (samples.length - sourceOffset) / 2;\n    }\n\n    var numSamples = numFrames * 2;\n    this.ensureCapacity(numFrames + this._frameCount);\n    var destOffset = this.endIndex;\n\n    this._vector.set(samples.subarray(sourceOffset, sourceOffset + numSamples), destOffset);\n\n    this._frameCount += numFrames;\n  },\n  putBuffer: function (buffer, position, numFrames) {\n    position = position || 0;\n\n    if (!(numFrames >= 0)) {\n      numFrames = buffer.frameCount - position;\n    }\n\n    this.putSamples(buffer.vector, buffer.position + position, numFrames);\n  },\n  receive: function (numFrames) {\n    if (!(numFrames >= 0) || numFrames > this._frameCount) {\n      numFrames = this._frameCount;\n    }\n\n    this._frameCount -= numFrames;\n    this._position += numFrames;\n  },\n  receiveSamples: function (output, numFrames) {\n    var numSamples = numFrames * 2;\n    var sourceOffset = this.startIndex;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n    this.receive(numFrames);\n  },\n  extract: function (output, position, numFrames) {\n    var sourceOffset = this.startIndex + position * 2;\n    var numSamples = numFrames * 2;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n  },\n  ensureCapacity: function (numFrames) {\n    var minLength = numFrames * 2;\n\n    if (this._vector.length < minLength) {\n      var newVector = new Float32Array(minLength);\n      newVector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._vector = newVector;\n      this._position = 0;\n    } else {\n      this.rewind();\n    }\n  },\n  ensureAdditionalCapacity: function (numFrames) {\n    this.ensureCapacity(this.frameCount + numFrames);\n  },\n  rewind: function () {\n    if (this._position > 0) {\n      this._vector.set(this._vector.subarray(this.startIndex, this.endIndex));\n\n      this._position = 0;\n    }\n  }\n};\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nfunction FilterSupport(pipe) {\n  this._pipe = pipe;\n}\n\n_c4 = FilterSupport;\nFilterSupport.prototype = {\n  get pipe() {\n    return this._pipe;\n  },\n\n  get inputBuffer() {\n    return this._pipe.inputBuffer;\n  },\n\n  get outputBuffer() {\n    return this._pipe.outputBuffer;\n  },\n\n  // fillInputBuffer: function(numFrames) {\n  //     throw new Error(\"fillInputBuffer() not overridden\");\n  // },\n  fillOutputBuffer: function (numFrames) {\n    while (this.outputBuffer.frameCount < numFrames) {\n      // TODO hardcoded buffer size\n      var numInputFrames = 8192 * 2 - this.inputBuffer.frameCount;\n      this.fillInputBuffer(numInputFrames);\n\n      if (this.inputBuffer.frameCount < 8192 * 2) {\n        break; // TODO flush pipe\n      }\n\n      this._pipe.process();\n    }\n  },\n  clear: function () {\n    this._pipe.clear();\n  }\n};\n\nfunction SimpleFilter(sourceSound, pipe) {\n  FilterSupport.call(this, pipe);\n  this.sourceSound = sourceSound;\n  this.historyBufferSize = 22050;\n  this._sourcePosition = 0;\n  this.outputBufferPosition = 0;\n  this._position = 0;\n}\n\n_c5 = SimpleFilter;\nextend(SimpleFilter.prototype, FilterSupport.prototype);\nextend(SimpleFilter.prototype, {\n  get position() {\n    return this._position;\n  },\n\n  set position(position) {\n    if (position > this._position) {\n      throw new RangeError('New position may not be greater than current position');\n    }\n\n    var newOutputBufferPosition = this.outputBufferPosition - (this._position - position);\n\n    if (newOutputBufferPosition < 0) {\n      throw new RangeError('New position falls outside of history buffer');\n    }\n\n    this.outputBufferPosition = newOutputBufferPosition;\n    this._position = position;\n  },\n\n  get sourcePosition() {\n    return this._sourcePosition;\n  },\n\n  set sourcePosition(sourcePosition) {\n    this.clear();\n    this._sourcePosition = sourcePosition;\n  },\n\n  fillInputBuffer: function (numFrames) {\n    var samples = new Float32Array(numFrames * 2);\n    var numFramesExtracted = this.sourceSound.extract(samples, numFrames, this._sourcePosition);\n    this._sourcePosition += numFramesExtracted;\n    this.inputBuffer.putSamples(samples, 0, numFramesExtracted);\n  },\n  extract: function (target, numFrames) {\n    this.fillOutputBuffer(this.outputBufferPosition + numFrames);\n    var numFramesExtracted = Math.min(numFrames, this.outputBuffer.frameCount - this.outputBufferPosition);\n    this.outputBuffer.extract(target, this.outputBufferPosition, numFramesExtracted);\n    var currentFrames = this.outputBufferPosition + numFramesExtracted;\n    this.outputBufferPosition = Math.min(this.historyBufferSize, currentFrames);\n    this.outputBuffer.receive(Math.max(currentFrames - this.historyBufferSize, 0));\n    this._position += numFramesExtracted;\n    return numFramesExtracted;\n  },\n  handleSampleData: function (e) {\n    this.extract(e.data, 4096);\n  },\n  clear: function () {\n    // TODO yuck\n    FilterSupport.prototype.clear.call(this);\n    this.outputBufferPosition = 0;\n  }\n});\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n//'use strict';\n\n/**\n* Giving this value for the sequence length sets automatic parameter value\n* according to tempo setting (recommended)\n*/\n\nvar USE_AUTO_SEQUENCE_LEN = 0;\n/**\n* Default length of a single processing sequence, in milliseconds. This determines to how\n* long sequences the original sound is chopped in the time-stretch algorithm.\n*\n* The larger this value is, the lesser sequences are used in processing. In principle\n* a bigger value sounds better when slowing down tempo, but worse when increasing tempo\n* and vice versa.\n*\n* Increasing this value reduces computational burden and vice versa.\n*/\n//var DEFAULT_SEQUENCE_MS = 130\n\nvar DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN;\n/**\n* Giving this value for the seek window length sets automatic parameter value\n* according to tempo setting (recommended)\n*/\n\nvar USE_AUTO_SEEKWINDOW_LEN = 0;\n/**\n* Seeking window default length in milliseconds for algorithm that finds the best possible\n* overlapping location. This determines from how wide window the algorithm may look for an\n* optimal joining location when mixing the sound sequences back together.\n*\n* The bigger this window setting is, the higher the possibility to find a better mixing\n* position will become, but at the same time large values may cause a \"drifting\" artifact\n* because consequent sequences will be taken at more uneven intervals.\n*\n* If there's a disturbing artifact that sounds as if a constant frequency was drifting\n* around, try reducing this setting.\n*\n* Increasing this value increases computational burden and vice versa.\n*/\n//var DEFAULT_SEEKWINDOW_MS = 25;\n\nvar DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN;\n/**\n* Overlap length in milliseconds. When the chopped sound sequences are mixed back together,\n* to form a continuous sound stream, this parameter defines over how long period the two\n* consecutive sequences are let to overlap each other.\n*\n* This shouldn't be that critical parameter. If you reduce the DEFAULT_SEQUENCE_MS setting\n* by a large amount, you might wish to try a smaller value on this.\n*\n* Increasing this value increases computational burden and vice versa.\n*/\n\nvar DEFAULT_OVERLAP_MS = 8; // Table for the hierarchical mixing position seeking algorithm\n\nvar _SCAN_OFFSETS = [[124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0], [-100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]; // Adjust tempo param according to tempo, so that variating processing sequence length is used\n// at varius tempo settings, between the given low...top limits\n\nvar AUTOSEQ_TEMPO_LOW = 0.5; // auto setting low tempo range (-50%)\n\nvar AUTOSEQ_TEMPO_TOP = 2.0; // auto setting top tempo range (+100%)\n// sequence-ms setting values at above low & top tempo\n\nvar AUTOSEQ_AT_MIN = 125.0;\nvar AUTOSEQ_AT_MAX = 50.0;\nvar AUTOSEQ_K = (AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nvar AUTOSEQ_C = AUTOSEQ_AT_MIN - AUTOSEQ_K * AUTOSEQ_TEMPO_LOW; // seek-window-ms setting values at above low & top tempo\n\nvar AUTOSEEK_AT_MIN = 25.0;\nvar AUTOSEEK_AT_MAX = 15.0;\nvar AUTOSEEK_K = (AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nvar AUTOSEEK_C = AUTOSEEK_AT_MIN - AUTOSEEK_K * AUTOSEQ_TEMPO_LOW;\n\nfunction Stretch(createBuffers) {\n  AbstractFifoSamplePipe.call(this, createBuffers);\n  this.bQuickSeek = true;\n  this.bMidBufferDirty = false;\n  this.pMidBuffer = null;\n  this.overlapLength = 0;\n  this.bAutoSeqSetting = true;\n  this.bAutoSeekSetting = true;\n  this._tempo = 1;\n  this.setParameters(44100, DEFAULT_SEQUENCE_MS, DEFAULT_SEEKWINDOW_MS, DEFAULT_OVERLAP_MS);\n}\n\n_c6 = Stretch;\nextend(Stretch.prototype, AbstractFifoSamplePipe.prototype);\nextend(Stretch.prototype, {\n  clear: function () {\n    AbstractFifoSamplePipe.prototype.clear.call(this);\n\n    this._clearMidBuffer();\n  },\n  _clearMidBuffer: function () {\n    if (this.bMidBufferDirty) {\n      this.bMidBufferDirty = false;\n      this.pMidBuffer = null;\n    }\n  },\n\n  /**\n  * Sets routine control parameters. These control are certain time constants\n  * defining how the sound is stretched to the desired duration.\n  *\n  * 'sampleRate' = sample rate of the sound\n  * 'sequenceMS' = one processing sequence length in milliseconds (default = 82 ms)\n  * 'seekwindowMS' = seeking window length for scanning the best overlapping\n  *      position (default = 28 ms)\n  * 'overlapMS' = overlapping length (default = 12 ms)\n  */\n  setParameters: function (aSampleRate, aSequenceMS, aSeekWindowMS, aOverlapMS) {\n    // accept only positive parameter values - if zero or negative, use old values instead\n    if (aSampleRate > 0) {\n      this.sampleRate = aSampleRate;\n    }\n\n    if (aOverlapMS > 0) {\n      this.overlapMs = aOverlapMS;\n    }\n\n    if (aSequenceMS > 0) {\n      this.sequenceMs = aSequenceMS;\n      this.bAutoSeqSetting = false;\n    } else {\n      // zero or below, use automatic setting\n      this.bAutoSeqSetting = true;\n    }\n\n    if (aSeekWindowMS > 0) {\n      this.seekWindowMs = aSeekWindowMS;\n      this.bAutoSeekSetting = false;\n    } else {\n      // zero or below, use automatic setting\n      this.bAutoSeekSetting = true;\n    }\n\n    this.calcSeqParameters();\n    this.calculateOverlapLength(this.overlapMs); // set tempo to recalculate 'sampleReq'\n\n    this.tempo = this._tempo;\n  },\n\n  /**\n  * Sets new target tempo. Normal tempo = 'SCALE', smaller values represent slower\n  * tempo, larger faster tempo.\n  */\n  set tempo(newTempo) {\n    var intskip;\n    this._tempo = newTempo; // Calculate new sequence duration\n\n    this.calcSeqParameters(); // Calculate ideal skip length (according to tempo value)\n\n    this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength);\n    this.skipFract = 0;\n    intskip = Math.floor(this.nominalSkip + 0.5); // Calculate how many samples are needed in the 'inputBuffer' to\n    // process another batch of samples\n\n    this.sampleReq = Math.max(intskip + this.overlapLength, this.seekWindowLength) + this.seekLength;\n  },\n\n  // get tempo() {\n  //   return this._tempo;\n  // },\n  get inputChunkSize() {\n    return this.sampleReq;\n  },\n\n  get outputChunkSize() {\n    return this.overlapLength + Math.max(0, this.seekWindowLength - 2 * this.overlapLength);\n  },\n\n  /**\n  * Calculates overlapInMsec period length in samples.\n  */\n  calculateOverlapLength: function (overlapInMsec) {\n    var newOvl; // TODO assert(overlapInMsec >= 0);\n\n    newOvl = this.sampleRate * overlapInMsec / 1000;\n    if (newOvl < 16) newOvl = 16; // must be divisible by 8\n\n    newOvl -= newOvl % 8;\n    this.overlapLength = newOvl;\n    this.pRefMidBuffer = new Float32Array(this.overlapLength * 2);\n    this.pMidBuffer = new Float32Array(this.overlapLength * 2);\n  },\n  checkLimits: function (x, mi, ma) {\n    return x < mi ? mi : x > ma ? ma : x;\n  },\n\n  /**\n  * Calculates processing sequence length according to tempo setting\n  */\n  calcSeqParameters: function () {\n    var seq;\n    var seek;\n\n    if (this.bAutoSeqSetting) {\n      seq = AUTOSEQ_C + AUTOSEQ_K * this._tempo;\n      seq = this.checkLimits(seq, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN);\n      this.sequenceMs = Math.floor(seq + 0.5);\n    }\n\n    if (this.bAutoSeekSetting) {\n      seek = AUTOSEEK_C + AUTOSEEK_K * this._tempo;\n      seek = this.checkLimits(seek, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN);\n      this.seekWindowMs = Math.floor(seek + 0.5);\n    } // Update seek window lengths\n\n\n    this.seekWindowLength = Math.floor(this.sampleRate * this.sequenceMs / 1000);\n    this.seekLength = Math.floor(this.sampleRate * this.seekWindowMs / 1000);\n  },\n\n  /**\n  * Enables/disables the quick position seeking algorithm.\n  */\n  set quickSeek(enable) {\n    this.bQuickSeek = enable;\n  },\n\n  clone: function () {\n    var result = new Stretch();\n    result.tempo = this.tempo;\n    result.setParameters(this.sampleRate, this.sequenceMs, this.seekWindowMs, this.overlapMs);\n    return result;\n  },\n\n  /**\n  * Seeks for the optimal overlap-mixing position.\n  */\n  seekBestOverlapPosition: function () {\n    if (this.bQuickSeek) {\n      return this.seekBestOverlapPositionStereoQuick();\n    } else {\n      return this.seekBestOverlapPositionStereo();\n    }\n  },\n\n  /**\n  * Seeks for the optimal overlap-mixing position. The 'stereo' version of the\n  * routine\n  *\n  * The best position is determined as the position where the two overlapped\n  * sample sequences are 'most alike', in terms of the highest cross-correlation\n  * value over the overlapping period\n  */\n  seekBestOverlapPositionStereo: function () {\n    var bestOffs;\n    var bestCorr;\n    var corr;\n    var i; // Slopes the amplitudes of the 'midBuffer' samples\n\n    this.precalcCorrReferenceStereo();\n    bestCorr = Number.MIN_VALUE;\n    bestOffs = 0; // Scans for the best correlation value by testing each possible position\n    // over the permitted range.\n\n    for (i = 0; i < this.seekLength; i++) {\n      // Calculates correlation value for the mixing position corresponding\n      // to 'i'\n      corr = this.calcCrossCorrStereo(2 * i, this.pRefMidBuffer); // Checks for the highest correlation value\n\n      if (corr > bestCorr) {\n        bestCorr = corr;\n        bestOffs = i;\n      }\n    }\n\n    return bestOffs;\n  },\n\n  /**\n  * Seeks for the optimal overlap-mixing position. The 'stereo' version of the\n  * routine\n  *\n  * The best position is determined as the position where the two overlapped\n  * sample sequences are 'most alike', in terms of the highest cross-correlation\n  * value over the overlapping period\n  */\n  seekBestOverlapPositionStereoQuick: function () {\n    var j;\n    var bestOffs;\n    var bestCorr;\n    var corr;\n    var scanCount;\n    var corrOffset;\n    var tempOffset; // Slopes the amplitude of the 'midBuffer' samples\n\n    this.precalcCorrReferenceStereo();\n    bestCorr = Number.MIN_VALUE;\n    bestOffs = 0;\n    corrOffset = 0;\n    tempOffset = 0; // Scans for the best correlation value using four-pass hierarchical search.\n    //\n    // The look-up table 'scans' has hierarchical position adjusting steps.\n    // In first pass the routine searhes for the highest correlation with\n    // relatively coarse steps, then rescans the neighbourhood of the highest\n    // correlation with better resolution and so on.\n\n    for (scanCount = 0; scanCount < 4; scanCount++) {\n      j = 0;\n\n      while (_SCAN_OFFSETS[scanCount][j]) {\n        tempOffset = corrOffset + _SCAN_OFFSETS[scanCount][j];\n        if (tempOffset >= this.seekLength) break; // Calculates correlation value for the mixing position corresponding\n        // to 'tempOffset'\n\n        corr = this.calcCrossCorrStereo(2 * tempOffset, this.pRefMidBuffer); // Checks for the highest correlation value\n\n        if (corr > bestCorr) {\n          bestCorr = corr;\n          bestOffs = tempOffset;\n        }\n\n        j++;\n      }\n\n      corrOffset = bestOffs;\n    }\n\n    return bestOffs;\n  },\n\n  /**\n  * Slopes the amplitude of the 'midBuffer' samples so that cross correlation\n  * is faster to calculate\n  */\n  precalcCorrReferenceStereo: function () {\n    var i;\n    var cnt2;\n    var temp;\n\n    for (i = 0; i < this.overlapLength; i++) {\n      temp = i * (this.overlapLength - i);\n      cnt2 = i * 2;\n      this.pRefMidBuffer[cnt2] = this.pMidBuffer[cnt2] * temp;\n      this.pRefMidBuffer[cnt2 + 1] = this.pMidBuffer[cnt2 + 1] * temp;\n    }\n  },\n  calcCrossCorrStereo: function (mixingPos, compare) {\n    var mixing = this._inputBuffer.vector;\n    mixingPos += this._inputBuffer.startIndex;\n    var corr;\n    var i;\n    var mixingOffset;\n    corr = 0;\n\n    for (i = 2; i < 2 * this.overlapLength; i += 2) {\n      mixingOffset = i + mixingPos;\n      corr += mixing[mixingOffset] * compare[i] + mixing[mixingOffset + 1] * compare[i + 1];\n    }\n\n    return corr;\n  },\n  // TODO inline\n\n  /**\n  * Overlaps samples in 'midBuffer' with the samples in 'pInputBuffer' at position\n  * of 'ovlPos'.\n  */\n  overlap: function (ovlPos) {\n    this.overlapStereo(2 * ovlPos);\n  },\n\n  /**\n  * Overlaps samples in 'midBuffer' with the samples in 'pInput'\n  */\n  overlapStereo: function (pInputPos) {\n    var pInput = this._inputBuffer.vector;\n    pInputPos += this._inputBuffer.startIndex;\n    var pOutput = this._outputBuffer.vector;\n    var pOutputPos = this._outputBuffer.endIndex;\n    var i;\n    var cnt2;\n    var fTemp;\n    var fScale;\n    var fi;\n    var pInputOffset;\n    var pOutputOffset;\n    fScale = 1 / this.overlapLength;\n\n    for (i = 0; i < this.overlapLength; i++) {\n      fTemp = (this.overlapLength - i) * fScale;\n      fi = i * fScale;\n      cnt2 = 2 * i;\n      pInputOffset = cnt2 + pInputPos;\n      pOutputOffset = cnt2 + pOutputPos;\n      pOutput[pOutputOffset + 0] = pInput[pInputOffset + 0] * fi + this.pMidBuffer[cnt2 + 0] * fTemp;\n      pOutput[pOutputOffset + 1] = pInput[pInputOffset + 1] * fi + this.pMidBuffer[cnt2 + 1] * fTemp;\n    }\n  },\n  process: function () {\n    var ovlSkip;\n    var offset;\n    var temp;\n    var i;\n\n    if (this.pMidBuffer == null) {\n      // if midBuffer is empty, move the first samples of the input stream\n      // into it\n      if (this._inputBuffer.frameCount < this.overlapLength) {\n        // wait until we've got overlapLength samples\n        return;\n      }\n\n      this.pMidBuffer = new Float32Array(this.overlapLength * 2);\n\n      this._inputBuffer.receiveSamples(this.pMidBuffer, this.overlapLength);\n    }\n\n    var output; // Process samples as long as there are enough samples in 'inputBuffer'\n    // to form a processing frame.\n\n    while (this._inputBuffer.frameCount >= this.sampleReq) {\n      // If tempo differs from the normal ('SCALE'), scan for the best overlapping\n      // position\n      offset = this.seekBestOverlapPosition(); // Mix the samples in the 'inputBuffer' at position of 'offset' with the\n      // samples in 'midBuffer' using sliding overlapping\n      // ... first partially overlap with the end of the previous sequence\n      // (that's in 'midBuffer')\n\n      this._outputBuffer.ensureAdditionalCapacity(this.overlapLength); // FIXME unit?\n      //overlap(uint(offset));\n\n\n      this.overlap(Math.floor(offset));\n\n      this._outputBuffer.put(this.overlapLength); // ... then copy sequence samples from 'inputBuffer' to output\n\n\n      temp = this.seekWindowLength - 2 * this.overlapLength; // & 0xfffffffe;\n\n      if (temp > 0) {\n        this._outputBuffer.putBuffer(this._inputBuffer, offset + this.overlapLength, temp);\n      } // Copies the end of the current sequence from 'inputBuffer' to\n      // 'midBuffer' for being mixed with the beginning of the next\n      // processing sequence and so on\n      //assert(offset + seekWindowLength <= (int)inputBuffer.numSamples());\n\n\n      var start = this.inputBuffer.startIndex + 2 * (offset + this.seekWindowLength - this.overlapLength);\n      this.pMidBuffer.set(this._inputBuffer.vector.subarray(start, start + 2 * this.overlapLength)); // Remove the processed samples from the input buffer. Update\n      // the difference between integer & nominal skip step to 'skipFract'\n      // in order to prevent the error from accumulating over time.\n\n      this.skipFract += this.nominalSkip; // real skip size\n\n      ovlSkip = Math.floor(this.skipFract); // rounded to integer skip\n\n      this.skipFract -= ovlSkip; // maintain the fraction part, i.e. real vs. integer skip\n\n      this._inputBuffer.receive(ovlSkip);\n    }\n  }\n}); // https://bugs.webkit.org/show_bug.cgi?id=57295\n\nextend(Stretch.prototype, {\n  get tempo() {\n    return this._tempo;\n  }\n\n});\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nfunction SoundTouch() {\n  this.rateTransposer = new RateTransposer(false);\n  this.tdStretch = new Stretch(false);\n  this._inputBuffer = new FifoSampleBuffer();\n  this._intermediateBuffer = new FifoSampleBuffer();\n  this._outputBuffer = new FifoSampleBuffer();\n  this._rate = 0;\n  this.tempo = 0;\n  this.virtualPitch = 1.0;\n  this.virtualRate = 1.0;\n  this.virtualTempo = 1.0;\n\n  this._calculateEffectiveRateAndTempo();\n}\n\n_c7 = SoundTouch;\nextend(SoundTouch.prototype, {\n  clear: function () {\n    this.rateTransposer.clear();\n    this.tdStretch.clear();\n  },\n  clone: function () {\n    var result = new SoundTouch();\n    result.rate = rate;\n    result.tempo = tempo;\n    return result;\n  },\n\n  get rate() {\n    return this._rate;\n  },\n\n  set rate(rate) {\n    this.virtualRate = rate;\n\n    this._calculateEffectiveRateAndTempo();\n  },\n\n  set rateChange(rateChange) {\n    this.rate = 1.0 + 0.01 * rateChange;\n  },\n\n  get tempo() {\n    return this._tempo;\n  },\n\n  set tempo(tempo) {\n    this.virtualTempo = tempo;\n\n    this._calculateEffectiveRateAndTempo();\n  },\n\n  set tempoChange(tempoChange) {\n    this.tempo = 1.0 + 0.01 * tempoChange;\n  },\n\n  set pitch(pitch) {\n    this.virtualPitch = pitch;\n\n    this._calculateEffectiveRateAndTempo();\n  },\n\n  set pitchOctaves(pitchOctaves) {\n    this.pitch = Math.exp(0.69314718056 * pitchOctaves);\n\n    this._calculateEffectiveRateAndTempo();\n  },\n\n  set pitchSemitones(pitchSemitones) {\n    this.pitchOctaves = pitchSemitones / 12.0;\n  },\n\n  get inputBuffer() {\n    return this._inputBuffer;\n  },\n\n  get outputBuffer() {\n    return this._outputBuffer;\n  },\n\n  _calculateEffectiveRateAndTempo: function () {\n    var previousTempo = this._tempo;\n    var previousRate = this._rate;\n    this._tempo = this.virtualTempo / this.virtualPitch;\n    this._rate = this.virtualRate * this.virtualPitch;\n\n    if (testFloatEqual(this._tempo, previousTempo)) {\n      this.tdStretch.tempo = this._tempo;\n    }\n\n    if (testFloatEqual(this._rate, previousRate)) {\n      this.rateTransposer.rate = this._rate;\n    }\n\n    if (this._rate > 1.0) {\n      if (this._outputBuffer != this.rateTransposer.outputBuffer) {\n        this.tdStretch.inputBuffer = this._inputBuffer;\n        this.tdStretch.outputBuffer = this._intermediateBuffer;\n        this.rateTransposer.inputBuffer = this._intermediateBuffer;\n        this.rateTransposer.outputBuffer = this._outputBuffer;\n      }\n    } else {\n      if (this._outputBuffer != this.tdStretch.outputBuffer) {\n        this.rateTransposer.inputBuffer = this._inputBuffer;\n        this.rateTransposer.outputBuffer = this._intermediateBuffer;\n        this.tdStretch.inputBuffer = this._intermediateBuffer;\n        this.tdStretch.outputBuffer = this._outputBuffer;\n      }\n    }\n  },\n  process: function () {\n    if (this._rate > 1.0) {\n      this.tdStretch.process();\n      this.rateTransposer.process();\n    } else {\n      this.rateTransposer.process();\n      this.tdStretch.process();\n    }\n  }\n}); // This is the only part that was added for screw (plus fixing a couple typos where `this` was\n// erroneously not used)\n\nmodule.exports = {\n  SimpleFilter,\n  SoundTouch\n};\n\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7;\n\n$RefreshReg$(_c, \"AbstractFifoSamplePipe\");\n$RefreshReg$(_c2, \"RateTransposer\");\n$RefreshReg$(_c3, \"FifoSampleBuffer\");\n$RefreshReg$(_c4, \"FilterSupport\");\n$RefreshReg$(_c5, \"SimpleFilter\");\n$RefreshReg$(_c6, \"Stretch\");\n$RefreshReg$(_c7, \"SoundTouch\");","map":{"version":3,"sources":["/Users/jonkim/my-app/src/vendor/soundtouch.js"],"names":["extend","a","b","i","g","__lookupGetter__","s","__lookupSetter__","__defineGetter__","__defineSetter__","testFloatEqual","AbstractFifoSamplePipe","createBuffers","inputBuffer","FifoSampleBuffer","outputBuffer","prototype","_inputBuffer","_outputBuffer","clear","RateTransposer","call","_reset","rate","_rate","slopeCount","prevSampleL","prevSampleR","clone","result","process","numFrames","frameCount","ensureAdditionalCapacity","numFramesOutput","_transpose","receive","put","src","vector","srcOffset","startIndex","dest","destOffset","endIndex","used","out","srcIndex","_vector","Float32Array","_position","_frameCount","position","rewind","putSamples","samples","sourceOffset","length","numSamples","ensureCapacity","set","subarray","putBuffer","buffer","receiveSamples","output","extract","minLength","newVector","FilterSupport","pipe","_pipe","fillOutputBuffer","numInputFrames","fillInputBuffer","SimpleFilter","sourceSound","historyBufferSize","_sourcePosition","outputBufferPosition","RangeError","newOutputBufferPosition","sourcePosition","numFramesExtracted","target","Math","min","currentFrames","max","handleSampleData","e","data","USE_AUTO_SEQUENCE_LEN","DEFAULT_SEQUENCE_MS","USE_AUTO_SEEKWINDOW_LEN","DEFAULT_SEEKWINDOW_MS","DEFAULT_OVERLAP_MS","_SCAN_OFFSETS","AUTOSEQ_TEMPO_LOW","AUTOSEQ_TEMPO_TOP","AUTOSEQ_AT_MIN","AUTOSEQ_AT_MAX","AUTOSEQ_K","AUTOSEQ_C","AUTOSEEK_AT_MIN","AUTOSEEK_AT_MAX","AUTOSEEK_K","AUTOSEEK_C","Stretch","bQuickSeek","bMidBufferDirty","pMidBuffer","overlapLength","bAutoSeqSetting","bAutoSeekSetting","_tempo","setParameters","_clearMidBuffer","aSampleRate","aSequenceMS","aSeekWindowMS","aOverlapMS","sampleRate","overlapMs","sequenceMs","seekWindowMs","calcSeqParameters","calculateOverlapLength","tempo","newTempo","intskip","nominalSkip","seekWindowLength","skipFract","floor","sampleReq","seekLength","inputChunkSize","outputChunkSize","overlapInMsec","newOvl","pRefMidBuffer","checkLimits","x","mi","ma","seq","seek","quickSeek","enable","seekBestOverlapPosition","seekBestOverlapPositionStereoQuick","seekBestOverlapPositionStereo","bestOffs","bestCorr","corr","precalcCorrReferenceStereo","Number","MIN_VALUE","calcCrossCorrStereo","j","scanCount","corrOffset","tempOffset","cnt2","temp","mixingPos","compare","mixing","mixingOffset","overlap","ovlPos","overlapStereo","pInputPos","pInput","pOutput","pOutputPos","fTemp","fScale","fi","pInputOffset","pOutputOffset","ovlSkip","offset","start","SoundTouch","rateTransposer","tdStretch","_intermediateBuffer","virtualPitch","virtualRate","virtualTempo","_calculateEffectiveRateAndTempo","rateChange","tempoChange","pitch","pitchOctaves","exp","pitchSemitones","previousTempo","previousRate","module","exports"],"mappings":"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","sourcesContent":["/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nfunction extend(a,b) {\n    for ( var i in b ) {\n        var g = b.__lookupGetter__(i), s = b.__lookupSetter__(i);\n       \n        if ( g || s ) {\n            if ( g )\n                a.__defineGetter__(i, g);\n            if ( s )\n                a.__defineSetter__(i, s);\n         } else\n             a[i] = b[i];\n    }\n    return a;\n}\n\nfunction testFloatEqual(a, b) {\n    return (a > b ? a - b : b - a) > 1e-10;\n}\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n\nfunction AbstractFifoSamplePipe(createBuffers) {\n    if (createBuffers) {\n        this.inputBuffer = new FifoSampleBuffer();\n        this.outputBuffer = new FifoSampleBuffer();\n    }\n    else {\n        this.inputBuffer = this.outputBuffer = null;\n    }\n}\n        \nAbstractFifoSamplePipe.prototype = {\n    get inputBuffer() {\n        return this._inputBuffer;\n    },\n\n    set inputBuffer (inputBuffer) {\n      this._inputBuffer = inputBuffer;\n    },\n\n    get outputBuffer() {\n        return this._outputBuffer;\n    },\n\n    set outputBuffer(outputBuffer) {\n      this._outputBuffer = outputBuffer;\n    },\n\n    clear: function () {\n        this._inputBuffer.clear();\n        this._outputBuffer.clear();\n    }\n};\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nfunction RateTransposer(createBuffers) {\n    AbstractFifoSamplePipe.call(this, createBuffers);\n    this._reset();\n    this.rate = 1;\n}\n\nextend(RateTransposer.prototype, AbstractFifoSamplePipe.prototype);\nextend(RateTransposer.prototype, {\n    set rate(rate) {\n        this._rate = rate;\n        // TODO aa filter\n    },\n\n    _reset: function () {\n        this.slopeCount = 0;\n        this.prevSampleL = 0;\n        this.prevSampleR = 0;\n    },\n\n    clone: function () {\n        var result = new RateTransposer();\n        result.rate = this._rate;\n        return result;\n    },\n\n    process: function () {\n        // TODO aa filter\n        var numFrames = this._inputBuffer.frameCount;\n        this._outputBuffer.ensureAdditionalCapacity(numFrames / this._rate + 1);\n        var numFramesOutput = this._transpose(numFrames);\n        this._inputBuffer.receive();\n        this._outputBuffer.put(numFramesOutput);\n    },\n\n    _transpose: function (numFrames) {\n        if (numFrames == 0) {\n            // no work\n            return 0;\n        }\n\n        var src = this._inputBuffer.vector;\n        var srcOffset = this._inputBuffer.startIndex;\n\n        var dest = this._outputBuffer.vector;\n        var destOffset = this._outputBuffer.endIndex;\n\n        var used = 0;\n        var i = 0;\n\n        while(this.slopeCount < 1.0) {\n            dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * this.prevSampleL + this.slopeCount * src[srcOffset];\n            dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * this.prevSampleR + this.slopeCount * src[srcOffset + 1];\n            i++;\n            this.slopeCount += this._rate;\n        }\n\n        this.slopeCount -= 1.0;\n\n        if (numFrames != 1) {\n            out: while (true) {\n                while (this.slopeCount > 1.0) {\n                    this.slopeCount -= 1.0;\n                    used++;\n                    if (used >= numFrames - 1) {\n                        break out;\n                    }\n                }\n\n                var srcIndex = srcOffset + 2 * used;\n                dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * src[srcIndex] + this.slopeCount * src[srcIndex + 2];\n                dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * src[srcIndex + 1] + this.slopeCount * src[srcIndex + 3];\n\n                i++;\n                this.slopeCount += this._rate;\n            }\n        }\n\n        this.prevSampleL = src[srcOffset + 2 * numFrames - 2];\n        this.prevSampleR = src[srcOffset + 2 * numFrames - 1];\n\n        return i;\n    }\n});\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nfunction FifoSampleBuffer() {\n    this._vector = new Float32Array();\n    this._position = 0;\n    this._frameCount = 0;\n}\n\nFifoSampleBuffer.prototype = {\n    get vector() {\n        return this._vector;\n    },\n\n    get position() {\n        return this._position;\n    },\n\n    get startIndex() {\n        return this._position * 2;\n    },\n\n    get frameCount() {\n        return this._frameCount;\n    },\n\n    get endIndex() {\n        return (this._position + this._frameCount) * 2;\n    },\n\n    clear: function() {\n        this.receive(this._frameCount);\n        this.rewind();\n    },\n\n    put: function (numFrames) {\n        this._frameCount += numFrames;\n    },\n\n    putSamples: function (samples, position, numFrames) {\n        position = position || 0;\n        var sourceOffset = position * 2;\n        if (!(numFrames >= 0)) {\n            numFrames = (samples.length - sourceOffset) / 2;\n        }\n        var numSamples = numFrames * 2;\n\n        this.ensureCapacity(numFrames + this._frameCount);\n\n        var destOffset = this.endIndex;\n        this._vector.set(samples.subarray(sourceOffset, sourceOffset + numSamples), destOffset);\n\n        this._frameCount += numFrames;\n    },\n\n    putBuffer: function (buffer, position, numFrames) {\n        position = position || 0;\n        if (!(numFrames >= 0)) {\n            numFrames = buffer.frameCount - position;\n        }\n        this.putSamples(buffer.vector, buffer.position + position, numFrames);\n    },\n\n    receive: function (numFrames) {\n        if (!(numFrames >= 0) || numFrames > this._frameCount) {\n            numFrames = this._frameCount\n        }\n        this._frameCount -= numFrames;\n        this._position += numFrames;\n    },\n\n    receiveSamples: function (output, numFrames) {\n        var numSamples = numFrames * 2;\n        var sourceOffset = this.startIndex;\n        output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n        this.receive(numFrames);\n    },\n\n    extract: function (output, position, numFrames) {\n        var sourceOffset = this.startIndex + position * 2;\n        var numSamples = numFrames * 2;\n        output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n    },\n\n    ensureCapacity: function (numFrames) {\n        var minLength = numFrames * 2;\n        if (this._vector.length < minLength) {\n            var newVector = new Float32Array(minLength);\n            newVector.set(this._vector.subarray(this.startIndex, this.endIndex));\n            this._vector = newVector;\n            this._position = 0;\n        }\n        else {\n            this.rewind();\n        }\n    },\n\n    ensureAdditionalCapacity: function (numFrames) {\n        this.ensureCapacity(this.frameCount + numFrames);\n    },\n\n    rewind: function () {\n        if (this._position > 0) {\n            this._vector.set(this._vector.subarray(this.startIndex, this.endIndex));\n            this._position = 0;\n        }\n    }\n};\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nfunction FilterSupport(pipe) {\n    this._pipe = pipe;\n}\n\nFilterSupport.prototype = {\n    get pipe() {\n        return this._pipe;\n    },\n\n    get inputBuffer() {\n        return this._pipe.inputBuffer;\n    },\n\n    get outputBuffer() {\n        return this._pipe.outputBuffer;\n    },\n\n    // fillInputBuffer: function(numFrames) {\n    //     throw new Error(\"fillInputBuffer() not overridden\");\n    // },\n\n    fillOutputBuffer: function(numFrames) {\n        while (this.outputBuffer.frameCount < numFrames) {\n            // TODO hardcoded buffer size\n            var numInputFrames = (8192 * 2) - this.inputBuffer.frameCount;\n\n            this.fillInputBuffer(numInputFrames);\n\n            if (this.inputBuffer.frameCount < (8192 * 2)) {\n                break;\n                // TODO flush pipe\n            }\n            this._pipe.process();\n        }\n    },\n\n    clear: function() {\n        this._pipe.clear();\n    }\n};\n\nfunction SimpleFilter(sourceSound, pipe) {\n    FilterSupport.call(this, pipe);\n    this.sourceSound = sourceSound;\n    this.historyBufferSize = 22050;\n    this._sourcePosition = 0;\n    this.outputBufferPosition = 0;\n    this._position = 0;\n}\n\nextend(SimpleFilter.prototype, FilterSupport.prototype);\n\nextend(SimpleFilter.prototype, {\n    get position() {\n        return this._position;\n    },\n\n    set position(position) {\n        if (position > this._position) {\n            throw new RangeError('New position may not be greater than current position');\n        }\n        var newOutputBufferPosition = this.outputBufferPosition - (this._position - position);\n        if (newOutputBufferPosition < 0) {\n            throw new RangeError('New position falls outside of history buffer');\n        }\n        this.outputBufferPosition = newOutputBufferPosition;\n        this._position = position;\n    },\n\n    get sourcePosition() {\n        return this._sourcePosition;\n    },\n\n    set sourcePosition(sourcePosition) {\n        this.clear();\n        this._sourcePosition = sourcePosition;\n    },\n\n    fillInputBuffer: function(numFrames) {\n        var samples = new Float32Array(numFrames * 2);\n        var numFramesExtracted = this.sourceSound.extract(samples, numFrames, this._sourcePosition);\n        this._sourcePosition += numFramesExtracted;\n        this.inputBuffer.putSamples(samples, 0, numFramesExtracted);\n    },\n\n    extract: function(target, numFrames) {\n        this.fillOutputBuffer(this.outputBufferPosition + numFrames);\n\n        var numFramesExtracted = Math.min(numFrames, this.outputBuffer.frameCount - this.outputBufferPosition);\n        this.outputBuffer.extract(target, this.outputBufferPosition, numFramesExtracted);\n\n        var currentFrames = this.outputBufferPosition + numFramesExtracted;\n        this.outputBufferPosition = Math.min(this.historyBufferSize, currentFrames);\n        this.outputBuffer.receive(Math.max(currentFrames - this.historyBufferSize, 0));\n\n        this._position += numFramesExtracted;\n        return numFramesExtracted;\n    },\n\n    handleSampleData: function(e) {\n        this.extract(e.data, 4096);\n    },\n\n    clear: function() {\n        // TODO yuck\n        FilterSupport.prototype.clear.call(this);\n        this.outputBufferPosition = 0;\n    }\n});\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n//'use strict';\n\n/**\n* Giving this value for the sequence length sets automatic parameter value\n* according to tempo setting (recommended)\n*/\nvar USE_AUTO_SEQUENCE_LEN = 0;\n\n/**\n* Default length of a single processing sequence, in milliseconds. This determines to how\n* long sequences the original sound is chopped in the time-stretch algorithm.\n*\n* The larger this value is, the lesser sequences are used in processing. In principle\n* a bigger value sounds better when slowing down tempo, but worse when increasing tempo\n* and vice versa.\n*\n* Increasing this value reduces computational burden and vice versa.\n*/\n//var DEFAULT_SEQUENCE_MS = 130\nvar DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN;\n\n/**\n* Giving this value for the seek window length sets automatic parameter value\n* according to tempo setting (recommended)\n*/\nvar USE_AUTO_SEEKWINDOW_LEN = 0;\n\n/**\n* Seeking window default length in milliseconds for algorithm that finds the best possible\n* overlapping location. This determines from how wide window the algorithm may look for an\n* optimal joining location when mixing the sound sequences back together.\n*\n* The bigger this window setting is, the higher the possibility to find a better mixing\n* position will become, but at the same time large values may cause a \"drifting\" artifact\n* because consequent sequences will be taken at more uneven intervals.\n*\n* If there's a disturbing artifact that sounds as if a constant frequency was drifting\n* around, try reducing this setting.\n*\n* Increasing this value increases computational burden and vice versa.\n*/\n//var DEFAULT_SEEKWINDOW_MS = 25;\nvar DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN;\n\n/**\n* Overlap length in milliseconds. When the chopped sound sequences are mixed back together,\n* to form a continuous sound stream, this parameter defines over how long period the two\n* consecutive sequences are let to overlap each other.\n*\n* This shouldn't be that critical parameter. If you reduce the DEFAULT_SEQUENCE_MS setting\n* by a large amount, you might wish to try a smaller value on this.\n*\n* Increasing this value increases computational burden and vice versa.\n*/\nvar DEFAULT_OVERLAP_MS = 8;\n\n// Table for the hierarchical mixing position seeking algorithm\nvar _SCAN_OFFSETS = [\n    [ 124,  186,  248,  310,  372,  434,  496,  558,  620,  682,  744, 806,\n      868,  930,  992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488,   0],\n    [-100,  -75,  -50,  -25,   25,   50,   75,  100,    0,    0,    0,   0,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0],\n    [ -20,  -15,  -10,   -5,    5,   10,   15,   20,    0,    0,    0,   0,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0],\n    [  -4,   -3,   -2,   -1,    1,    2,    3,    4,    0,    0,    0,   0,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0]];\n\n// Adjust tempo param according to tempo, so that variating processing sequence length is used\n// at varius tempo settings, between the given low...top limits\nvar AUTOSEQ_TEMPO_LOW = 0.5;     // auto setting low tempo range (-50%)\nvar AUTOSEQ_TEMPO_TOP = 2.0;     // auto setting top tempo range (+100%)\n\n// sequence-ms setting values at above low & top tempo\nvar AUTOSEQ_AT_MIN = 125.0;\nvar AUTOSEQ_AT_MAX = 50.0;\nvar AUTOSEQ_K = ((AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW));\nvar AUTOSEQ_C = (AUTOSEQ_AT_MIN - (AUTOSEQ_K) * (AUTOSEQ_TEMPO_LOW));\n\n// seek-window-ms setting values at above low & top tempo\nvar AUTOSEEK_AT_MIN = 25.0;\nvar AUTOSEEK_AT_MAX = 15.0;\nvar AUTOSEEK_K = ((AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW));\nvar AUTOSEEK_C = (AUTOSEEK_AT_MIN - (AUTOSEEK_K) * (AUTOSEQ_TEMPO_LOW));\n\nfunction Stretch(createBuffers) {\n    AbstractFifoSamplePipe.call(this, createBuffers);\n    this.bQuickSeek = true;\n    this.bMidBufferDirty = false;\n\n    this.pMidBuffer = null;\n    this.overlapLength = 0;\n\n    this.bAutoSeqSetting = true;\n    this.bAutoSeekSetting = true;\n\n    this._tempo = 1;\n    this.setParameters(44100, DEFAULT_SEQUENCE_MS, DEFAULT_SEEKWINDOW_MS, DEFAULT_OVERLAP_MS);\n}\n\nextend(Stretch.prototype, AbstractFifoSamplePipe.prototype);\n\nextend(Stretch.prototype, {\n    clear: function () {\n        AbstractFifoSamplePipe.prototype.clear.call(this);\n        this._clearMidBuffer();\n    },\n\n    _clearMidBuffer: function () {\n        if (this.bMidBufferDirty) {\n            this.bMidBufferDirty = false;\n            this.pMidBuffer = null;\n        }\n    },\n\n    /**\n    * Sets routine control parameters. These control are certain time constants\n    * defining how the sound is stretched to the desired duration.\n    *\n    * 'sampleRate' = sample rate of the sound\n    * 'sequenceMS' = one processing sequence length in milliseconds (default = 82 ms)\n    * 'seekwindowMS' = seeking window length for scanning the best overlapping\n    *      position (default = 28 ms)\n    * 'overlapMS' = overlapping length (default = 12 ms)\n    */\n    setParameters: function(aSampleRate, aSequenceMS, aSeekWindowMS, aOverlapMS) {\n        // accept only positive parameter values - if zero or negative, use old values instead\n        if (aSampleRate > 0) {\n            this.sampleRate = aSampleRate;\n        }\n        if (aOverlapMS > 0) {\n            this.overlapMs = aOverlapMS;\n        }\n\n        if (aSequenceMS > 0) {\n            this.sequenceMs = aSequenceMS;\n            this.bAutoSeqSetting = false;\n        } else {\n            // zero or below, use automatic setting\n            this.bAutoSeqSetting = true;\n        }\n\n        if (aSeekWindowMS > 0) {\n            this.seekWindowMs = aSeekWindowMS;\n            this.bAutoSeekSetting = false;\n        } else {\n            // zero or below, use automatic setting\n            this.bAutoSeekSetting = true;\n        }\n\n        this.calcSeqParameters();\n\n        this.calculateOverlapLength(this.overlapMs);\n\n        // set tempo to recalculate 'sampleReq'\n        this.tempo = this._tempo;\n    },\n\n    /**\n    * Sets new target tempo. Normal tempo = 'SCALE', smaller values represent slower\n    * tempo, larger faster tempo.\n    */\n    set tempo(newTempo) {\n        var intskip;\n\n        this._tempo = newTempo;\n\n        // Calculate new sequence duration\n        this.calcSeqParameters();\n\n        // Calculate ideal skip length (according to tempo value)\n        this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength);\n        this.skipFract = 0;\n        intskip = Math.floor(this.nominalSkip + 0.5);\n\n        // Calculate how many samples are needed in the 'inputBuffer' to\n        // process another batch of samples\n        this.sampleReq = Math.max(intskip + this.overlapLength, this.seekWindowLength) + this.seekLength;\n    },\n\n\n    // get tempo() {\n    //   return this._tempo;\n    // },\n\n    get inputChunkSize() {\n        return this.sampleReq;\n    },\n\n    get outputChunkSize() {\n        return this.overlapLength + Math.max(0, this.seekWindowLength - 2 * this.overlapLength);\n    },\n\n    /**\n    * Calculates overlapInMsec period length in samples.\n    */\n    calculateOverlapLength: function (overlapInMsec) {\n        var newOvl;\n\n        // TODO assert(overlapInMsec >= 0);\n        newOvl = (this.sampleRate * overlapInMsec) / 1000;\n        if (newOvl < 16) newOvl = 16;\n\n        // must be divisible by 8\n        newOvl -= newOvl % 8;\n\n        this.overlapLength = newOvl;\n\n        this.pRefMidBuffer = new Float32Array(this.overlapLength * 2);\n        this.pMidBuffer = new Float32Array(this.overlapLength * 2);\n    },\n\n    checkLimits: function (x, mi, ma) {\n        return (x < mi) ? mi : ((x > ma) ? ma : x);\n    },\n\n    /**\n    * Calculates processing sequence length according to tempo setting\n    */\n    calcSeqParameters: function() {\n        var seq;\n        var seek;\n\n        if (this.bAutoSeqSetting) {\n            seq = AUTOSEQ_C + AUTOSEQ_K * this._tempo;\n            seq = this.checkLimits(seq, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN);\n            this.sequenceMs = Math.floor(seq + 0.5);\n        }\n\n        if (this.bAutoSeekSetting) {\n            seek = AUTOSEEK_C + AUTOSEEK_K * this._tempo;\n            seek = this.checkLimits(seek, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN);\n            this.seekWindowMs = Math.floor(seek + 0.5);\n        }\n\n        // Update seek window lengths\n        this.seekWindowLength = Math.floor((this.sampleRate * this.sequenceMs) / 1000);\n        this.seekLength = Math.floor((this.sampleRate * this.seekWindowMs) / 1000);\n    },\n\n\n    /**\n    * Enables/disables the quick position seeking algorithm.\n    */\n    set quickSeek(enable) {\n        this.bQuickSeek = enable;\n    },\n\n    clone: function () {\n        var result = new Stretch();\n        result.tempo = this.tempo;\n        result.setParameters(this.sampleRate, this.sequenceMs, this.seekWindowMs, this.overlapMs);\n        return result;\n    },\n\n    /**\n    * Seeks for the optimal overlap-mixing position.\n    */\n    seekBestOverlapPosition: function () {\n      if (this.bQuickSeek) {\n          return this.seekBestOverlapPositionStereoQuick();\n      }\n      else {\n          return this.seekBestOverlapPositionStereo();\n      }\n    },\n\n    /**\n    * Seeks for the optimal overlap-mixing position. The 'stereo' version of the\n    * routine\n    *\n    * The best position is determined as the position where the two overlapped\n    * sample sequences are 'most alike', in terms of the highest cross-correlation\n    * value over the overlapping period\n    */\n    seekBestOverlapPositionStereo: function () {\n        var bestOffs;\n        var bestCorr\n        var corr;\n        var i;\n\n        // Slopes the amplitudes of the 'midBuffer' samples\n        this.precalcCorrReferenceStereo();\n\n        bestCorr = Number.MIN_VALUE;\n        bestOffs = 0;\n\n        // Scans for the best correlation value by testing each possible position\n        // over the permitted range.\n        for (i = 0; i < this.seekLength; i ++) {\n            // Calculates correlation value for the mixing position corresponding\n            // to 'i'\n            corr = this.calcCrossCorrStereo(2 * i, this.pRefMidBuffer);\n\n            // Checks for the highest correlation value\n            if (corr > bestCorr) {\n                bestCorr = corr;\n                bestOffs = i;\n            }\n        }\n\n        return bestOffs;\n    },\n\n    /**\n    * Seeks for the optimal overlap-mixing position. The 'stereo' version of the\n    * routine\n    *\n    * The best position is determined as the position where the two overlapped\n    * sample sequences are 'most alike', in terms of the highest cross-correlation\n    * value over the overlapping period\n    */\n    seekBestOverlapPositionStereoQuick: function () {\n        var j;\n        var bestOffs;\n        var bestCorr;\n        var corr;\n        var scanCount;\n        var corrOffset;\n        var tempOffset;\n\n        // Slopes the amplitude of the 'midBuffer' samples\n        this.precalcCorrReferenceStereo();\n\n        bestCorr = Number.MIN_VALUE;\n        bestOffs = 0;\n        corrOffset = 0;\n        tempOffset = 0;\n\n        // Scans for the best correlation value using four-pass hierarchical search.\n        //\n        // The look-up table 'scans' has hierarchical position adjusting steps.\n        // In first pass the routine searhes for the highest correlation with\n        // relatively coarse steps, then rescans the neighbourhood of the highest\n        // correlation with better resolution and so on.\n        for (scanCount = 0; scanCount < 4; scanCount ++) {\n            j = 0;\n            while (_SCAN_OFFSETS[scanCount][j]) {\n                tempOffset = corrOffset + _SCAN_OFFSETS[scanCount][j];\n                if (tempOffset >= this.seekLength) break;\n\n                // Calculates correlation value for the mixing position corresponding\n                // to 'tempOffset'\n                corr = this.calcCrossCorrStereo(2 * tempOffset, this.pRefMidBuffer);\n\n                // Checks for the highest correlation value\n                if (corr > bestCorr) {\n                    bestCorr = corr;\n                    bestOffs = tempOffset;\n                }\n                j++;\n            }\n            corrOffset = bestOffs;\n        }\n\n        return bestOffs;\n    },\n\n    /**\n    * Slopes the amplitude of the 'midBuffer' samples so that cross correlation\n    * is faster to calculate\n    */\n    precalcCorrReferenceStereo: function() {\n        var i;\n        var cnt2;\n        var temp;\n\n        for (i = 0; i < this.overlapLength; i ++) {\n            temp = i * (this.overlapLength - i);\n            cnt2 = i * 2;\n            this.pRefMidBuffer[cnt2] = this.pMidBuffer[cnt2] * temp;\n            this.pRefMidBuffer[cnt2 + 1] = this.pMidBuffer[cnt2 + 1] * temp;\n        }\n    },\n\n    calcCrossCorrStereo: function(mixingPos, compare) {\n        var mixing = this._inputBuffer.vector;\n        mixingPos += this._inputBuffer.startIndex;\n\n        var corr;\n        var i;\n        var mixingOffset;\n\n        corr = 0;\n        for (i = 2; i < 2 * this.overlapLength; i += 2) {\n            mixingOffset = i + mixingPos;\n            corr += mixing[mixingOffset] * compare[i] +\n            mixing[mixingOffset + 1] * compare[i + 1];\n        }\n\n        return corr;\n    },\n\n    // TODO inline\n    /**\n    * Overlaps samples in 'midBuffer' with the samples in 'pInputBuffer' at position\n    * of 'ovlPos'.\n    */\n    overlap: function (ovlPos) {\n        this.overlapStereo(2 * ovlPos);\n    },\n\n    /**\n    * Overlaps samples in 'midBuffer' with the samples in 'pInput'\n    */\n    overlapStereo: function(pInputPos) {\n        var pInput = this._inputBuffer.vector;\n        pInputPos += this._inputBuffer.startIndex;\n\n        var pOutput = this._outputBuffer.vector;\n        var pOutputPos = this._outputBuffer.endIndex;\n\n        var i;\n        var cnt2;\n        var fTemp;\n        var fScale;\n        var fi;\n        var pInputOffset;\n        var pOutputOffset;\n\n        fScale = 1 / this.overlapLength;\n\n        for (i = 0; i < this.overlapLength; i++) {\n            fTemp = (this.overlapLength - i) * fScale;\n            fi = i * fScale;\n            cnt2 = 2 * i;\n            pInputOffset = cnt2 + pInputPos;\n            pOutputOffset = cnt2 + pOutputPos;\n            pOutput[pOutputOffset + 0] = pInput[pInputOffset + 0] * fi + this.pMidBuffer[cnt2 + 0] * fTemp;\n            pOutput[pOutputOffset + 1] = pInput[pInputOffset + 1] * fi + this.pMidBuffer[cnt2 + 1] * fTemp;\n        }\n    },\n\n    process: function() {\n        var ovlSkip;\n        var offset;\n        var temp;\n        var i;\n\n        if (this.pMidBuffer == null) {\n            // if midBuffer is empty, move the first samples of the input stream\n            // into it\n            if (this._inputBuffer.frameCount < this.overlapLength) {\n                // wait until we've got overlapLength samples\n                return;\n            }\n            this.pMidBuffer = new Float32Array(this.overlapLength * 2);\n            this._inputBuffer.receiveSamples(this.pMidBuffer, this.overlapLength);\n        }\n\n        var output;\n        // Process samples as long as there are enough samples in 'inputBuffer'\n        // to form a processing frame.\n        while (this._inputBuffer.frameCount >= this.sampleReq) {\n            // If tempo differs from the normal ('SCALE'), scan for the best overlapping\n            // position\n            offset = this.seekBestOverlapPosition();\n\n            // Mix the samples in the 'inputBuffer' at position of 'offset' with the\n            // samples in 'midBuffer' using sliding overlapping\n            // ... first partially overlap with the end of the previous sequence\n            // (that's in 'midBuffer')\n            this._outputBuffer.ensureAdditionalCapacity(this.overlapLength);\n            // FIXME unit?\n            //overlap(uint(offset));\n            this.overlap(Math.floor(offset));\n            this._outputBuffer.put(this.overlapLength);\n\n            // ... then copy sequence samples from 'inputBuffer' to output\n            temp = (this.seekWindowLength - 2 * this.overlapLength); // & 0xfffffffe;\n            if (temp > 0) {\n                this._outputBuffer.putBuffer(this._inputBuffer, offset + this.overlapLength, temp);\n            }\n\n            // Copies the end of the current sequence from 'inputBuffer' to\n            // 'midBuffer' for being mixed with the beginning of the next\n            // processing sequence and so on\n            //assert(offset + seekWindowLength <= (int)inputBuffer.numSamples());\n            var start = this.inputBuffer.startIndex + 2 * (offset + this.seekWindowLength - this.overlapLength);\n            this.pMidBuffer.set(this._inputBuffer.vector.subarray(start, start + 2 * this.overlapLength))\n\n            // Remove the processed samples from the input buffer. Update\n            // the difference between integer & nominal skip step to 'skipFract'\n            // in order to prevent the error from accumulating over time.\n            this.skipFract += this.nominalSkip;   // real skip size\n            ovlSkip = Math.floor(this.skipFract); // rounded to integer skip\n            this.skipFract -= ovlSkip;            // maintain the fraction part, i.e. real vs. integer skip\n            this._inputBuffer.receive(ovlSkip);\n        }\n    }\n});\n\n// https://bugs.webkit.org/show_bug.cgi?id=57295\nextend(Stretch.prototype, {\n    get tempo() {\n      return this._tempo;\n    }\n});\n/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nfunction SoundTouch() {\n    this.rateTransposer = new RateTransposer(false);\n    this.tdStretch = new Stretch(false);\n\n    this._inputBuffer = new FifoSampleBuffer();\n    this._intermediateBuffer = new FifoSampleBuffer();\n    this._outputBuffer = new FifoSampleBuffer();\n\n    this._rate = 0;\n    this.tempo = 0;\n\n    this.virtualPitch = 1.0;\n    this.virtualRate = 1.0;\n    this.virtualTempo = 1.0;\n\n    this._calculateEffectiveRateAndTempo();\n}\n\nextend(SoundTouch.prototype, {\n    clear: function () {\n        this.rateTransposer.clear();\n        this.tdStretch.clear();\n    },\n\n    clone: function () {\n        var result = new SoundTouch();\n        result.rate = rate;\n        result.tempo = tempo;\n        return result;\n    },\n\n    get rate() {\n        return this._rate;\n    },\n\n    set rate(rate) {\n        this.virtualRate = rate;\n        this._calculateEffectiveRateAndTempo();\n    },\n\n    set rateChange(rateChange) {\n        this.rate = 1.0 + 0.01 * rateChange;\n    },\n\n    get tempo() {\n        return this._tempo;\n    },\n\n    set tempo(tempo) {\n        this.virtualTempo = tempo;\n        this._calculateEffectiveRateAndTempo();\n    },\n\n    set tempoChange(tempoChange) {\n        this.tempo = 1.0 + 0.01 * tempoChange;\n    },\n\n    set pitch(pitch) {\n        this.virtualPitch = pitch;\n        this._calculateEffectiveRateAndTempo();\n    },\n\n    set pitchOctaves(pitchOctaves) {\n        this.pitch = Math.exp(0.69314718056 * pitchOctaves);\n        this._calculateEffectiveRateAndTempo();\n    },\n\n    set pitchSemitones(pitchSemitones) {\n        this.pitchOctaves = pitchSemitones / 12.0;\n    },\n\n    get inputBuffer() {\n        return this._inputBuffer;\n    },\n\n    get outputBuffer() {\n        return this._outputBuffer;\n    },\n\n    _calculateEffectiveRateAndTempo: function () {\n        var previousTempo = this._tempo;\n        var previousRate = this._rate;\n\n        this._tempo = this.virtualTempo / this.virtualPitch;\n        this._rate = this.virtualRate * this.virtualPitch;\n\n        if (testFloatEqual(this._tempo, previousTempo)) {\n            this.tdStretch.tempo = this._tempo;\n        }\n        if (testFloatEqual(this._rate, previousRate)) {\n            this.rateTransposer.rate = this._rate;\n        }\n\n        if (this._rate > 1.0) {\n            if (this._outputBuffer != this.rateTransposer.outputBuffer) {\n                this.tdStretch.inputBuffer = this._inputBuffer;\n                this.tdStretch.outputBuffer = this._intermediateBuffer;\n\n                this.rateTransposer.inputBuffer = this._intermediateBuffer;\n                this.rateTransposer.outputBuffer = this._outputBuffer;\n            }\n        }\n        else {\n            if (this._outputBuffer != this.tdStretch.outputBuffer) {\n                this.rateTransposer.inputBuffer = this._inputBuffer;\n                this.rateTransposer.outputBuffer = this._intermediateBuffer;\n\n                this.tdStretch.inputBuffer = this._intermediateBuffer;\n                this.tdStretch.outputBuffer = this._outputBuffer;\n            }\n        }\n    },\n\n    process: function () {\n        if (this._rate > 1.0) {\n            this.tdStretch.process();\n            this.rateTransposer.process();\n        }\n        else {\n            this.rateTransposer.process();\n            this.tdStretch.process();\n        }\n    }\n});\n\n// This is the only part that was added for screw (plus fixing a couple typos where `this` was\n// erroneously not used)\nmodule.exports = {SimpleFilter, SoundTouch};\n"]},"metadata":{},"sourceType":"module"}