{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nconst http_1 = __importDefault(require(\"http\"));\n\nconst https_1 = __importDefault(require(\"https\"));\n\nconst url_1 = require(\"url\");\n\nconst stream_1 = require(\"stream\");\n\nconst httpLibs = {\n  'http:': http_1.default,\n  'https:': https_1.default\n};\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst retryStatusCodes = new Set([429, 503]); // `request`, `response`, `abort`, left out, miniget will emit these.\n\nconst requestEvents = ['connect', 'continue', 'information', 'socket', 'timeout', 'upgrade'];\nconst responseEvents = ['aborted'];\nMiniget.MinigetError = class MinigetError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n  }\n\n};\nMiniget.defaultOptions = {\n  maxRedirects: 10,\n  maxRetries: 2,\n  maxReconnects: 0,\n  backoff: {\n    inc: 100,\n    max: 10000\n  }\n};\n\nfunction Miniget(url, options = {}) {\n  var _a;\n\n  const opts = Object.assign({}, Miniget.defaultOptions, options);\n  const stream = new stream_1.PassThrough({\n    highWaterMark: opts.highWaterMark\n  });\n  stream.destroyed = stream.aborted = false;\n  let activeRequest;\n  let activeResponse;\n  let activeDecodedStream;\n  let redirects = 0;\n  let retries = 0;\n  let retryTimeout;\n  let reconnects = 0;\n  let contentLength;\n  let acceptRanges = false;\n  let rangeStart = 0,\n      rangeEnd;\n  let downloaded = 0; // Check if this is a ranged request.\n\n  if ((_a = opts.headers) === null || _a === void 0 ? void 0 : _a.Range) {\n    let r = /bytes=(\\d+)-(\\d+)?/.exec(opts.headers.Range + '');\n\n    if (r) {\n      rangeStart = parseInt(r[1], 10);\n      rangeEnd = parseInt(r[2], 10);\n    }\n  } // Add `Accept-Encoding` header.\n\n\n  if (opts.acceptEncoding) {\n    opts.headers = Object.assign({\n      'Accept-Encoding': Object.keys(opts.acceptEncoding).join(', ')\n    }, opts.headers);\n  }\n\n  const downloadHasStarted = () => activeDecodedStream && 0 < downloaded;\n\n  const downloadComplete = () => !acceptRanges || downloaded == contentLength;\n\n  const reconnect = err => {\n    activeDecodedStream = null;\n    retries = 0;\n    let inc = opts.backoff.inc;\n    let ms = Math.min(inc, opts.backoff.max);\n    retryTimeout = setTimeout(doDownload, ms);\n    stream.emit('reconnect', reconnects, err);\n  };\n\n  const reconnectIfEndedEarly = err => {\n    if (options.method != 'HEAD' && !downloadComplete() && reconnects++ < opts.maxReconnects) {\n      reconnect(err);\n      return true;\n    }\n\n    return false;\n  };\n\n  const retryRequest = retryOptions => {\n    if (stream.destroyed) {\n      return false;\n    }\n\n    if (downloadHasStarted()) {\n      return reconnectIfEndedEarly(retryOptions.err);\n    } else if ((!retryOptions.statusCode || retryOptions.err.message === 'ENOTFOUND') && retries++ < opts.maxRetries) {\n      let ms = retryOptions.retryAfter || Math.min(retries * opts.backoff.inc, opts.backoff.max);\n      retryTimeout = setTimeout(doDownload, ms);\n      stream.emit('retry', retries, retryOptions.err);\n      return true;\n    }\n\n    return false;\n  };\n\n  const forwardEvents = (ee, events) => {\n    for (let event of events) {\n      ee.on(event, stream.emit.bind(stream, event));\n    }\n  };\n\n  const doDownload = () => {\n    let parsed, httpLib;\n\n    try {\n      parsed = url_1.parse(url);\n      httpLib = httpLibs[parsed.protocol];\n    } catch (err) {// Let the error be caught by the if statement below.\n    }\n\n    if (!httpLib) {\n      stream.emit('error', new Miniget.MinigetError('Invalid URL: ' + url));\n      return;\n    }\n\n    Object.assign(parsed, opts);\n\n    if (acceptRanges && downloaded > 0) {\n      let start = downloaded + rangeStart;\n      let end = rangeEnd || '';\n      parsed.headers = Object.assign({}, parsed.headers, {\n        Range: `bytes=${start}-${end}`\n      });\n    }\n\n    if (opts.transform) {\n      try {\n        parsed = opts.transform(parsed);\n      } catch (err) {\n        stream.emit('error', err);\n        return;\n      }\n\n      if (!parsed || parsed.protocol) {\n        httpLib = httpLibs[parsed === null || parsed === void 0 ? void 0 : parsed.protocol];\n\n        if (!httpLib) {\n          stream.emit('error', new Miniget.MinigetError('Invalid URL object from `transform` function'));\n          return;\n        }\n      }\n    }\n\n    const onError = (err, statusCode) => {\n      cleanup();\n\n      if (!retryRequest({\n        err,\n        statusCode\n      })) {\n        stream.emit('error', err);\n      } else {\n        activeRequest.removeListener('close', onRequestClose);\n      }\n    };\n\n    const onRequestClose = () => {\n      cleanup();\n      retryRequest({});\n    };\n\n    const cleanup = () => {\n      activeRequest.removeListener('error', onError);\n      activeRequest.removeListener('close', onRequestClose);\n      activeResponse === null || activeResponse === void 0 ? void 0 : activeResponse.removeListener('data', onData);\n      activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.removeListener('end', onEnd);\n      activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.removeListener('error', onError);\n      activeResponse === null || activeResponse === void 0 ? void 0 : activeResponse.removeListener('error', onError);\n    };\n\n    const onData = chunk => {\n      downloaded += chunk.length;\n    };\n\n    const onEnd = () => {\n      cleanup();\n\n      if (!reconnectIfEndedEarly()) {\n        stream.end();\n      }\n    };\n\n    activeRequest = httpLib.request(parsed, res => {\n      // Needed for node v10, v12.\n      // istanbul ignore next\n      if (stream.destroyed) {\n        return;\n      }\n\n      if (redirectStatusCodes.has(res.statusCode)) {\n        if (redirects++ >= opts.maxRedirects) {\n          stream.emit('error', new Miniget.MinigetError('Too many redirects'));\n        } else {\n          url = res.headers.location;\n          setTimeout(doDownload, res.headers['retry-after'] ? parseInt(res.headers['retry-after'], 10) * 1000 : 0);\n          stream.emit('redirect', url);\n        }\n\n        return cleanup(); // Check for rate limiting.\n      } else if (retryStatusCodes.has(res.statusCode)) {\n        if (!retryRequest({\n          retryAfter: parseInt(res.headers['retry-after'], 10)\n        })) {\n          let err = new Miniget.MinigetError('Status code: ' + res.statusCode, res.statusCode);\n          stream.emit('error', err);\n        }\n\n        return cleanup();\n      } else if (res.statusCode < 200 || 400 <= res.statusCode) {\n        let err = new Miniget.MinigetError('Status code: ' + res.statusCode, res.statusCode);\n\n        if (res.statusCode >= 500) {\n          onError(err, res.statusCode);\n        } else {\n          stream.emit('error', err);\n        }\n\n        return cleanup();\n      }\n\n      activeDecodedStream = res;\n\n      if (opts.acceptEncoding && res.headers['content-encoding']) {\n        for (let enc of res.headers['content-encoding'].split(', ').reverse()) {\n          let fn = opts.acceptEncoding[enc];\n\n          if (fn != null) {\n            activeDecodedStream = activeDecodedStream.pipe(fn());\n            activeDecodedStream.on('error', onError);\n          }\n        }\n      }\n\n      if (!contentLength) {\n        contentLength = parseInt(res.headers['content-length'] + '', 10);\n        acceptRanges = res.headers['accept-ranges'] === 'bytes' && contentLength > 0 && opts.maxReconnects > 0;\n      }\n\n      res.on('data', onData);\n      activeDecodedStream.on('end', onEnd);\n      activeDecodedStream.pipe(stream, {\n        end: !acceptRanges\n      });\n      activeResponse = res;\n      stream.emit('response', res);\n      res.on('error', onError);\n      forwardEvents(res, responseEvents);\n    });\n    activeRequest.on('error', onError);\n    activeRequest.on('close', onRequestClose);\n    forwardEvents(activeRequest, requestEvents);\n\n    if (stream.destroyed) {\n      streamDestroy(destroyErr);\n    }\n\n    stream.emit('request', activeRequest);\n    activeRequest.end();\n  };\n\n  stream.abort = err => {\n    console.warn('`MinigetStream#abort()` has been deprecated in favor of `MinigetStream#destroy()`');\n    stream.aborted = true;\n    stream.emit('abort');\n    stream.destroy(err);\n  };\n\n  let destroyErr;\n\n  const streamDestroy = err => {\n    activeRequest.destroy(err);\n    activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.unpipe(stream);\n    activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.destroy();\n    clearTimeout(retryTimeout);\n  };\n\n  stream._destroy = err => {\n    stream.destroyed = true;\n\n    if (activeRequest) {\n      streamDestroy(err);\n    } else {\n      destroyErr = err;\n    }\n  };\n\n  stream.text = () => __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      let body = '';\n      stream.setEncoding('utf8');\n      stream.on('data', chunk => body += chunk);\n      stream.on('end', () => resolve(body));\n      stream.on('error', reject);\n    });\n  });\n\n  process.nextTick(doDownload);\n  return stream;\n}\n\nmodule.exports = Miniget;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst http_1 = __importDefault(require(\"http\"));\nconst https_1 = __importDefault(require(\"https\"));\nconst url_1 = require(\"url\");\nconst stream_1 = require(\"stream\");\nconst httpLibs = { 'http:': http_1.default, 'https:': https_1.default };\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst retryStatusCodes = new Set([429, 503]);\n// `request`, `response`, `abort`, left out, miniget will emit these.\nconst requestEvents = ['connect', 'continue', 'information', 'socket', 'timeout', 'upgrade'];\nconst responseEvents = ['aborted'];\nMiniget.MinigetError = class MinigetError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.statusCode = statusCode;\n    }\n};\nMiniget.defaultOptions = {\n    maxRedirects: 10,\n    maxRetries: 2,\n    maxReconnects: 0,\n    backoff: { inc: 100, max: 10000 },\n};\nfunction Miniget(url, options = {}) {\n    var _a;\n    const opts = Object.assign({}, Miniget.defaultOptions, options);\n    const stream = new stream_1.PassThrough({ highWaterMark: opts.highWaterMark });\n    stream.destroyed = stream.aborted = false;\n    let activeRequest;\n    let activeResponse;\n    let activeDecodedStream;\n    let redirects = 0;\n    let retries = 0;\n    let retryTimeout;\n    let reconnects = 0;\n    let contentLength;\n    let acceptRanges = false;\n    let rangeStart = 0, rangeEnd;\n    let downloaded = 0;\n    // Check if this is a ranged request.\n    if ((_a = opts.headers) === null || _a === void 0 ? void 0 : _a.Range) {\n        let r = /bytes=(\\d+)-(\\d+)?/.exec(opts.headers.Range + '');\n        if (r) {\n            rangeStart = parseInt(r[1], 10);\n            rangeEnd = parseInt(r[2], 10);\n        }\n    }\n    // Add `Accept-Encoding` header.\n    if (opts.acceptEncoding) {\n        opts.headers = Object.assign({\n            'Accept-Encoding': Object.keys(opts.acceptEncoding).join(', ')\n        }, opts.headers);\n    }\n    const downloadHasStarted = () => activeDecodedStream && 0 < downloaded;\n    const downloadComplete = () => !acceptRanges || downloaded == contentLength;\n    const reconnect = (err) => {\n        activeDecodedStream = null;\n        retries = 0;\n        let inc = opts.backoff.inc;\n        let ms = Math.min(inc, opts.backoff.max);\n        retryTimeout = setTimeout(doDownload, ms);\n        stream.emit('reconnect', reconnects, err);\n    };\n    const reconnectIfEndedEarly = (err) => {\n        if (options.method != 'HEAD' && !downloadComplete() && reconnects++ < opts.maxReconnects) {\n            reconnect(err);\n            return true;\n        }\n        return false;\n    };\n    const retryRequest = (retryOptions) => {\n        if (stream.destroyed) {\n            return false;\n        }\n        if (downloadHasStarted()) {\n            return reconnectIfEndedEarly(retryOptions.err);\n        }\n        else if ((!retryOptions.statusCode || retryOptions.err.message === 'ENOTFOUND') &&\n            retries++ < opts.maxRetries) {\n            let ms = retryOptions.retryAfter ||\n                Math.min(retries * opts.backoff.inc, opts.backoff.max);\n            retryTimeout = setTimeout(doDownload, ms);\n            stream.emit('retry', retries, retryOptions.err);\n            return true;\n        }\n        return false;\n    };\n    const forwardEvents = (ee, events) => {\n        for (let event of events) {\n            ee.on(event, stream.emit.bind(stream, event));\n        }\n    };\n    const doDownload = () => {\n        let parsed, httpLib;\n        try {\n            parsed = url_1.parse(url);\n            httpLib = httpLibs[parsed.protocol];\n        }\n        catch (err) {\n            // Let the error be caught by the if statement below.\n        }\n        if (!httpLib) {\n            stream.emit('error', new Miniget.MinigetError('Invalid URL: ' + url));\n            return;\n        }\n        Object.assign(parsed, opts);\n        if (acceptRanges && downloaded > 0) {\n            let start = downloaded + rangeStart;\n            let end = rangeEnd || '';\n            parsed.headers = Object.assign({}, parsed.headers, {\n                Range: `bytes=${start}-${end}`\n            });\n        }\n        if (opts.transform) {\n            try {\n                parsed = opts.transform(parsed);\n            }\n            catch (err) {\n                stream.emit('error', err);\n                return;\n            }\n            if (!parsed || parsed.protocol) {\n                httpLib = httpLibs[parsed === null || parsed === void 0 ? void 0 : parsed.protocol];\n                if (!httpLib) {\n                    stream.emit('error', new Miniget.MinigetError('Invalid URL object from `transform` function'));\n                    return;\n                }\n            }\n        }\n        const onError = (err, statusCode) => {\n            cleanup();\n            if (!retryRequest({ err, statusCode })) {\n                stream.emit('error', err);\n            }\n            else {\n                activeRequest.removeListener('close', onRequestClose);\n            }\n        };\n        const onRequestClose = () => {\n            cleanup();\n            retryRequest({});\n        };\n        const cleanup = () => {\n            activeRequest.removeListener('error', onError);\n            activeRequest.removeListener('close', onRequestClose);\n            activeResponse === null || activeResponse === void 0 ? void 0 : activeResponse.removeListener('data', onData);\n            activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.removeListener('end', onEnd);\n            activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.removeListener('error', onError);\n            activeResponse === null || activeResponse === void 0 ? void 0 : activeResponse.removeListener('error', onError);\n        };\n        const onData = (chunk) => { downloaded += chunk.length; };\n        const onEnd = () => {\n            cleanup();\n            if (!reconnectIfEndedEarly()) {\n                stream.end();\n            }\n        };\n        activeRequest = httpLib.request(parsed, (res) => {\n            // Needed for node v10, v12.\n            // istanbul ignore next\n            if (stream.destroyed) {\n                return;\n            }\n            if (redirectStatusCodes.has(res.statusCode)) {\n                if (redirects++ >= opts.maxRedirects) {\n                    stream.emit('error', new Miniget.MinigetError('Too many redirects'));\n                }\n                else {\n                    url = res.headers.location;\n                    setTimeout(doDownload, res.headers['retry-after'] ? parseInt(res.headers['retry-after'], 10) * 1000 : 0);\n                    stream.emit('redirect', url);\n                }\n                return cleanup();\n                // Check for rate limiting.\n            }\n            else if (retryStatusCodes.has(res.statusCode)) {\n                if (!retryRequest({ retryAfter: parseInt(res.headers['retry-after'], 10) })) {\n                    let err = new Miniget.MinigetError('Status code: ' + res.statusCode, res.statusCode);\n                    stream.emit('error', err);\n                }\n                return cleanup();\n            }\n            else if (res.statusCode < 200 || 400 <= res.statusCode) {\n                let err = new Miniget.MinigetError('Status code: ' + res.statusCode, res.statusCode);\n                if (res.statusCode >= 500) {\n                    onError(err, res.statusCode);\n                }\n                else {\n                    stream.emit('error', err);\n                }\n                return cleanup();\n            }\n            activeDecodedStream = res;\n            if (opts.acceptEncoding && res.headers['content-encoding']) {\n                for (let enc of res.headers['content-encoding'].split(', ').reverse()) {\n                    let fn = opts.acceptEncoding[enc];\n                    if (fn != null) {\n                        activeDecodedStream = activeDecodedStream.pipe(fn());\n                        activeDecodedStream.on('error', onError);\n                    }\n                }\n            }\n            if (!contentLength) {\n                contentLength = parseInt(res.headers['content-length'] + '', 10);\n                acceptRanges = res.headers['accept-ranges'] === 'bytes' &&\n                    contentLength > 0 && opts.maxReconnects > 0;\n            }\n            res.on('data', onData);\n            activeDecodedStream.on('end', onEnd);\n            activeDecodedStream.pipe(stream, { end: !acceptRanges });\n            activeResponse = res;\n            stream.emit('response', res);\n            res.on('error', onError);\n            forwardEvents(res, responseEvents);\n        });\n        activeRequest.on('error', onError);\n        activeRequest.on('close', onRequestClose);\n        forwardEvents(activeRequest, requestEvents);\n        if (stream.destroyed) {\n            streamDestroy(destroyErr);\n        }\n        stream.emit('request', activeRequest);\n        activeRequest.end();\n    };\n    stream.abort = (err) => {\n        console.warn('`MinigetStream#abort()` has been deprecated in favor of `MinigetStream#destroy()`');\n        stream.aborted = true;\n        stream.emit('abort');\n        stream.destroy(err);\n    };\n    let destroyErr;\n    const streamDestroy = (err) => {\n        activeRequest.destroy(err);\n        activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.unpipe(stream);\n        activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.destroy();\n        clearTimeout(retryTimeout);\n    };\n    stream._destroy = (err) => {\n        stream.destroyed = true;\n        if (activeRequest) {\n            streamDestroy(err);\n        }\n        else {\n            destroyErr = err;\n        }\n    };\n    stream.text = () => __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            let body = '';\n            stream.setEncoding('utf8');\n            stream.on('data', (chunk) => body += chunk);\n            stream.on('end', () => resolve(body));\n            stream.on('error', reject);\n        });\n    });\n    process.nextTick(doDownload);\n    return stream;\n}\nmodule.exports = Miniget;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}