{"ast":null,"code":"const urllib = require('url');\n\nconst querystring = require('querystring');\n\nconst sax = require(\"./__REACT_NATIVE_YTDL_CUSTOM_MODULES__/sax\");\n\nconst miniget = require(\"./__REACT_NATIVE_YTDL_CUSTOM_MODULES__/miniget\");\n\nconst utils = require('./utils'); // Forces Node JS version of setTimeout for Electron based applications\n\n\nconst {\n  setTimeout\n} = require(\"./__REACT_NATIVE_YTDL_CUSTOM_MODULES__/timers\");\n\nconst formatUtils = require('./format-utils');\n\nconst urlUtils = require('./url-utils');\n\nconst extras = require('./info-extras');\n\nconst sig = require('./sig');\n\nconst Cache = require('./cache');\n\nconst VIDEO_URL = 'https://www.youtube.com/watch?v='; // Cached for storing basic/full info.\n\nexports.cache = new Cache();\nexports.cookieCache = new Cache(1000 * 60 * 60 * 24);\nexports.watchPageCache = new Cache(); // Special error class used to determine if an error is unrecoverable,\n// as in, ytdl-core should not try again to fetch the video metadata.\n// In this case, the video is usually unavailable in some way.\n\nclass UnrecoverableError extends Error {} // List of URLs that show up in `notice_url` for age restricted videos.\n\n\nconst AGE_RESTRICTED_URLS = ['support.google.com/youtube/?p=age_restrictions', 'youtube.com/t/community_guidelines'];\n/**\n * Gets info from a video without getting additional formats.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n*/\n\nexports.getBasicInfo = async (id, options) => {\n  const retryOptions = Object.assign({}, miniget.defaultOptions, options.requestOptions);\n\n  const validate = info => {\n    let playErr = utils.playError(info.player_response, ['ERROR'], UnrecoverableError);\n    let privateErr = privateVideoError(info.player_response);\n\n    if (playErr || privateErr) {\n      throw playErr || privateErr;\n    }\n\n    return info && info.player_response && (info.player_response.streamingData || isRental(info.player_response) || isNotYetBroadcasted(info.player_response));\n  };\n\n  let info = await pipeline([id, options], validate, retryOptions, [getWatchHTMLPage, getWatchJSONPage, getVideoInfoPage]);\n  Object.assign(info, {\n    formats: parseFormats(info.player_response),\n    related_videos: extras.getRelatedVideos(info)\n  }); // Add additional properties to info.\n\n  const media = extras.getMedia(info);\n  let additional = {\n    author: extras.getAuthor(info),\n    media,\n    likes: extras.getLikes(info),\n    dislikes: extras.getDislikes(info),\n    age_restricted: !!(media && media.notice_url && AGE_RESTRICTED_URLS.some(url => media.notice_url.includes(url))),\n    // Give the standard link to the video.\n    video_url: VIDEO_URL + id\n  };\n  info.videoDetails = extras.cleanVideoDetails(Object.assign({}, info.player_response && info.player_response.microformat && info.player_response.microformat.playerMicroformatRenderer, info.player_response && info.player_response.videoDetails, additional));\n  return info;\n};\n\nconst privateVideoError = player_response => {\n  let playability = player_response && player_response.playabilityStatus;\n\n  if (playability && playability.status === 'LOGIN_REQUIRED' && playability.messages && playability.messages.filter(m => /This is a private video/.test(m)).length) {\n    return new UnrecoverableError(playability.reason || playability.messages && playability.messages[0]);\n  } else {\n    return null;\n  }\n};\n\nconst isRental = player_response => {\n  let playability = player_response.playabilityStatus;\n  return playability && playability.status === 'UNPLAYABLE' && playability.errorScreen && playability.errorScreen.playerLegacyDesktopYpcOfferRenderer;\n};\n\nconst isNotYetBroadcasted = player_response => {\n  let playability = player_response.playabilityStatus;\n  return playability && playability.status === 'LIVE_STREAM_OFFLINE';\n};\n\nconst getWatchHTMLURL = (id, options) => `${VIDEO_URL + id}&hl=${options.lang || 'en'}`;\n\nconst getWatchHTMLPageBody = (id, options) => {\n  const url = getWatchHTMLURL(id, options);\n  return exports.watchPageCache.getOrSet(url, () => miniget(url, options.requestOptions).text());\n};\n\nconst EMBED_URL = 'https://www.youtube.com/embed/';\n\nconst getEmbedPageBody = (id, options) => {\n  const embedUrl = `${EMBED_URL + id}?hl=${options.lang || 'en'}`;\n  return miniget(embedUrl, options.requestOptions).text();\n};\n\nconst getHTML5player = body => {\n  let html5playerRes = /<script\\s+src=\"([^\"]+)\"(?:\\s+type=\"text\\/javascript\")?\\s+name=\"player_ias\\/base\"\\s*>|\"jsUrl\":\"([^\"]+)\"/.exec(body);\n  return html5playerRes ? html5playerRes[1] || html5playerRes[2] : null;\n};\n\nconst getIdentityToken = (id, options, key, throwIfNotFound) => exports.cookieCache.getOrSet(key, async () => {\n  let page = await getWatchHTMLPageBody(id, options);\n  let match = page.match(/([\"'])ID_TOKEN\\1[:,]\\s?\"([^\"]+)\"/);\n\n  if (!match && throwIfNotFound) {\n    throw new UnrecoverableError('Cookie header used in request, but unable to find YouTube identity token');\n  }\n\n  return match && match[2];\n});\n/**\n * Goes through each endpoint in the pipeline, retrying on failure if the error is recoverable.\n * If unable to succeed with one endpoint, moves onto the next one.\n *\n * @param {Array.<Object>} args\n * @param {Function} validate\n * @param {Object} retryOptions\n * @param {Array.<Function>} endpoints\n * @returns {[Object, Object, Object]}\n */\n\n\nconst pipeline = async (args, validate, retryOptions, endpoints) => {\n  let info;\n\n  for (let func of endpoints) {\n    try {\n      const newInfo = await retryFunc(func, args.concat([info]), retryOptions);\n\n      if (newInfo.player_response) {\n        newInfo.player_response.videoDetails = assign(info && info.player_response && info.player_response.videoDetails, newInfo.player_response.videoDetails);\n        newInfo.player_response = assign(info && info.player_response, newInfo.player_response);\n      }\n\n      info = assign(info, newInfo);\n\n      if (validate(info, false)) {\n        break;\n      }\n    } catch (err) {\n      if (err instanceof UnrecoverableError || func === endpoints[endpoints.length - 1]) {\n        throw err;\n      } // Unable to find video metadata... so try next endpoint.\n\n    }\n  }\n\n  return info;\n};\n/**\n * Like Object.assign(), but ignores `null` and `undefined` from `source`.\n *\n * @param {Object} target\n * @param {Object} source\n * @returns {Object}\n */\n\n\nconst assign = (target, source) => {\n  if (!target || !source) {\n    return target || source;\n  }\n\n  for (let [key, value] of Object.entries(source)) {\n    if (value !== null && value !== undefined) {\n      target[key] = value;\n    }\n  }\n\n  return target;\n};\n/**\n * Given a function, calls it with `args` until it's successful,\n * or until it encounters an unrecoverable error.\n * Currently, any error from miniget is considered unrecoverable. Errors such as\n * too many redirects, invalid URL, status code 404, status code 502.\n *\n * @param {Function} func\n * @param {Array.<Object>} args\n * @param {Object} options\n * @param {number} options.maxRetries\n * @param {Object} options.backoff\n * @param {number} options.backoff.inc\n */\n\n\nconst retryFunc = async (func, args, options) => {\n  let currentTry = 0,\n      result;\n\n  while (currentTry <= options.maxRetries) {\n    try {\n      result = await func(...args);\n      break;\n    } catch (err) {\n      if (err instanceof UnrecoverableError || err instanceof miniget.MinigetError && err.statusCode < 500 || currentTry >= options.maxRetries) {\n        throw err;\n      }\n\n      let wait = Math.min(++currentTry * options.backoff.inc, options.backoff.max);\n      await new Promise(resolve => setTimeout(resolve, wait));\n    }\n  }\n\n  return result;\n};\n\nconst jsonClosingChars = /^[)\\]}'\\s]+/;\n\nconst parseJSON = (source, varName, json) => {\n  if (!json || typeof json === 'object') {\n    return json;\n  } else {\n    try {\n      json = json.replace(jsonClosingChars, '');\n      return JSON.parse(json);\n    } catch (err) {\n      throw Error(`Error parsing ${varName} in ${source}: ${err.message}`);\n    }\n  }\n};\n\nconst findJSON = (source, varName, body, left, right, prependJSON = '') => {\n  let jsonStr = utils.between(body, left, right);\n\n  if (!jsonStr) {\n    throw Error(`Could not find ${varName} in ${source}`);\n  }\n\n  return parseJSON(source, varName, utils.cutAfterJSON(`${prependJSON}${jsonStr}`));\n};\n\nconst findPlayerResponse = (source, info) => {\n  const player_response = info && (info.args && info.args.player_response || info.player_response || info.playerResponse || info.embedded_player_response);\n  return parseJSON(source, 'player_response', player_response);\n};\n\nconst getWatchJSONURL = (id, options) => `${getWatchHTMLURL(id, options)}&pbj=1`;\n\nconst getWatchJSONPage = async (id, options) => {\n  const reqOptions = Object.assign({\n    headers: {}\n  }, options.requestOptions);\n  let cookie = reqOptions.headers.Cookie || reqOptions.headers.cookie;\n  reqOptions.headers = Object.assign({\n    'x-youtube-client-name': '1',\n    'x-youtube-client-version': '2.20201203.06.00',\n    'x-youtube-identity-token': exports.cookieCache.get(cookie || 'browser') || ''\n  }, reqOptions.headers);\n\n  const setIdentityToken = async (key, throwIfNotFound) => {\n    if (reqOptions.headers['x-youtube-identity-token']) {\n      return;\n    }\n\n    reqOptions.headers['x-youtube-identity-token'] = await getIdentityToken(id, options, key, throwIfNotFound);\n  };\n\n  if (cookie) {\n    await setIdentityToken(cookie, true);\n  }\n\n  const jsonUrl = getWatchJSONURL(id, options);\n  let body = await miniget(jsonUrl, reqOptions).text();\n  let parsedBody = parseJSON('watch.json', 'body', body);\n\n  if (parsedBody.reload === 'now') {\n    await setIdentityToken('browser', false);\n  }\n\n  if (parsedBody.reload === 'now' || !Array.isArray(parsedBody)) {\n    throw Error('Unable to retrieve video metadata in watch.json');\n  }\n\n  let info = parsedBody.reduce((part, curr) => Object.assign(curr, part), {});\n  info.player_response = findPlayerResponse('watch.json', info);\n  info.html5player = info.player && info.player.assets && info.player.assets.js;\n  return info;\n};\n\nconst getWatchHTMLPage = async (id, options) => {\n  let body = await getWatchHTMLPageBody(id, options);\n  let info = {\n    page: 'watch'\n  };\n\n  try {\n    info.player_response = findJSON('watch.html', 'player_response', body, /\\bytInitialPlayerResponse\\s*=\\s*\\{/i, '\\n', '{');\n  } catch (err) {\n    let args = findJSON('watch.html', 'player_response', body, /\\bytplayer\\.config\\s*=\\s*{/, '</script>', '{');\n    info.player_response = findPlayerResponse('watch.html', args);\n  }\n\n  info.response = findJSON('watch.html', 'response', body, /\\bytInitialData(\"\\])?\\s*=\\s*\\{/i, '\\n', '{');\n  info.html5player = getHTML5player(body);\n  return info;\n};\n\nconst INFO_HOST = 'www.youtube.com';\nconst INFO_PATH = '/get_video_info';\nconst VIDEO_EURL = 'https://youtube.googleapis.com/v/';\n\nconst getVideoInfoPage = async (id, options) => {\n  const url = urllib.format({\n    protocol: 'https',\n    host: INFO_HOST,\n    pathname: INFO_PATH,\n    query: {\n      video_id: id,\n      eurl: VIDEO_EURL + id,\n      ps: 'default',\n      gl: 'US',\n      hl: options.lang || 'en'\n    }\n  });\n  let body = await miniget(url, options.requestOptions).text();\n  let info = querystring.parse(body);\n  info.player_response = findPlayerResponse('get_video_info', info);\n  return info;\n};\n/**\n * @param {Object} player_response\n * @returns {Array.<Object>}\n */\n\n\nconst parseFormats = player_response => {\n  let formats = [];\n\n  if (player_response && player_response.streamingData) {\n    formats = formats.concat(player_response.streamingData.formats || []).concat(player_response.streamingData.adaptiveFormats || []);\n  }\n\n  return formats;\n};\n/**\n * Gets info from a video additional formats and deciphered URLs.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n */\n\n\nexports.getInfo = async (id, options) => {\n  let info = await exports.getBasicInfo(id, options);\n  const hasManifest = info.player_response && info.player_response.streamingData && (info.player_response.streamingData.dashManifestUrl || info.player_response.streamingData.hlsManifestUrl);\n  let funcs = [];\n\n  if (info.formats.length) {\n    info.html5player = info.html5player || getHTML5player(await getWatchHTMLPageBody(id, options)) || getHTML5player(await getEmbedPageBody(id, options));\n\n    if (!info.html5player) {\n      throw Error('Unable to find html5player file');\n    }\n\n    const html5player = urllib.resolve(VIDEO_URL, info.html5player);\n    funcs.push(sig.decipherFormats(info.formats, html5player, options));\n  }\n\n  if (hasManifest && info.player_response.streamingData.dashManifestUrl) {\n    let url = info.player_response.streamingData.dashManifestUrl;\n    funcs.push(getDashManifest(url, options));\n  }\n\n  if (hasManifest && info.player_response.streamingData.hlsManifestUrl) {\n    let url = info.player_response.streamingData.hlsManifestUrl;\n    funcs.push(getM3U8(url, options));\n  }\n\n  let results = await Promise.all(funcs);\n  info.formats = Object.values(Object.assign({}, ...results));\n  info.formats = info.formats.map(formatUtils.addFormatMeta);\n  info.formats.sort(formatUtils.sortFormats);\n  info.full = true;\n  return info;\n};\n/**\n * Gets additional DASH formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\n\n\nconst getDashManifest = (url, options) => new Promise((resolve, reject) => {\n  let formats = {};\n  const parser = sax.parser(false);\n  parser.onerror = reject;\n  let adaptationSet;\n\n  parser.onopentag = node => {\n    if (node.name === 'ADAPTATIONSET') {\n      adaptationSet = node.attributes;\n    } else if (node.name === 'REPRESENTATION') {\n      const itag = parseInt(node.attributes.ID);\n\n      if (!isNaN(itag)) {\n        formats[url] = Object.assign({\n          itag,\n          url,\n          bitrate: parseInt(node.attributes.BANDWIDTH),\n          mimeType: `${adaptationSet.MIMETYPE}; codecs=\"${node.attributes.CODECS}\"`\n        }, node.attributes.HEIGHT ? {\n          width: parseInt(node.attributes.WIDTH),\n          height: parseInt(node.attributes.HEIGHT),\n          fps: parseInt(node.attributes.FRAMERATE)\n        } : {\n          audioSampleRate: node.attributes.AUDIOSAMPLINGRATE\n        });\n      }\n    }\n  };\n\n  parser.onend = () => {\n    resolve(formats);\n  };\n\n  const req = miniget(urllib.resolve(VIDEO_URL, url), options.requestOptions);\n  req.setEncoding('utf8');\n  req.on('error', reject);\n  req.on('data', chunk => {\n    parser.write(chunk);\n  });\n  req.on('end', parser.close.bind(parser));\n});\n/**\n * Gets additional formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\n\n\nconst getM3U8 = async (url, options) => {\n  url = urllib.resolve(VIDEO_URL, url);\n  let body = await miniget(url, options.requestOptions).text();\n  let formats = {};\n  body.split('\\n').filter(line => /^https?:\\/\\//.test(line)).forEach(line => {\n    const itag = parseInt(line.match(/\\/itag\\/(\\d+)\\//)[1]);\n    formats[line] = {\n      itag,\n      url: line\n    };\n  });\n  return formats;\n}; // Cache get info functions.\n// In case a user wants to get a video's info before downloading.\n\n\nfor (let funcName of ['getBasicInfo', 'getInfo']) {\n  /**\n   * @param {string} link\n   * @param {Object} options\n   * @returns {Promise<Object>}\n   */\n  const func = exports[funcName];\n\n  exports[funcName] = (link, options = {}) => {\n    utils.checkForUpdates();\n    let id = urlUtils.getVideoID(link);\n    const key = [funcName, id, options.lang].join('-');\n    return exports.cache.getOrSet(key, () => func(id, options));\n  };\n} // Export a few helpers.\n\n\nexports.validateID = urlUtils.validateID;\nexports.validateURL = urlUtils.validateURL;\nexports.getURLVideoID = urlUtils.getURLVideoID;\nexports.getVideoID = urlUtils.getVideoID;","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/react-native-ytdl/lib/info.js"],"names":["urllib","require","querystring","sax","miniget","utils","setTimeout","formatUtils","urlUtils","extras","sig","Cache","VIDEO_URL","exports","cache","cookieCache","watchPageCache","UnrecoverableError","Error","AGE_RESTRICTED_URLS","getBasicInfo","id","options","retryOptions","Object","assign","defaultOptions","requestOptions","validate","info","playErr","playError","player_response","privateErr","privateVideoError","streamingData","isRental","isNotYetBroadcasted","pipeline","getWatchHTMLPage","getWatchJSONPage","getVideoInfoPage","formats","parseFormats","related_videos","getRelatedVideos","media","getMedia","additional","author","getAuthor","likes","getLikes","dislikes","getDislikes","age_restricted","notice_url","some","url","includes","video_url","videoDetails","cleanVideoDetails","microformat","playerMicroformatRenderer","playability","playabilityStatus","status","messages","filter","m","test","length","reason","errorScreen","playerLegacyDesktopYpcOfferRenderer","getWatchHTMLURL","lang","getWatchHTMLPageBody","getOrSet","text","EMBED_URL","getEmbedPageBody","embedUrl","getHTML5player","body","html5playerRes","exec","getIdentityToken","key","throwIfNotFound","page","match","args","endpoints","func","newInfo","retryFunc","concat","err","target","source","value","entries","undefined","currentTry","result","maxRetries","MinigetError","statusCode","wait","Math","min","backoff","inc","max","Promise","resolve","jsonClosingChars","parseJSON","varName","json","replace","JSON","parse","message","findJSON","left","right","prependJSON","jsonStr","between","cutAfterJSON","findPlayerResponse","playerResponse","embedded_player_response","getWatchJSONURL","reqOptions","headers","cookie","Cookie","get","setIdentityToken","jsonUrl","parsedBody","reload","Array","isArray","reduce","part","curr","html5player","player","assets","js","response","INFO_HOST","INFO_PATH","VIDEO_EURL","format","protocol","host","pathname","query","video_id","eurl","ps","gl","hl","adaptiveFormats","getInfo","hasManifest","dashManifestUrl","hlsManifestUrl","funcs","push","decipherFormats","getDashManifest","getM3U8","results","all","values","map","addFormatMeta","sort","sortFormats","full","reject","parser","onerror","adaptationSet","onopentag","node","name","attributes","itag","parseInt","ID","isNaN","bitrate","BANDWIDTH","mimeType","MIMETYPE","CODECS","HEIGHT","width","WIDTH","height","fps","FRAMERATE","audioSampleRate","AUDIOSAMPLINGRATE","onend","req","setEncoding","on","chunk","write","close","bind","split","line","forEach","funcName","link","checkForUpdates","getVideoID","join","validateID","validateURL","getURLVideoID"],"mappings":"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","sourcesContent":["const urllib = require('url');\nconst querystring = require('querystring');\nconst sax = require(\"./__REACT_NATIVE_YTDL_CUSTOM_MODULES__/sax\");\nconst miniget = require(\"./__REACT_NATIVE_YTDL_CUSTOM_MODULES__/miniget\");\nconst utils = require('./utils');\n// Forces Node JS version of setTimeout for Electron based applications\nconst { setTimeout } = require(\"./__REACT_NATIVE_YTDL_CUSTOM_MODULES__/timers\");\nconst formatUtils = require('./format-utils');\nconst urlUtils = require('./url-utils');\nconst extras = require('./info-extras');\nconst sig = require('./sig');\nconst Cache = require('./cache');\n\n\nconst VIDEO_URL = 'https://www.youtube.com/watch?v=';\n\n\n// Cached for storing basic/full info.\nexports.cache = new Cache();\nexports.cookieCache = new Cache(1000 * 60 * 60 * 24);\nexports.watchPageCache = new Cache();\n\n\n// Special error class used to determine if an error is unrecoverable,\n// as in, ytdl-core should not try again to fetch the video metadata.\n// In this case, the video is usually unavailable in some way.\nclass UnrecoverableError extends Error {}\n\n\n// List of URLs that show up in `notice_url` for age restricted videos.\nconst AGE_RESTRICTED_URLS = [\n  'support.google.com/youtube/?p=age_restrictions',\n  'youtube.com/t/community_guidelines',\n];\n\n\n/**\n * Gets info from a video without getting additional formats.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n*/\nexports.getBasicInfo = async(id, options) => {\n  const retryOptions = Object.assign({}, miniget.defaultOptions, options.requestOptions);\n  const validate = info => {\n    let playErr = utils.playError(info.player_response, ['ERROR'], UnrecoverableError);\n    let privateErr = privateVideoError(info.player_response);\n    if (playErr || privateErr) {\n      throw playErr || privateErr;\n    }\n    return info && info.player_response && (\n      info.player_response.streamingData || isRental(info.player_response) || isNotYetBroadcasted(info.player_response)\n    );\n  };\n  let info = await pipeline([id, options], validate, retryOptions, [\n    getWatchHTMLPage,\n    getWatchJSONPage,\n    getVideoInfoPage,\n  ]);\n\n  Object.assign(info, {\n    formats: parseFormats(info.player_response),\n    related_videos: extras.getRelatedVideos(info),\n  });\n\n  // Add additional properties to info.\n  const media = extras.getMedia(info);\n  let additional = {\n    author: extras.getAuthor(info),\n    media,\n    likes: extras.getLikes(info),\n    dislikes: extras.getDislikes(info),\n    age_restricted: !!(media && media.notice_url && AGE_RESTRICTED_URLS.some(url => media.notice_url.includes(url))),\n\n    // Give the standard link to the video.\n    video_url: VIDEO_URL + id,\n  };\n\n  info.videoDetails = extras.cleanVideoDetails(Object.assign({},\n    info.player_response && info.player_response.microformat &&\n    info.player_response.microformat.playerMicroformatRenderer,\n    info.player_response && info.player_response.videoDetails, additional));\n\n  return info;\n};\n\nconst privateVideoError = player_response => {\n  let playability = player_response && player_response.playabilityStatus;\n  if (playability && playability.status === 'LOGIN_REQUIRED' && playability.messages &&\n    playability.messages.filter(m => /This is a private video/.test(m)).length) {\n    return new UnrecoverableError(playability.reason || (playability.messages && playability.messages[0]));\n  } else {\n    return null;\n  }\n};\n\n\nconst isRental = player_response => {\n  let playability = player_response.playabilityStatus;\n  return playability && playability.status === 'UNPLAYABLE' &&\n    playability.errorScreen && playability.errorScreen.playerLegacyDesktopYpcOfferRenderer;\n};\n\n\nconst isNotYetBroadcasted = player_response => {\n  let playability = player_response.playabilityStatus;\n  return playability && playability.status === 'LIVE_STREAM_OFFLINE';\n};\n\n\nconst getWatchHTMLURL = (id, options) => `${VIDEO_URL + id}&hl=${options.lang || 'en'}`;\nconst getWatchHTMLPageBody = (id, options) => {\n  const url = getWatchHTMLURL(id, options);\n  return exports.watchPageCache.getOrSet(url, () => miniget(url, options.requestOptions).text());\n};\n\n\nconst EMBED_URL = 'https://www.youtube.com/embed/';\nconst getEmbedPageBody = (id, options) => {\n  const embedUrl = `${EMBED_URL + id}?hl=${options.lang || 'en'}`;\n  return miniget(embedUrl, options.requestOptions).text();\n};\n\n\nconst getHTML5player = body => {\n  let html5playerRes =\n    /<script\\s+src=\"([^\"]+)\"(?:\\s+type=\"text\\/javascript\")?\\s+name=\"player_ias\\/base\"\\s*>|\"jsUrl\":\"([^\"]+)\"/\n      .exec(body);\n  return html5playerRes ? html5playerRes[1] || html5playerRes[2] : null;\n};\n\n\nconst getIdentityToken = (id, options, key, throwIfNotFound) =>\n  exports.cookieCache.getOrSet(key, async() => {\n    let page = await getWatchHTMLPageBody(id, options);\n    let match = page.match(/([\"'])ID_TOKEN\\1[:,]\\s?\"([^\"]+)\"/);\n    if (!match && throwIfNotFound) {\n      throw new UnrecoverableError('Cookie header used in request, but unable to find YouTube identity token');\n    }\n    return match && match[2];\n  });\n\n\n/**\n * Goes through each endpoint in the pipeline, retrying on failure if the error is recoverable.\n * If unable to succeed with one endpoint, moves onto the next one.\n *\n * @param {Array.<Object>} args\n * @param {Function} validate\n * @param {Object} retryOptions\n * @param {Array.<Function>} endpoints\n * @returns {[Object, Object, Object]}\n */\nconst pipeline = async(args, validate, retryOptions, endpoints) => {\n  let info;\n  for (let func of endpoints) {\n    try {\n      const newInfo = await retryFunc(func, args.concat([info]), retryOptions);\n      if (newInfo.player_response) {\n        newInfo.player_response.videoDetails = assign(\n          info && info.player_response && info.player_response.videoDetails,\n          newInfo.player_response.videoDetails);\n        newInfo.player_response = assign(info && info.player_response, newInfo.player_response);\n      }\n      info = assign(info, newInfo);\n      if (validate(info, false)) {\n        break;\n      }\n    } catch (err) {\n      if (err instanceof UnrecoverableError || func === endpoints[endpoints.length - 1]) {\n        throw err;\n      }\n      // Unable to find video metadata... so try next endpoint.\n    }\n  }\n  return info;\n};\n\n\n/**\n * Like Object.assign(), but ignores `null` and `undefined` from `source`.\n *\n * @param {Object} target\n * @param {Object} source\n * @returns {Object}\n */\nconst assign = (target, source) => {\n  if (!target || !source) { return target || source; }\n  for (let [key, value] of Object.entries(source)) {\n    if (value !== null && value !== undefined) {\n      target[key] = value;\n    }\n  }\n  return target;\n};\n\n\n/**\n * Given a function, calls it with `args` until it's successful,\n * or until it encounters an unrecoverable error.\n * Currently, any error from miniget is considered unrecoverable. Errors such as\n * too many redirects, invalid URL, status code 404, status code 502.\n *\n * @param {Function} func\n * @param {Array.<Object>} args\n * @param {Object} options\n * @param {number} options.maxRetries\n * @param {Object} options.backoff\n * @param {number} options.backoff.inc\n */\nconst retryFunc = async(func, args, options) => {\n  let currentTry = 0, result;\n  while (currentTry <= options.maxRetries) {\n    try {\n      result = await func(...args);\n      break;\n    } catch (err) {\n      if (err instanceof UnrecoverableError ||\n        (err instanceof miniget.MinigetError && err.statusCode < 500) || currentTry >= options.maxRetries) {\n        throw err;\n      }\n      let wait = Math.min(++currentTry * options.backoff.inc, options.backoff.max);\n      await new Promise(resolve => setTimeout(resolve, wait));\n    }\n  }\n  return result;\n};\n\n\nconst jsonClosingChars = /^[)\\]}'\\s]+/;\nconst parseJSON = (source, varName, json) => {\n  if (!json || typeof json === 'object') {\n    return json;\n  } else {\n    try {\n      json = json.replace(jsonClosingChars, '');\n      return JSON.parse(json);\n    } catch (err) {\n      throw Error(`Error parsing ${varName} in ${source}: ${err.message}`);\n    }\n  }\n};\n\n\nconst findJSON = (source, varName, body, left, right, prependJSON = '') => {\n  let jsonStr = utils.between(body, left, right);\n  if (!jsonStr) {\n    throw Error(`Could not find ${varName} in ${source}`);\n  }\n  return parseJSON(source, varName, utils.cutAfterJSON(`${prependJSON}${jsonStr}`));\n};\n\n\nconst findPlayerResponse = (source, info) => {\n  const player_response = info && (\n    (info.args && info.args.player_response) ||\n    info.player_response || info.playerResponse || info.embedded_player_response);\n  return parseJSON(source, 'player_response', player_response);\n};\n\n\nconst getWatchJSONURL = (id, options) => `${getWatchHTMLURL(id, options)}&pbj=1`;\nconst getWatchJSONPage = async(id, options) => {\n  const reqOptions = Object.assign({ headers: {} }, options.requestOptions);\n  let cookie = reqOptions.headers.Cookie || reqOptions.headers.cookie;\n  reqOptions.headers = Object.assign({\n    'x-youtube-client-name': '1',\n    'x-youtube-client-version': '2.20201203.06.00',\n    'x-youtube-identity-token': exports.cookieCache.get(cookie || 'browser') || '',\n  }, reqOptions.headers);\n\n  const setIdentityToken = async(key, throwIfNotFound) => {\n    if (reqOptions.headers['x-youtube-identity-token']) { return; }\n    reqOptions.headers['x-youtube-identity-token'] = await getIdentityToken(id, options, key, throwIfNotFound);\n  };\n\n  if (cookie) {\n    await setIdentityToken(cookie, true);\n  }\n\n  const jsonUrl = getWatchJSONURL(id, options);\n  let body = await miniget(jsonUrl, reqOptions).text();\n  let parsedBody = parseJSON('watch.json', 'body', body);\n  if (parsedBody.reload === 'now') {\n    await setIdentityToken('browser', false);\n  }\n  if (parsedBody.reload === 'now' || !Array.isArray(parsedBody)) {\n    throw Error('Unable to retrieve video metadata in watch.json');\n  }\n  let info = parsedBody.reduce((part, curr) => Object.assign(curr, part), {});\n  info.player_response = findPlayerResponse('watch.json', info);\n  info.html5player = info.player && info.player.assets && info.player.assets.js;\n\n  return info;\n};\n\n\nconst getWatchHTMLPage = async(id, options) => {\n  let body = await getWatchHTMLPageBody(id, options);\n  let info = { page: 'watch' };\n  try {\n    info.player_response = findJSON('watch.html', 'player_response',\n      body, /\\bytInitialPlayerResponse\\s*=\\s*\\{/i, '\\n', '{');\n  } catch (err) {\n    let args = findJSON('watch.html', 'player_response', body, /\\bytplayer\\.config\\s*=\\s*{/, '</script>', '{');\n    info.player_response = findPlayerResponse('watch.html', args);\n  }\n  info.response = findJSON('watch.html', 'response', body, /\\bytInitialData(\"\\])?\\s*=\\s*\\{/i, '\\n', '{');\n  info.html5player = getHTML5player(body);\n  return info;\n};\n\n\nconst INFO_HOST = 'www.youtube.com';\nconst INFO_PATH = '/get_video_info';\nconst VIDEO_EURL = 'https://youtube.googleapis.com/v/';\nconst getVideoInfoPage = async(id, options) => {\n  const url = urllib.format({\n    protocol: 'https',\n    host: INFO_HOST,\n    pathname: INFO_PATH,\n    query: {\n      video_id: id,\n      eurl: VIDEO_EURL + id,\n      ps: 'default',\n      gl: 'US',\n      hl: options.lang || 'en',\n    },\n  });\n  let body = await miniget(url, options.requestOptions).text();\n  let info = querystring.parse(body);\n  info.player_response = findPlayerResponse('get_video_info', info);\n  return info;\n};\n\n\n/**\n * @param {Object} player_response\n * @returns {Array.<Object>}\n */\nconst parseFormats = player_response => {\n  let formats = [];\n  if (player_response && player_response.streamingData) {\n    formats = formats\n      .concat(player_response.streamingData.formats || [])\n      .concat(player_response.streamingData.adaptiveFormats || []);\n  }\n  return formats;\n};\n\n\n/**\n * Gets info from a video additional formats and deciphered URLs.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n */\nexports.getInfo = async(id, options) => {\n  let info = await exports.getBasicInfo(id, options);\n  const hasManifest =\n    info.player_response && info.player_response.streamingData && (\n      info.player_response.streamingData.dashManifestUrl ||\n      info.player_response.streamingData.hlsManifestUrl\n    );\n  let funcs = [];\n  if (info.formats.length) {\n    info.html5player = info.html5player ||\n      getHTML5player(await getWatchHTMLPageBody(id, options)) || getHTML5player(await getEmbedPageBody(id, options));\n    if (!info.html5player) {\n      throw Error('Unable to find html5player file');\n    }\n    const html5player = urllib.resolve(VIDEO_URL, info.html5player);\n    funcs.push(sig.decipherFormats(info.formats, html5player, options));\n  }\n  if (hasManifest && info.player_response.streamingData.dashManifestUrl) {\n    let url = info.player_response.streamingData.dashManifestUrl;\n    funcs.push(getDashManifest(url, options));\n  }\n  if (hasManifest && info.player_response.streamingData.hlsManifestUrl) {\n    let url = info.player_response.streamingData.hlsManifestUrl;\n    funcs.push(getM3U8(url, options));\n  }\n\n  let results = await Promise.all(funcs);\n  info.formats = Object.values(Object.assign({}, ...results));\n  info.formats = info.formats.map(formatUtils.addFormatMeta);\n  info.formats.sort(formatUtils.sortFormats);\n  info.full = true;\n  return info;\n};\n\n\n/**\n * Gets additional DASH formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getDashManifest = (url, options) => new Promise((resolve, reject) => {\n  let formats = {};\n  const parser = sax.parser(false);\n  parser.onerror = reject;\n  let adaptationSet;\n  parser.onopentag = node => {\n    if (node.name === 'ADAPTATIONSET') {\n      adaptationSet = node.attributes;\n    } else if (node.name === 'REPRESENTATION') {\n      const itag = parseInt(node.attributes.ID);\n      if (!isNaN(itag)) {\n        formats[url] = Object.assign({\n          itag, url,\n          bitrate: parseInt(node.attributes.BANDWIDTH),\n          mimeType: `${adaptationSet.MIMETYPE}; codecs=\"${node.attributes.CODECS}\"`,\n        }, node.attributes.HEIGHT ? {\n          width: parseInt(node.attributes.WIDTH),\n          height: parseInt(node.attributes.HEIGHT),\n          fps: parseInt(node.attributes.FRAMERATE),\n        } : {\n          audioSampleRate: node.attributes.AUDIOSAMPLINGRATE,\n        });\n      }\n    }\n  };\n  parser.onend = () => { resolve(formats); };\n  const req = miniget(urllib.resolve(VIDEO_URL, url), options.requestOptions);\n  req.setEncoding('utf8');\n  req.on('error', reject);\n  req.on('data', chunk => { parser.write(chunk); });\n  req.on('end', parser.close.bind(parser));\n});\n\n\n/**\n * Gets additional formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getM3U8 = async(url, options) => {\n  url = urllib.resolve(VIDEO_URL, url);\n  let body = await miniget(url, options.requestOptions).text();\n  let formats = {};\n  body\n    .split('\\n')\n    .filter(line => /^https?:\\/\\//.test(line))\n    .forEach(line => {\n      const itag = parseInt(line.match(/\\/itag\\/(\\d+)\\//)[1]);\n      formats[line] = { itag, url: line };\n    });\n  return formats;\n};\n\n\n// Cache get info functions.\n// In case a user wants to get a video's info before downloading.\nfor (let funcName of ['getBasicInfo', 'getInfo']) {\n  /**\n   * @param {string} link\n   * @param {Object} options\n   * @returns {Promise<Object>}\n   */\n  const func = exports[funcName];\n  exports[funcName] = (link, options = {}) => {\n    utils.checkForUpdates();\n    let id = urlUtils.getVideoID(link);\n    const key = [funcName, id, options.lang].join('-');\n    return exports.cache.getOrSet(key, () => func(id, options));\n  };\n}\n\n\n// Export a few helpers.\nexports.validateID = urlUtils.validateID;\nexports.validateURL = urlUtils.validateURL;\nexports.getURLVideoID = urlUtils.getURLVideoID;\nexports.getVideoID = urlUtils.getVideoID;\n"]},"metadata":{},"sourceType":"script"}