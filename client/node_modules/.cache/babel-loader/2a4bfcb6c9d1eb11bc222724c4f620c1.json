{"ast":null,"code":"const url = require('url');\n\nconst miniget = require('miniget');\n\nconst querystring = require('querystring');\n\nconst Cache = require('./cache'); // A shared cache to keep track of html5player.js tokens.\n\n\nexports.cache = new Cache();\n/**\n * Extract signature deciphering tokens from html5player file.\n *\n * @param {string} html5playerfile\n * @param {Object} options\n * @returns {Promise<Array.<string>>}\n */\n\nexports.getTokens = (html5playerfile, options) => exports.cache.getOrSet(html5playerfile, async () => {\n  let body = await miniget(html5playerfile, options.requestOptions).text();\n  const tokens = exports.extractActions(body);\n\n  if (!tokens || !tokens.length) {\n    throw Error('Could not extract signature deciphering actions');\n  }\n\n  exports.cache.set(html5playerfile, tokens);\n  return tokens;\n});\n/**\n * Decipher a signature based on action tokens.\n *\n * @param {Array.<string>} tokens\n * @param {string} sig\n * @returns {string}\n */\n\n\nexports.decipher = (tokens, sig) => {\n  sig = sig.split('');\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    let token = tokens[i],\n        pos;\n\n    switch (token[0]) {\n      case 'r':\n        sig = sig.reverse();\n        break;\n\n      case 'w':\n        pos = ~~token.slice(1);\n        sig = swapHeadAndPosition(sig, pos);\n        break;\n\n      case 's':\n        pos = ~~token.slice(1);\n        sig = sig.slice(pos);\n        break;\n\n      case 'p':\n        pos = ~~token.slice(1);\n        sig.splice(0, pos);\n        break;\n    }\n  }\n\n  return sig.join('');\n};\n/**\n * Swaps the first element of an array with one of given position.\n *\n * @param {Array.<Object>} arr\n * @param {number} position\n * @returns {Array.<Object>}\n */\n\n\nconst swapHeadAndPosition = (arr, position) => {\n  const first = arr[0];\n  arr[0] = arr[position % arr.length];\n  arr[position] = first;\n  return arr;\n};\n\nconst jsVarStr = '[a-zA-Z_\\\\$][a-zA-Z_0-9]*';\nconst jsSingleQuoteStr = `'[^'\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^'\\\\\\\\]*)*'`;\nconst jsDoubleQuoteStr = `\"[^\"\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^\"\\\\\\\\]*)*\"`;\nconst jsQuoteStr = `(?:${jsSingleQuoteStr}|${jsDoubleQuoteStr})`;\nconst jsKeyStr = `(?:${jsVarStr}|${jsQuoteStr})`;\nconst jsPropStr = `(?:\\\\.${jsVarStr}|\\\\[${jsQuoteStr}\\\\])`;\nconst jsEmptyStr = `(?:''|\"\")`;\nconst reverseStr = ':function\\\\(a\\\\)\\\\{' + '(?:return )?a\\\\.reverse\\\\(\\\\)' + '\\\\}';\nconst sliceStr = ':function\\\\(a,b\\\\)\\\\{' + 'return a\\\\.slice\\\\(b\\\\)' + '\\\\}';\nconst spliceStr = ':function\\\\(a,b\\\\)\\\\{' + 'a\\\\.splice\\\\(0,b\\\\)' + '\\\\}';\nconst swapStr = ':function\\\\(a,b\\\\)\\\\{' + 'var c=a\\\\[0\\\\];a\\\\[0\\\\]=a\\\\[b(?:%a\\\\.length)?\\\\];a\\\\[b(?:%a\\\\.length)?\\\\]=c(?:;return a)?' + '\\\\}';\nconst actionsObjRegexp = new RegExp(`var (${jsVarStr})=\\\\{((?:(?:${jsKeyStr}${reverseStr}|${jsKeyStr}${sliceStr}|${jsKeyStr}${spliceStr}|${jsKeyStr}${swapStr}),?\\\\r?\\\\n?)+)\\\\};`);\nconst actionsFuncRegexp = new RegExp(`${`function(?: ${jsVarStr})?\\\\(a\\\\)\\\\{` + `a=a\\\\.split\\\\(${jsEmptyStr}\\\\);\\\\s*` + `((?:(?:a=)?${jsVarStr}`}${jsPropStr}\\\\(a,\\\\d+\\\\);)+)` + `return a\\\\.join\\\\(${jsEmptyStr}\\\\)` + `\\\\}`);\nconst reverseRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${reverseStr}`, 'm');\nconst sliceRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${sliceStr}`, 'm');\nconst spliceRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${spliceStr}`, 'm');\nconst swapRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${swapStr}`, 'm');\n/**\n * Extracts the actions that should be taken to decipher a signature.\n *\n * This searches for a function that performs string manipulations on\n * the signature. We already know what the 3 possible changes to a signature\n * are in order to decipher it. There is\n *\n * * Reversing the string.\n * * Removing a number of characters from the beginning.\n * * Swapping the first character with another position.\n *\n * Note, `Array#slice()` used to be used instead of `Array#splice()`,\n * it's kept in case we encounter any older html5player files.\n *\n * After retrieving the function that does this, we can see what actions\n * it takes on a signature.\n *\n * @param {string} body\n * @returns {Array.<string>}\n */\n\nexports.extractActions = body => {\n  const objResult = actionsObjRegexp.exec(body);\n  const funcResult = actionsFuncRegexp.exec(body);\n\n  if (!objResult || !funcResult) {\n    return null;\n  }\n\n  const obj = objResult[1].replace(/\\$/g, '\\\\$');\n  const objBody = objResult[2].replace(/\\$/g, '\\\\$');\n  const funcBody = funcResult[1].replace(/\\$/g, '\\\\$');\n  let result = reverseRegexp.exec(objBody);\n  const reverseKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\n  result = sliceRegexp.exec(objBody);\n  const sliceKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\n  result = spliceRegexp.exec(objBody);\n  const spliceKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\n  result = swapRegexp.exec(objBody);\n  const swapKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\n  const keys = `(${[reverseKey, sliceKey, spliceKey, swapKey].join('|')})`;\n  const myreg = `(?:a=)?${obj}(?:\\\\.${keys}|\\\\['${keys}'\\\\]|\\\\[\"${keys}\"\\\\])` + `\\\\(a,(\\\\d+)\\\\)`;\n  const tokenizeRegexp = new RegExp(myreg, 'g');\n  const tokens = [];\n\n  while ((result = tokenizeRegexp.exec(funcBody)) !== null) {\n    let key = result[1] || result[2] || result[3];\n\n    switch (key) {\n      case swapKey:\n        tokens.push(`w${result[4]}`);\n        break;\n\n      case reverseKey:\n        tokens.push('r');\n        break;\n\n      case sliceKey:\n        tokens.push(`s${result[4]}`);\n        break;\n\n      case spliceKey:\n        tokens.push(`p${result[4]}`);\n        break;\n    }\n  }\n\n  return tokens;\n};\n/**\n * @param {Object} format\n * @param {string} sig\n */\n\n\nexports.setDownloadURL = (format, sig) => {\n  let decodedUrl;\n\n  if (format.url) {\n    decodedUrl = format.url;\n  } else {\n    return;\n  }\n\n  try {\n    decodedUrl = decodeURIComponent(decodedUrl);\n  } catch (err) {\n    return;\n  } // Make some adjustments to the final url.\n\n\n  const parsedUrl = url.parse(decodedUrl, true); // Deleting the `search` part is necessary otherwise changes to\n  // `query` won't reflect when running `url.format()`\n\n  delete parsedUrl.search;\n  let query = parsedUrl.query; // This is needed for a speedier download.\n  // See https://github.com/fent/node-ytdl-core/issues/127\n\n  query.ratebypass = 'yes';\n\n  if (sig) {\n    // When YouTube provides a `sp` parameter the signature `sig` must go\n    // into the parameter it specifies.\n    // See https://github.com/fent/node-ytdl-core/issues/417\n    query[format.sp || 'signature'] = sig;\n  }\n\n  format.url = url.format(parsedUrl);\n};\n/**\n * Applies `sig.decipher()` to all format URL's.\n *\n * @param {Array.<Object>} formats\n * @param {string} html5player\n * @param {Object} options\n */\n\n\nexports.decipherFormats = async (formats, html5player, options) => {\n  let decipheredFormats = {};\n  let tokens = await exports.getTokens(html5player, options);\n  formats.forEach(format => {\n    let cipher = format.signatureCipher || format.cipher;\n\n    if (cipher) {\n      Object.assign(format, querystring.parse(cipher));\n      delete format.signatureCipher;\n      delete format.cipher;\n    }\n\n    const sig = tokens && format.s ? exports.decipher(tokens, format.s) : null;\n    exports.setDownloadURL(format, sig);\n    decipheredFormats[format.url] = format;\n  });\n  return decipheredFormats;\n};","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/ytdl-core/lib/sig.js"],"names":["url","require","miniget","querystring","Cache","exports","cache","getTokens","html5playerfile","options","getOrSet","body","requestOptions","text","tokens","extractActions","length","Error","set","decipher","sig","split","i","len","token","pos","reverse","slice","swapHeadAndPosition","splice","join","arr","position","first","jsVarStr","jsSingleQuoteStr","jsDoubleQuoteStr","jsQuoteStr","jsKeyStr","jsPropStr","jsEmptyStr","reverseStr","sliceStr","spliceStr","swapStr","actionsObjRegexp","RegExp","actionsFuncRegexp","reverseRegexp","sliceRegexp","spliceRegexp","swapRegexp","objResult","exec","funcResult","obj","replace","objBody","funcBody","result","reverseKey","sliceKey","spliceKey","swapKey","keys","myreg","tokenizeRegexp","key","push","setDownloadURL","format","decodedUrl","decodeURIComponent","err","parsedUrl","parse","search","query","ratebypass","sp","decipherFormats","formats","html5player","decipheredFormats","forEach","cipher","signatureCipher","Object","assign","s"],"mappings":"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","sourcesContent":["const url = require('url');\nconst miniget = require('miniget');\nconst querystring = require('querystring');\nconst Cache = require('./cache');\n\n\n// A shared cache to keep track of html5player.js tokens.\nexports.cache = new Cache();\n\n\n/**\n * Extract signature deciphering tokens from html5player file.\n *\n * @param {string} html5playerfile\n * @param {Object} options\n * @returns {Promise<Array.<string>>}\n */\nexports.getTokens = (html5playerfile, options) => exports.cache.getOrSet(html5playerfile, async() => {\n  let body = await miniget(html5playerfile, options.requestOptions).text();\n  const tokens = exports.extractActions(body);\n  if (!tokens || !tokens.length) {\n    throw Error('Could not extract signature deciphering actions');\n  }\n  exports.cache.set(html5playerfile, tokens);\n  return tokens;\n});\n\n\n/**\n * Decipher a signature based on action tokens.\n *\n * @param {Array.<string>} tokens\n * @param {string} sig\n * @returns {string}\n */\nexports.decipher = (tokens, sig) => {\n  sig = sig.split('');\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    let token = tokens[i], pos;\n    switch (token[0]) {\n      case 'r':\n        sig = sig.reverse();\n        break;\n      case 'w':\n        pos = ~~token.slice(1);\n        sig = swapHeadAndPosition(sig, pos);\n        break;\n      case 's':\n        pos = ~~token.slice(1);\n        sig = sig.slice(pos);\n        break;\n      case 'p':\n        pos = ~~token.slice(1);\n        sig.splice(0, pos);\n        break;\n    }\n  }\n  return sig.join('');\n};\n\n\n/**\n * Swaps the first element of an array with one of given position.\n *\n * @param {Array.<Object>} arr\n * @param {number} position\n * @returns {Array.<Object>}\n */\nconst swapHeadAndPosition = (arr, position) => {\n  const first = arr[0];\n  arr[0] = arr[position % arr.length];\n  arr[position] = first;\n  return arr;\n};\n\n\nconst jsVarStr = '[a-zA-Z_\\\\$][a-zA-Z_0-9]*';\nconst jsSingleQuoteStr = `'[^'\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^'\\\\\\\\]*)*'`;\nconst jsDoubleQuoteStr = `\"[^\"\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^\"\\\\\\\\]*)*\"`;\nconst jsQuoteStr = `(?:${jsSingleQuoteStr}|${jsDoubleQuoteStr})`;\nconst jsKeyStr = `(?:${jsVarStr}|${jsQuoteStr})`;\nconst jsPropStr = `(?:\\\\.${jsVarStr}|\\\\[${jsQuoteStr}\\\\])`;\nconst jsEmptyStr = `(?:''|\"\")`;\nconst reverseStr = ':function\\\\(a\\\\)\\\\{' +\n  '(?:return )?a\\\\.reverse\\\\(\\\\)' +\n'\\\\}';\nconst sliceStr = ':function\\\\(a,b\\\\)\\\\{' +\n  'return a\\\\.slice\\\\(b\\\\)' +\n'\\\\}';\nconst spliceStr = ':function\\\\(a,b\\\\)\\\\{' +\n  'a\\\\.splice\\\\(0,b\\\\)' +\n'\\\\}';\nconst swapStr = ':function\\\\(a,b\\\\)\\\\{' +\n  'var c=a\\\\[0\\\\];a\\\\[0\\\\]=a\\\\[b(?:%a\\\\.length)?\\\\];a\\\\[b(?:%a\\\\.length)?\\\\]=c(?:;return a)?' +\n'\\\\}';\nconst actionsObjRegexp = new RegExp(\n  `var (${jsVarStr})=\\\\{((?:(?:${\n    jsKeyStr}${reverseStr}|${\n    jsKeyStr}${sliceStr}|${\n    jsKeyStr}${spliceStr}|${\n    jsKeyStr}${swapStr\n  }),?\\\\r?\\\\n?)+)\\\\};`);\nconst actionsFuncRegexp = new RegExp(`${`function(?: ${jsVarStr})?\\\\(a\\\\)\\\\{` +\n    `a=a\\\\.split\\\\(${jsEmptyStr}\\\\);\\\\s*` +\n    `((?:(?:a=)?${jsVarStr}`}${\n  jsPropStr\n}\\\\(a,\\\\d+\\\\);)+)` +\n    `return a\\\\.join\\\\(${jsEmptyStr}\\\\)` +\n  `\\\\}`);\nconst reverseRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${reverseStr}`, 'm');\nconst sliceRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${sliceStr}`, 'm');\nconst spliceRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${spliceStr}`, 'm');\nconst swapRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${swapStr}`, 'm');\n\n\n/**\n * Extracts the actions that should be taken to decipher a signature.\n *\n * This searches for a function that performs string manipulations on\n * the signature. We already know what the 3 possible changes to a signature\n * are in order to decipher it. There is\n *\n * * Reversing the string.\n * * Removing a number of characters from the beginning.\n * * Swapping the first character with another position.\n *\n * Note, `Array#slice()` used to be used instead of `Array#splice()`,\n * it's kept in case we encounter any older html5player files.\n *\n * After retrieving the function that does this, we can see what actions\n * it takes on a signature.\n *\n * @param {string} body\n * @returns {Array.<string>}\n */\nexports.extractActions = body => {\n  const objResult = actionsObjRegexp.exec(body);\n  const funcResult = actionsFuncRegexp.exec(body);\n  if (!objResult || !funcResult) { return null; }\n\n  const obj = objResult[1].replace(/\\$/g, '\\\\$');\n  const objBody = objResult[2].replace(/\\$/g, '\\\\$');\n  const funcBody = funcResult[1].replace(/\\$/g, '\\\\$');\n\n  let result = reverseRegexp.exec(objBody);\n  const reverseKey = result && result[1]\n    .replace(/\\$/g, '\\\\$')\n    .replace(/\\$|^'|^\"|'$|\"$/g, '');\n  result = sliceRegexp.exec(objBody);\n  const sliceKey = result && result[1]\n    .replace(/\\$/g, '\\\\$')\n    .replace(/\\$|^'|^\"|'$|\"$/g, '');\n  result = spliceRegexp.exec(objBody);\n  const spliceKey = result && result[1]\n    .replace(/\\$/g, '\\\\$')\n    .replace(/\\$|^'|^\"|'$|\"$/g, '');\n  result = swapRegexp.exec(objBody);\n  const swapKey = result && result[1]\n    .replace(/\\$/g, '\\\\$')\n    .replace(/\\$|^'|^\"|'$|\"$/g, '');\n\n  const keys = `(${[reverseKey, sliceKey, spliceKey, swapKey].join('|')})`;\n  const myreg = `(?:a=)?${obj\n  }(?:\\\\.${keys}|\\\\['${keys}'\\\\]|\\\\[\"${keys}\"\\\\])` +\n    `\\\\(a,(\\\\d+)\\\\)`;\n  const tokenizeRegexp = new RegExp(myreg, 'g');\n  const tokens = [];\n  while ((result = tokenizeRegexp.exec(funcBody)) !== null) {\n    let key = result[1] || result[2] || result[3];\n    switch (key) {\n      case swapKey:\n        tokens.push(`w${result[4]}`);\n        break;\n      case reverseKey:\n        tokens.push('r');\n        break;\n      case sliceKey:\n        tokens.push(`s${result[4]}`);\n        break;\n      case spliceKey:\n        tokens.push(`p${result[4]}`);\n        break;\n    }\n  }\n  return tokens;\n};\n\n\n/**\n * @param {Object} format\n * @param {string} sig\n */\nexports.setDownloadURL = (format, sig) => {\n  let decodedUrl;\n  if (format.url) {\n    decodedUrl = format.url;\n  } else {\n    return;\n  }\n\n  try {\n    decodedUrl = decodeURIComponent(decodedUrl);\n  } catch (err) {\n    return;\n  }\n\n  // Make some adjustments to the final url.\n  const parsedUrl = url.parse(decodedUrl, true);\n\n  // Deleting the `search` part is necessary otherwise changes to\n  // `query` won't reflect when running `url.format()`\n  delete parsedUrl.search;\n\n  let query = parsedUrl.query;\n\n  // This is needed for a speedier download.\n  // See https://github.com/fent/node-ytdl-core/issues/127\n  query.ratebypass = 'yes';\n  if (sig) {\n    // When YouTube provides a `sp` parameter the signature `sig` must go\n    // into the parameter it specifies.\n    // See https://github.com/fent/node-ytdl-core/issues/417\n    query[format.sp || 'signature'] = sig;\n  }\n\n  format.url = url.format(parsedUrl);\n};\n\n\n/**\n * Applies `sig.decipher()` to all format URL's.\n *\n * @param {Array.<Object>} formats\n * @param {string} html5player\n * @param {Object} options\n */\nexports.decipherFormats = async(formats, html5player, options) => {\n  let decipheredFormats = {};\n  let tokens = await exports.getTokens(html5player, options);\n  formats.forEach(format => {\n    let cipher = format.signatureCipher || format.cipher;\n    if (cipher) {\n      Object.assign(format, querystring.parse(cipher));\n      delete format.signatureCipher;\n      delete format.cipher;\n    }\n    const sig = tokens && format.s ? exports.decipher(tokens, format.s) : null;\n    exports.setDownloadURL(format, sig);\n    decipheredFormats[format.url] = format;\n  });\n  return decipheredFormats;\n};\n"]},"metadata":{},"sourceType":"script"}