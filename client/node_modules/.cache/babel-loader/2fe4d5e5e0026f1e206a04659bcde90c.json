{"ast":null,"code":"/*jshint node:true*/\n'use strict';\n\nvar spawn = require('child_process').spawn;\n\nvar path = require('path');\n\nvar fs = require('fs');\n\nvar async = require('async');\n\nvar utils = require('./utils');\n\nvar nlRegexp = /\\r\\n|\\r|\\n/g;\n/*\n *! Processor methods\n */\n\n/**\n * Run ffprobe asynchronously and store data in command\n *\n * @param {FfmpegCommand} command\n * @private\n */\n\nfunction runFfprobe(command) {\n  const inputProbeIndex = 0;\n\n  if (command._inputs[inputProbeIndex].isStream) {\n    // Don't probe input streams as this will consume them\n    return;\n  }\n\n  command.ffprobe(inputProbeIndex, function (err, data) {\n    command._ffprobeData = data;\n  });\n}\n\nmodule.exports = function (proto) {\n  /**\n   * Emitted just after ffmpeg has been spawned.\n   *\n   * @event FfmpegCommand#start\n   * @param {String} command ffmpeg command line\n   */\n\n  /**\n   * Emitted when ffmpeg reports progress information\n   *\n   * @event FfmpegCommand#progress\n   * @param {Object} progress progress object\n   * @param {Number} progress.frames number of frames transcoded\n   * @param {Number} progress.currentFps current processing speed in frames per second\n   * @param {Number} progress.currentKbps current output generation speed in kilobytes per second\n   * @param {Number} progress.targetSize current output file size\n   * @param {String} progress.timemark current video timemark\n   * @param {Number} [progress.percent] processing progress (may not be available depending on input)\n   */\n\n  /**\n   * Emitted when ffmpeg outputs to stderr\n   *\n   * @event FfmpegCommand#stderr\n   * @param {String} line stderr output line\n   */\n\n  /**\n   * Emitted when ffmpeg reports input codec data\n   *\n   * @event FfmpegCommand#codecData\n   * @param {Object} codecData codec data object\n   * @param {String} codecData.format input format name\n   * @param {String} codecData.audio input audio codec name\n   * @param {String} codecData.audio_details input audio codec parameters\n   * @param {String} codecData.video input video codec name\n   * @param {String} codecData.video_details input video codec parameters\n   */\n\n  /**\n   * Emitted when an error happens when preparing or running a command\n   *\n   * @event FfmpegCommand#error\n   * @param {Error} error error object, with optional properties 'inputStreamError' / 'outputStreamError' for errors on their respective streams\n   * @param {String|null} stdout ffmpeg stdout, unless outputting to a stream\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n  /**\n   * Emitted when a command finishes processing\n   *\n   * @event FfmpegCommand#end\n   * @param {Array|String|null} [filenames|stdout] generated filenames when taking screenshots, ffmpeg stdout when not outputting to a stream, null otherwise\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n  /**\n   * Spawn an ffmpeg process\n   *\n   * The 'options' argument may contain the following keys:\n   * - 'niceness': specify process niceness, ignored on Windows (default: 0)\n   * - `cwd`: change working directory\n   * - 'captureStdout': capture stdout and pass it to 'endCB' as its 2nd argument (default: false)\n   * - 'stdoutLines': override command limit (default: use command limit)\n   *\n   * The 'processCB' callback, if present, is called as soon as the process is created and\n   * receives a nodejs ChildProcess object.  It may not be called at all if an error happens\n   * before spawning the process.\n   *\n   * The 'endCB' callback is called either when an error occurs or when the ffmpeg process finishes.\n   *\n   * @method FfmpegCommand#_spawnFfmpeg\n   * @param {Array} args ffmpeg command line argument list\n   * @param {Object} [options] spawn options (see above)\n   * @param {Function} [processCB] callback called with process object and stdout/stderr ring buffers when process has been created\n   * @param {Function} endCB callback called with error (if applicable) and stdout/stderr ring buffers when process finished\n   * @private\n   */\n  proto._spawnFfmpeg = function (args, options, processCB, endCB) {\n    // Enable omitting options\n    if (typeof options === 'function') {\n      endCB = processCB;\n      processCB = options;\n      options = {};\n    } // Enable omitting processCB\n\n\n    if (typeof endCB === 'undefined') {\n      endCB = processCB;\n\n      processCB = function () {};\n    }\n\n    var maxLines = 'stdoutLines' in options ? options.stdoutLines : this.options.stdoutLines; // Find ffmpeg\n\n    this._getFfmpegPath(function (err, command) {\n      if (err) {\n        return endCB(err);\n      } else if (!command || command.length === 0) {\n        return endCB(new Error('Cannot find ffmpeg'));\n      } // Apply niceness\n\n\n      if (options.niceness && options.niceness !== 0 && !utils.isWindows) {\n        args.unshift('-n', options.niceness, command);\n        command = 'nice';\n      }\n\n      var stdoutRing = utils.linesRing(maxLines);\n      var stdoutClosed = false;\n      var stderrRing = utils.linesRing(maxLines);\n      var stderrClosed = false; // Spawn process\n\n      var ffmpegProc = spawn(command, args, options);\n\n      if (ffmpegProc.stderr) {\n        ffmpegProc.stderr.setEncoding('utf8');\n      }\n\n      ffmpegProc.on('error', function (err) {\n        endCB(err);\n      }); // Ensure we wait for captured streams to end before calling endCB\n\n      var exitError = null;\n\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && (stdoutClosed || !options.captureStdout) && stderrClosed) {\n          endCB(exitError, stdoutRing, stderrRing);\n        }\n      } // Handle process exit\n\n\n      var processExited = false;\n      ffmpegProc.on('exit', function (code, signal) {\n        processExited = true;\n\n        if (signal) {\n          handleExit(new Error('ffmpeg was killed with signal ' + signal));\n        } else if (code) {\n          handleExit(new Error('ffmpeg exited with code ' + code));\n        } else {\n          handleExit();\n        }\n      }); // Capture stdout if specified\n\n      if (options.captureStdout) {\n        ffmpegProc.stdout.on('data', function (data) {\n          stdoutRing.append(data);\n        });\n        ffmpegProc.stdout.on('close', function () {\n          stdoutRing.close();\n          stdoutClosed = true;\n          handleExit();\n        });\n      } // Capture stderr if specified\n\n\n      ffmpegProc.stderr.on('data', function (data) {\n        stderrRing.append(data);\n      });\n      ffmpegProc.stderr.on('close', function () {\n        stderrRing.close();\n        stderrClosed = true;\n        handleExit();\n      }); // Call process callback\n\n      processCB(ffmpegProc, stdoutRing, stderrRing);\n    });\n  };\n  /**\n   * Build the argument list for an ffmpeg command\n   *\n   * @method FfmpegCommand#_getArguments\n   * @return argument list\n   * @private\n   */\n\n\n  proto._getArguments = function () {\n    var complexFilters = this._complexFilters.get();\n\n    var fileOutput = this._outputs.some(function (output) {\n      return output.isFile;\n    });\n\n    return [].concat( // Inputs and input options\n    this._inputs.reduce(function (args, input) {\n      var source = typeof input.source === 'string' ? input.source : 'pipe:0'; // For each input, add input options, then '-i <source>'\n\n      return args.concat(input.options.get(), ['-i', source]);\n    }, []), // Global options\n    this._global.get(), // Overwrite if we have file outputs\n    fileOutput ? ['-y'] : [], // Complex filters\n    complexFilters, // Outputs, filters and output options\n    this._outputs.reduce(function (args, output) {\n      var sizeFilters = utils.makeFilterStrings(output.sizeFilters.get());\n      var audioFilters = output.audioFilters.get();\n      var videoFilters = output.videoFilters.get().concat(sizeFilters);\n      var outputArg;\n\n      if (!output.target) {\n        outputArg = [];\n      } else if (typeof output.target === 'string') {\n        outputArg = [output.target];\n      } else {\n        outputArg = ['pipe:1'];\n      }\n\n      return args.concat(output.audio.get(), audioFilters.length ? ['-filter:a', audioFilters.join(',')] : [], output.video.get(), videoFilters.length ? ['-filter:v', videoFilters.join(',')] : [], output.options.get(), outputArg);\n    }, []));\n  };\n  /**\n   * Prepare execution of an ffmpeg command\n   *\n   * Checks prerequisites for the execution of the command (codec/format availability, flvtool...),\n   * then builds the argument list for ffmpeg and pass them to 'callback'.\n   *\n   * @method FfmpegCommand#_prepare\n   * @param {Function} callback callback with signature (err, args)\n   * @param {Boolean} [readMetadata=false] read metadata before processing\n   * @private\n   */\n\n\n  proto._prepare = function (callback, readMetadata) {\n    var self = this;\n    async.waterfall([// Check codecs and formats\n    function (cb) {\n      self._checkCapabilities(cb);\n    }, // Read metadata if required\n    function (cb) {\n      if (!readMetadata) {\n        return cb();\n      }\n\n      self.ffprobe(0, function (err, data) {\n        if (!err) {\n          self._ffprobeData = data;\n        }\n\n        cb();\n      });\n    }, // Check for flvtool2/flvmeta if necessary\n    function (cb) {\n      var flvmeta = self._outputs.some(function (output) {\n        // Remove flvmeta flag on non-file output\n        if (output.flags.flvmeta && !output.isFile) {\n          self.logger.warn('Updating flv metadata is only supported for files');\n          output.flags.flvmeta = false;\n        }\n\n        return output.flags.flvmeta;\n      });\n\n      if (flvmeta) {\n        self._getFlvtoolPath(function (err) {\n          cb(err);\n        });\n      } else {\n        cb();\n      }\n    }, // Build argument list\n    function (cb) {\n      var args;\n\n      try {\n        args = self._getArguments();\n      } catch (e) {\n        return cb(e);\n      }\n\n      cb(null, args);\n    }, // Add \"-strict experimental\" option where needed\n    function (args, cb) {\n      self.availableEncoders(function (err, encoders) {\n        for (var i = 0; i < args.length; i++) {\n          if (args[i] === '-acodec' || args[i] === '-vcodec') {\n            i++;\n\n            if (args[i] in encoders && encoders[args[i]].experimental) {\n              args.splice(i + 1, 0, '-strict', 'experimental');\n              i += 2;\n            }\n          }\n        }\n\n        cb(null, args);\n      });\n    }], callback);\n\n    if (!readMetadata) {\n      // Read metadata as soon as 'progress' listeners are added\n      if (this.listeners('progress').length > 0) {\n        // Read metadata in parallel\n        runFfprobe(this);\n      } else {\n        // Read metadata as soon as the first 'progress' listener is added\n        this.once('newListener', function (event) {\n          if (event === 'progress') {\n            runFfprobe(this);\n          }\n        });\n      }\n    }\n  };\n  /**\n   * Run ffmpeg command\n   *\n   * @method FfmpegCommand#run\n   * @category Processing\n   * @aliases exec,execute\n   */\n\n\n  proto.exec = proto.execute = proto.run = function () {\n    var self = this; // Check if at least one output is present\n\n    var outputPresent = this._outputs.some(function (output) {\n      return 'target' in output;\n    });\n\n    if (!outputPresent) {\n      throw new Error('No output specified');\n    } // Get output stream if any\n\n\n    var outputStream = this._outputs.filter(function (output) {\n      return typeof output.target !== 'string';\n    })[0]; // Get input stream if any\n\n\n    var inputStream = this._inputs.filter(function (input) {\n      return typeof input.source !== 'string';\n    })[0]; // Ensure we send 'end' or 'error' only once\n\n\n    var ended = false;\n\n    function emitEnd(err, stdout, stderr) {\n      if (!ended) {\n        ended = true;\n\n        if (err) {\n          self.emit('error', err, stdout, stderr);\n        } else {\n          self.emit('end', stdout, stderr);\n        }\n      }\n    }\n\n    self._prepare(function (err, args) {\n      if (err) {\n        return emitEnd(err);\n      } // Run ffmpeg\n\n\n      self._spawnFfmpeg(args, {\n        captureStdout: !outputStream,\n        niceness: self.options.niceness,\n        cwd: self.options.cwd\n      }, function processCB(ffmpegProc, stdoutRing, stderrRing) {\n        self.ffmpegProc = ffmpegProc;\n        self.emit('start', 'ffmpeg ' + args.join(' ')); // Pipe input stream if any\n\n        if (inputStream) {\n          inputStream.source.on('error', function (err) {\n            var reportingErr = new Error('Input stream error: ' + err.message);\n            reportingErr.inputStreamError = err;\n            emitEnd(reportingErr);\n            ffmpegProc.kill();\n          });\n          inputStream.source.resume();\n          inputStream.source.pipe(ffmpegProc.stdin); // Set stdin error handler on ffmpeg (prevents nodejs catching the error, but\n          // ffmpeg will fail anyway, so no need to actually handle anything)\n\n          ffmpegProc.stdin.on('error', function () {});\n        } // Setup timeout if requested\n\n\n        var processTimer;\n\n        if (self.options.timeout) {\n          processTimer = setTimeout(function () {\n            var msg = 'process ran into a timeout (' + self.options.timeout + 's)';\n            emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());\n            ffmpegProc.kill();\n          }, self.options.timeout * 1000);\n        }\n\n        if (outputStream) {\n          // Pipe ffmpeg stdout to output stream\n          ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts); // Handle output stream events\n\n          outputStream.target.on('close', function () {\n            self.logger.debug('Output stream closed, scheduling kill for ffmpeg process'); // Don't kill process yet, to give a chance to ffmpeg to\n            // terminate successfully first  This is necessary because\n            // under load, the process 'exit' event sometimes happens\n            // after the output stream 'close' event.\n\n            setTimeout(function () {\n              emitEnd(new Error('Output stream closed'));\n              ffmpegProc.kill();\n            }, 20);\n          });\n          outputStream.target.on('error', function (err) {\n            self.logger.debug('Output stream error, killing ffmpeg process');\n            var reportingErr = new Error('Output stream error: ' + err.message);\n            reportingErr.outputStreamError = err;\n            emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());\n            ffmpegProc.kill('SIGKILL');\n          });\n        } // Setup stderr handling\n\n\n        if (stderrRing) {\n          // 'stderr' event\n          if (self.listeners('stderr').length) {\n            stderrRing.callback(function (line) {\n              self.emit('stderr', line);\n            });\n          } // 'codecData' event\n\n\n          if (self.listeners('codecData').length) {\n            var codecDataSent = false;\n            var codecObject = {};\n            stderrRing.callback(function (line) {\n              if (!codecDataSent) codecDataSent = utils.extractCodecData(self, line, codecObject);\n            });\n          } // 'progress' event\n\n\n          if (self.listeners('progress').length) {\n            stderrRing.callback(function (line) {\n              utils.extractProgress(self, line);\n            });\n          }\n        }\n      }, function endCB(err, stdoutRing, stderrRing) {\n        delete self.ffmpegProc;\n\n        if (err) {\n          if (err.message.match(/ffmpeg exited with code/)) {\n            // Add ffmpeg error message\n            err.message += ': ' + utils.extractError(stderrRing.get());\n          }\n\n          emitEnd(err, stdoutRing.get(), stderrRing.get());\n        } else {\n          // Find out which outputs need flv metadata\n          var flvmeta = self._outputs.filter(function (output) {\n            return output.flags.flvmeta;\n          });\n\n          if (flvmeta.length) {\n            self._getFlvtoolPath(function (err, flvtool) {\n              if (err) {\n                return emitEnd(err);\n              }\n\n              async.each(flvmeta, function (output, cb) {\n                spawn(flvtool, ['-U', output.target]).on('error', function (err) {\n                  cb(new Error('Error running ' + flvtool + ' on ' + output.target + ': ' + err.message));\n                }).on('exit', function (code, signal) {\n                  if (code !== 0 || signal) {\n                    cb(new Error(flvtool + ' ' + (signal ? 'received signal ' + signal : 'exited with code ' + code)) + ' when running on ' + output.target);\n                  } else {\n                    cb();\n                  }\n                });\n              }, function (err) {\n                if (err) {\n                  emitEnd(err);\n                } else {\n                  emitEnd(null, stdoutRing.get(), stderrRing.get());\n                }\n              });\n            });\n          } else {\n            emitEnd(null, stdoutRing.get(), stderrRing.get());\n          }\n        }\n      });\n    });\n  };\n  /**\n   * Renice current and/or future ffmpeg processes\n   *\n   * Ignored on Windows platforms.\n   *\n   * @method FfmpegCommand#renice\n   * @category Processing\n   *\n   * @param {Number} [niceness=0] niceness value between -20 (highest priority) and 20 (lowest priority)\n   * @return FfmpegCommand\n   */\n\n\n  proto.renice = function (niceness) {\n    if (!utils.isWindows) {\n      niceness = niceness || 0;\n\n      if (niceness < -20 || niceness > 20) {\n        this.logger.warn('Invalid niceness value: ' + niceness + ', must be between -20 and 20');\n      }\n\n      niceness = Math.min(20, Math.max(-20, niceness));\n      this.options.niceness = niceness;\n\n      if (this.ffmpegProc) {\n        var logger = this.logger;\n        var pid = this.ffmpegProc.pid;\n        var renice = spawn('renice', [niceness, '-p', pid]);\n        renice.on('error', function (err) {\n          logger.warn('could not renice process ' + pid + ': ' + err.message);\n        });\n        renice.on('exit', function (code, signal) {\n          if (signal) {\n            logger.warn('could not renice process ' + pid + ': renice was killed by signal ' + signal);\n          } else if (code) {\n            logger.warn('could not renice process ' + pid + ': renice exited with ' + code);\n          } else {\n            logger.info('successfully reniced process ' + pid + ' to ' + niceness + ' niceness');\n          }\n        });\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Kill current ffmpeg process, if any\n   *\n   * @method FfmpegCommand#kill\n   * @category Processing\n   *\n   * @param {String} [signal=SIGKILL] signal name\n   * @return FfmpegCommand\n   */\n\n\n  proto.kill = function (signal) {\n    if (!this.ffmpegProc) {\n      this.logger.warn('No running ffmpeg process, cannot send signal');\n    } else {\n      this.ffmpegProc.kill(signal || 'SIGKILL');\n    }\n\n    return this;\n  };\n};","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/fluent-ffmpeg/lib/processor.js"],"names":["spawn","require","path","fs","async","utils","nlRegexp","runFfprobe","command","inputProbeIndex","_inputs","isStream","ffprobe","err","data","_ffprobeData","module","exports","proto","_spawnFfmpeg","args","options","processCB","endCB","maxLines","stdoutLines","_getFfmpegPath","length","Error","niceness","isWindows","unshift","stdoutRing","linesRing","stdoutClosed","stderrRing","stderrClosed","ffmpegProc","stderr","setEncoding","on","exitError","handleExit","processExited","captureStdout","code","signal","stdout","append","close","_getArguments","complexFilters","_complexFilters","get","fileOutput","_outputs","some","output","isFile","concat","reduce","input","source","_global","sizeFilters","makeFilterStrings","audioFilters","videoFilters","outputArg","target","audio","join","video","_prepare","callback","readMetadata","self","waterfall","cb","_checkCapabilities","flvmeta","flags","logger","warn","_getFlvtoolPath","e","availableEncoders","encoders","i","experimental","splice","listeners","once","event","exec","execute","run","outputPresent","outputStream","filter","inputStream","ended","emitEnd","emit","cwd","reportingErr","message","inputStreamError","kill","resume","pipe","stdin","processTimer","timeout","setTimeout","msg","pipeopts","debug","outputStreamError","line","codecDataSent","codecObject","extractCodecData","extractProgress","match","extractError","flvtool","each","renice","Math","min","max","pid","info"],"mappings":"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","sourcesContent":["/*jshint node:true*/\n'use strict';\n\nvar spawn = require('child_process').spawn;\nvar path = require('path');\nvar fs = require('fs');\nvar async = require('async');\nvar utils = require('./utils');\n\nvar nlRegexp = /\\r\\n|\\r|\\n/g;\n\n/*\n *! Processor methods\n */\n\n\n/**\n * Run ffprobe asynchronously and store data in command\n *\n * @param {FfmpegCommand} command\n * @private\n */\nfunction runFfprobe(command) {\n  const inputProbeIndex = 0;\n  if (command._inputs[inputProbeIndex].isStream) {\n    // Don't probe input streams as this will consume them\n    return;\n  }\n  command.ffprobe(inputProbeIndex, function(err, data) {\n    command._ffprobeData = data;\n  });\n}\n\n\nmodule.exports = function(proto) {\n  /**\n   * Emitted just after ffmpeg has been spawned.\n   *\n   * @event FfmpegCommand#start\n   * @param {String} command ffmpeg command line\n   */\n\n  /**\n   * Emitted when ffmpeg reports progress information\n   *\n   * @event FfmpegCommand#progress\n   * @param {Object} progress progress object\n   * @param {Number} progress.frames number of frames transcoded\n   * @param {Number} progress.currentFps current processing speed in frames per second\n   * @param {Number} progress.currentKbps current output generation speed in kilobytes per second\n   * @param {Number} progress.targetSize current output file size\n   * @param {String} progress.timemark current video timemark\n   * @param {Number} [progress.percent] processing progress (may not be available depending on input)\n   */\n\n  /**\n   * Emitted when ffmpeg outputs to stderr\n   *\n   * @event FfmpegCommand#stderr\n   * @param {String} line stderr output line\n   */\n\n  /**\n   * Emitted when ffmpeg reports input codec data\n   *\n   * @event FfmpegCommand#codecData\n   * @param {Object} codecData codec data object\n   * @param {String} codecData.format input format name\n   * @param {String} codecData.audio input audio codec name\n   * @param {String} codecData.audio_details input audio codec parameters\n   * @param {String} codecData.video input video codec name\n   * @param {String} codecData.video_details input video codec parameters\n   */\n\n  /**\n   * Emitted when an error happens when preparing or running a command\n   *\n   * @event FfmpegCommand#error\n   * @param {Error} error error object, with optional properties 'inputStreamError' / 'outputStreamError' for errors on their respective streams\n   * @param {String|null} stdout ffmpeg stdout, unless outputting to a stream\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n  /**\n   * Emitted when a command finishes processing\n   *\n   * @event FfmpegCommand#end\n   * @param {Array|String|null} [filenames|stdout] generated filenames when taking screenshots, ffmpeg stdout when not outputting to a stream, null otherwise\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n\n  /**\n   * Spawn an ffmpeg process\n   *\n   * The 'options' argument may contain the following keys:\n   * - 'niceness': specify process niceness, ignored on Windows (default: 0)\n   * - `cwd`: change working directory\n   * - 'captureStdout': capture stdout and pass it to 'endCB' as its 2nd argument (default: false)\n   * - 'stdoutLines': override command limit (default: use command limit)\n   *\n   * The 'processCB' callback, if present, is called as soon as the process is created and\n   * receives a nodejs ChildProcess object.  It may not be called at all if an error happens\n   * before spawning the process.\n   *\n   * The 'endCB' callback is called either when an error occurs or when the ffmpeg process finishes.\n   *\n   * @method FfmpegCommand#_spawnFfmpeg\n   * @param {Array} args ffmpeg command line argument list\n   * @param {Object} [options] spawn options (see above)\n   * @param {Function} [processCB] callback called with process object and stdout/stderr ring buffers when process has been created\n   * @param {Function} endCB callback called with error (if applicable) and stdout/stderr ring buffers when process finished\n   * @private\n   */\n  proto._spawnFfmpeg = function(args, options, processCB, endCB) {\n    // Enable omitting options\n    if (typeof options === 'function') {\n      endCB = processCB;\n      processCB = options;\n      options = {};\n    }\n\n    // Enable omitting processCB\n    if (typeof endCB === 'undefined') {\n      endCB = processCB;\n      processCB = function() {};\n    }\n\n    var maxLines = 'stdoutLines' in options ? options.stdoutLines : this.options.stdoutLines;\n\n    // Find ffmpeg\n    this._getFfmpegPath(function(err, command) {\n      if (err) {\n        return endCB(err);\n      } else if (!command || command.length === 0) {\n        return endCB(new Error('Cannot find ffmpeg'));\n      }\n\n      // Apply niceness\n      if (options.niceness && options.niceness !== 0 && !utils.isWindows) {\n        args.unshift('-n', options.niceness, command);\n        command = 'nice';\n      }\n\n      var stdoutRing = utils.linesRing(maxLines);\n      var stdoutClosed = false;\n\n      var stderrRing = utils.linesRing(maxLines);\n      var stderrClosed = false;\n\n      // Spawn process\n      var ffmpegProc = spawn(command, args, options);\n\n      if (ffmpegProc.stderr) {\n        ffmpegProc.stderr.setEncoding('utf8');\n      }\n\n      ffmpegProc.on('error', function(err) {\n        endCB(err);\n      });\n\n      // Ensure we wait for captured streams to end before calling endCB\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && (stdoutClosed || !options.captureStdout) && stderrClosed) {\n          endCB(exitError, stdoutRing, stderrRing);\n        }\n      }\n\n      // Handle process exit\n      var processExited = false;\n      ffmpegProc.on('exit', function(code, signal) {\n        processExited = true;\n\n        if (signal) {\n          handleExit(new Error('ffmpeg was killed with signal ' + signal));\n        } else if (code) {\n          handleExit(new Error('ffmpeg exited with code ' + code));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Capture stdout if specified\n      if (options.captureStdout) {\n        ffmpegProc.stdout.on('data', function(data) {\n          stdoutRing.append(data);\n        });\n\n        ffmpegProc.stdout.on('close', function() {\n          stdoutRing.close();\n          stdoutClosed = true;\n          handleExit();\n        });\n      }\n\n      // Capture stderr if specified\n      ffmpegProc.stderr.on('data', function(data) {\n        stderrRing.append(data);\n      });\n\n      ffmpegProc.stderr.on('close', function() {\n        stderrRing.close();\n        stderrClosed = true;\n        handleExit();\n      });\n\n      // Call process callback\n      processCB(ffmpegProc, stdoutRing, stderrRing);\n    });\n  };\n\n\n  /**\n   * Build the argument list for an ffmpeg command\n   *\n   * @method FfmpegCommand#_getArguments\n   * @return argument list\n   * @private\n   */\n  proto._getArguments = function() {\n    var complexFilters = this._complexFilters.get();\n\n    var fileOutput = this._outputs.some(function(output) {\n      return output.isFile;\n    });\n\n    return [].concat(\n        // Inputs and input options\n        this._inputs.reduce(function(args, input) {\n          var source = (typeof input.source === 'string') ? input.source : 'pipe:0';\n\n          // For each input, add input options, then '-i <source>'\n          return args.concat(\n            input.options.get(),\n            ['-i', source]\n          );\n        }, []),\n\n        // Global options\n        this._global.get(),\n\n        // Overwrite if we have file outputs\n        fileOutput ? ['-y'] : [],\n\n        // Complex filters\n        complexFilters,\n\n        // Outputs, filters and output options\n        this._outputs.reduce(function(args, output) {\n          var sizeFilters = utils.makeFilterStrings(output.sizeFilters.get());\n          var audioFilters = output.audioFilters.get();\n          var videoFilters = output.videoFilters.get().concat(sizeFilters);\n          var outputArg;\n\n          if (!output.target) {\n            outputArg = [];\n          } else if (typeof output.target === 'string') {\n            outputArg = [output.target];\n          } else {\n            outputArg = ['pipe:1'];\n          }\n\n          return args.concat(\n            output.audio.get(),\n            audioFilters.length ? ['-filter:a', audioFilters.join(',')] : [],\n            output.video.get(),\n            videoFilters.length ? ['-filter:v', videoFilters.join(',')] : [],\n            output.options.get(),\n            outputArg\n          );\n        }, [])\n      );\n  };\n\n\n  /**\n   * Prepare execution of an ffmpeg command\n   *\n   * Checks prerequisites for the execution of the command (codec/format availability, flvtool...),\n   * then builds the argument list for ffmpeg and pass them to 'callback'.\n   *\n   * @method FfmpegCommand#_prepare\n   * @param {Function} callback callback with signature (err, args)\n   * @param {Boolean} [readMetadata=false] read metadata before processing\n   * @private\n   */\n  proto._prepare = function(callback, readMetadata) {\n    var self = this;\n\n    async.waterfall([\n      // Check codecs and formats\n      function(cb) {\n        self._checkCapabilities(cb);\n      },\n\n      // Read metadata if required\n      function(cb) {\n        if (!readMetadata) {\n          return cb();\n        }\n\n        self.ffprobe(0, function(err, data) {\n          if (!err) {\n            self._ffprobeData = data;\n          }\n\n          cb();\n        });\n      },\n\n      // Check for flvtool2/flvmeta if necessary\n      function(cb) {\n        var flvmeta = self._outputs.some(function(output) {\n          // Remove flvmeta flag on non-file output\n          if (output.flags.flvmeta && !output.isFile) {\n            self.logger.warn('Updating flv metadata is only supported for files');\n            output.flags.flvmeta = false;\n          }\n\n          return output.flags.flvmeta;\n        });\n\n        if (flvmeta) {\n          self._getFlvtoolPath(function(err) {\n            cb(err);\n          });\n        } else {\n          cb();\n        }\n      },\n\n      // Build argument list\n      function(cb) {\n        var args;\n        try {\n          args = self._getArguments();\n        } catch(e) {\n          return cb(e);\n        }\n\n        cb(null, args);\n      },\n\n      // Add \"-strict experimental\" option where needed\n      function(args, cb) {\n        self.availableEncoders(function(err, encoders) {\n          for (var i = 0; i < args.length; i++) {\n            if (args[i] === '-acodec' || args[i] === '-vcodec') {\n              i++;\n\n              if ((args[i] in encoders) && encoders[args[i]].experimental) {\n                args.splice(i + 1, 0, '-strict', 'experimental');\n                i += 2;\n              }\n            }\n          }\n\n          cb(null, args);\n        });\n      }\n    ], callback);\n\n    if (!readMetadata) {\n      // Read metadata as soon as 'progress' listeners are added\n\n      if (this.listeners('progress').length > 0) {\n        // Read metadata in parallel\n        runFfprobe(this);\n      } else {\n        // Read metadata as soon as the first 'progress' listener is added\n        this.once('newListener', function(event) {\n          if (event === 'progress') {\n            runFfprobe(this);\n          }\n        });\n      }\n    }\n  };\n\n\n  /**\n   * Run ffmpeg command\n   *\n   * @method FfmpegCommand#run\n   * @category Processing\n   * @aliases exec,execute\n   */\n  proto.exec =\n  proto.execute =\n  proto.run = function() {\n    var self = this;\n\n    // Check if at least one output is present\n    var outputPresent = this._outputs.some(function(output) {\n      return 'target' in output;\n    });\n\n    if (!outputPresent) {\n      throw new Error('No output specified');\n    }\n\n    // Get output stream if any\n    var outputStream = this._outputs.filter(function(output) {\n      return typeof output.target !== 'string';\n    })[0];\n\n    // Get input stream if any\n    var inputStream = this._inputs.filter(function(input) {\n      return typeof input.source !== 'string';\n    })[0];\n\n    // Ensure we send 'end' or 'error' only once\n    var ended = false;\n    function emitEnd(err, stdout, stderr) {\n      if (!ended) {\n        ended = true;\n\n        if (err) {\n          self.emit('error', err, stdout, stderr);\n        } else {\n          self.emit('end', stdout, stderr);\n        }\n      }\n    }\n\n    self._prepare(function(err, args) {\n      if (err) {\n        return emitEnd(err);\n      }\n\n      // Run ffmpeg\n      self._spawnFfmpeg(\n        args,\n        {\n          captureStdout: !outputStream,\n          niceness: self.options.niceness,\n          cwd: self.options.cwd\n        },\n\n        function processCB(ffmpegProc, stdoutRing, stderrRing) {\n          self.ffmpegProc = ffmpegProc;\n          self.emit('start', 'ffmpeg ' + args.join(' '));\n\n          // Pipe input stream if any\n          if (inputStream) {\n            inputStream.source.on('error', function(err) {\n              var reportingErr = new Error('Input stream error: ' + err.message);\n              reportingErr.inputStreamError = err;\n              emitEnd(reportingErr);\n              ffmpegProc.kill();\n            });\n\n            inputStream.source.resume();\n            inputStream.source.pipe(ffmpegProc.stdin);\n\n            // Set stdin error handler on ffmpeg (prevents nodejs catching the error, but\n            // ffmpeg will fail anyway, so no need to actually handle anything)\n            ffmpegProc.stdin.on('error', function() {});\n          }\n\n          // Setup timeout if requested\n          var processTimer;\n          if (self.options.timeout) {\n            processTimer = setTimeout(function() {\n              var msg = 'process ran into a timeout (' + self.options.timeout + 's)';\n\n              emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());\n              ffmpegProc.kill();\n            }, self.options.timeout * 1000);\n          }\n\n\n          if (outputStream) {\n            // Pipe ffmpeg stdout to output stream\n            ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);\n\n            // Handle output stream events\n            outputStream.target.on('close', function() {\n              self.logger.debug('Output stream closed, scheduling kill for ffmpeg process');\n\n              // Don't kill process yet, to give a chance to ffmpeg to\n              // terminate successfully first  This is necessary because\n              // under load, the process 'exit' event sometimes happens\n              // after the output stream 'close' event.\n              setTimeout(function() {\n                emitEnd(new Error('Output stream closed'));\n                ffmpegProc.kill();\n              }, 20);\n            });\n\n            outputStream.target.on('error', function(err) {\n              self.logger.debug('Output stream error, killing ffmpeg process');\n              var reportingErr = new Error('Output stream error: ' + err.message);\n              reportingErr.outputStreamError = err;\n              emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());\n              ffmpegProc.kill('SIGKILL');\n            });\n          }\n\n          // Setup stderr handling\n          if (stderrRing) {\n\n            // 'stderr' event\n            if (self.listeners('stderr').length) {\n              stderrRing.callback(function(line) {\n                self.emit('stderr', line);\n              });\n            }\n\n            // 'codecData' event\n            if (self.listeners('codecData').length) {\n              var codecDataSent = false;\n              var codecObject = {};\n\n              stderrRing.callback(function(line) {\n                if (!codecDataSent)\n                  codecDataSent = utils.extractCodecData(self, line, codecObject);\n              });\n            }\n\n            // 'progress' event\n            if (self.listeners('progress').length) {\n              stderrRing.callback(function(line) {\n                utils.extractProgress(self, line);\n              });\n            }\n          }\n        },\n\n        function endCB(err, stdoutRing, stderrRing) {\n          delete self.ffmpegProc;\n\n          if (err) {\n            if (err.message.match(/ffmpeg exited with code/)) {\n              // Add ffmpeg error message\n              err.message += ': ' + utils.extractError(stderrRing.get());\n            }\n\n            emitEnd(err, stdoutRing.get(), stderrRing.get());\n          } else {\n            // Find out which outputs need flv metadata\n            var flvmeta = self._outputs.filter(function(output) {\n              return output.flags.flvmeta;\n            });\n\n            if (flvmeta.length) {\n              self._getFlvtoolPath(function(err, flvtool) {\n                if (err) {\n                  return emitEnd(err);\n                }\n\n                async.each(\n                  flvmeta,\n                  function(output, cb) {\n                    spawn(flvtool, ['-U', output.target])\n                      .on('error', function(err) {\n                        cb(new Error('Error running ' + flvtool + ' on ' + output.target + ': ' + err.message));\n                      })\n                      .on('exit', function(code, signal) {\n                        if (code !== 0 || signal) {\n                          cb(\n                            new Error(flvtool + ' ' +\n                              (signal ? 'received signal ' + signal\n                                      : 'exited with code ' + code)) +\n                              ' when running on ' + output.target\n                          );\n                        } else {\n                          cb();\n                        }\n                      });\n                  },\n                  function(err) {\n                    if (err) {\n                      emitEnd(err);\n                    } else {\n                      emitEnd(null, stdoutRing.get(), stderrRing.get());\n                    }\n                  }\n                );\n              });\n            } else {\n              emitEnd(null, stdoutRing.get(), stderrRing.get());\n            }\n          }\n        }\n      );\n    });\n  };\n\n\n  /**\n   * Renice current and/or future ffmpeg processes\n   *\n   * Ignored on Windows platforms.\n   *\n   * @method FfmpegCommand#renice\n   * @category Processing\n   *\n   * @param {Number} [niceness=0] niceness value between -20 (highest priority) and 20 (lowest priority)\n   * @return FfmpegCommand\n   */\n  proto.renice = function(niceness) {\n    if (!utils.isWindows) {\n      niceness = niceness || 0;\n\n      if (niceness < -20 || niceness > 20) {\n        this.logger.warn('Invalid niceness value: ' + niceness + ', must be between -20 and 20');\n      }\n\n      niceness = Math.min(20, Math.max(-20, niceness));\n      this.options.niceness = niceness;\n\n      if (this.ffmpegProc) {\n        var logger = this.logger;\n        var pid = this.ffmpegProc.pid;\n        var renice = spawn('renice', [niceness, '-p', pid]);\n\n        renice.on('error', function(err) {\n          logger.warn('could not renice process ' + pid + ': ' + err.message);\n        });\n\n        renice.on('exit', function(code, signal) {\n          if (signal) {\n            logger.warn('could not renice process ' + pid + ': renice was killed by signal ' + signal);\n          } else if (code) {\n            logger.warn('could not renice process ' + pid + ': renice exited with ' + code);\n          } else {\n            logger.info('successfully reniced process ' + pid + ' to ' + niceness + ' niceness');\n          }\n        });\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Kill current ffmpeg process, if any\n   *\n   * @method FfmpegCommand#kill\n   * @category Processing\n   *\n   * @param {String} [signal=SIGKILL] signal name\n   * @return FfmpegCommand\n   */\n  proto.kill = function(signal) {\n    if (!this.ffmpegProc) {\n      this.logger.warn('No running ffmpeg process, cannot send signal');\n    } else {\n      this.ffmpegProc.kill(signal || 'SIGKILL');\n    }\n\n    return this;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}