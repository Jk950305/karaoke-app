{"ast":null,"code":"var through = require('through2');\n\nvar speedometer = require('speedometer');\n\nmodule.exports = function (options, onprogress) {\n  if (typeof options === 'function') return module.exports(null, options);\n  options = options || {};\n  var length = options.length || 0;\n  var time = options.time || 0;\n  var drain = options.drain || false;\n  var transferred = options.transferred || 0;\n  var nextUpdate = Date.now() + time;\n  var delta = 0;\n  var speed = speedometer(options.speed || 5000);\n  var startTime = Date.now();\n  var update = {\n    percentage: 0,\n    transferred: transferred,\n    length: length,\n    remaining: length,\n    eta: 0,\n    runtime: 0\n  };\n\n  var emit = function (ended) {\n    update.delta = delta;\n    update.percentage = ended ? 100 : length ? transferred / length * 100 : 0;\n    update.speed = speed(delta);\n    update.eta = Math.round(update.remaining / update.speed);\n    update.runtime = parseInt((Date.now() - startTime) / 1000);\n    nextUpdate = Date.now() + time;\n    delta = 0;\n    tr.emit('progress', update);\n  };\n\n  var write = function (chunk, enc, callback) {\n    var len = options.objectMode ? 1 : chunk.length;\n    transferred += len;\n    delta += len;\n    update.transferred = transferred;\n    update.remaining = length >= transferred ? length - transferred : 0;\n    if (Date.now() >= nextUpdate) emit(false);\n    callback(null, chunk);\n  };\n\n  var end = function (callback) {\n    emit(true);\n    callback();\n  };\n\n  var tr = through(options.objectMode ? {\n    objectMode: true,\n    highWaterMark: 16\n  } : {}, write, end);\n\n  var onlength = function (newLength) {\n    length = newLength;\n    update.length = length;\n    update.remaining = length - update.transferred;\n    tr.emit('length', length);\n  }; // Expose `onlength()` handler as `setLength()` to support custom use cases where length\n  // is not known until after a few chunks have already been pumped, or is\n  // calculated on the fly.\n\n\n  tr.setLength = onlength;\n  tr.on('pipe', function (stream) {\n    if (typeof length === 'number') return; // Support http module\n\n    if (stream.readable && !stream.writable && stream.headers) {\n      return onlength(parseInt(stream.headers['content-length'] || 0));\n    } // Support streams with a length property\n\n\n    if (typeof stream.length === 'number') {\n      return onlength(stream.length);\n    } // Support request module\n\n\n    stream.on('response', function (res) {\n      if (!res || !res.headers) return;\n      if (res.headers['content-encoding'] === 'gzip') return;\n\n      if (res.headers['content-length']) {\n        return onlength(parseInt(res.headers['content-length']));\n      }\n    });\n  });\n  if (drain) tr.resume();\n  if (onprogress) tr.on('progress', onprogress);\n\n  tr.progress = function () {\n    update.speed = speed(0);\n    update.eta = Math.round(update.remaining / update.speed);\n    return update;\n  };\n\n  return tr;\n};","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/progress-stream/index.js"],"names":["through","require","speedometer","module","exports","options","onprogress","length","time","drain","transferred","nextUpdate","Date","now","delta","speed","startTime","update","percentage","remaining","eta","runtime","emit","ended","Math","round","parseInt","tr","write","chunk","enc","callback","len","objectMode","end","highWaterMark","onlength","newLength","setLength","on","stream","readable","writable","headers","res","resume","progress"],"mappings":"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","sourcesContent":["var through = require('through2');\nvar speedometer = require('speedometer');\n\nmodule.exports = function(options, onprogress) {\n\tif (typeof options === 'function') return module.exports(null, options);\n\toptions = options || {};\n\n\tvar length = options.length || 0;\n\tvar time = options.time || 0;\n\tvar drain = options.drain || false;\n\tvar transferred = options.transferred || 0;\n\tvar nextUpdate = Date.now()+time;\n\tvar delta = 0;\n\tvar speed = speedometer(options.speed || 5000);\n\tvar startTime = Date.now();\n\n\tvar update = {\n\t\tpercentage: 0,\n\t\ttransferred: transferred,\n\t\tlength: length,\n\t\tremaining: length,\n\t\teta: 0,\n\t\truntime: 0\n\t};\n\n\tvar emit = function(ended) {\n\t\tupdate.delta = delta;\n\t\tupdate.percentage = ended ? 100 : (length ? transferred/length*100 : 0);\n\t\tupdate.speed = speed(delta);\n\t\tupdate.eta = Math.round(update.remaining / update.speed);\n\t\tupdate.runtime = parseInt((Date.now() - startTime)/1000);\n\t\tnextUpdate = Date.now()+time;\n\n\t\tdelta = 0;\n\n\t\ttr.emit('progress', update);\n\t};\n\tvar write = function(chunk, enc, callback) {\n\t\tvar len = options.objectMode ? 1 : chunk.length;\n\t\ttransferred += len;\n\t\tdelta += len;\n\t\tupdate.transferred = transferred;\n\t\tupdate.remaining = length >= transferred ? length - transferred : 0;\n\n\t\tif (Date.now() >= nextUpdate) emit(false);\n\t\tcallback(null, chunk);\n\t};\n\tvar end = function(callback) {\n\t\temit(true);\n\t\tcallback();\n\t};\n\n\tvar tr = through(options.objectMode ? {objectMode:true, highWaterMark:16} : {}, write, end);\n\tvar onlength = function(newLength) {\n\t\tlength = newLength;\n\t\tupdate.length = length;\n\t\tupdate.remaining = length - update.transferred;\n\t\ttr.emit('length', length);\n\t};\n\t\n\t// Expose `onlength()` handler as `setLength()` to support custom use cases where length\n\t// is not known until after a few chunks have already been pumped, or is\n\t// calculated on the fly.\n\ttr.setLength = onlength;\n\t\n\ttr.on('pipe', function(stream) {\n\t\tif (typeof length === 'number') return;\n\t\t// Support http module\n\t\tif (stream.readable && !stream.writable && stream.headers) {\n\t\t\treturn onlength(parseInt(stream.headers['content-length'] || 0));\n\t\t}\n\n\t\t// Support streams with a length property\n\t\tif (typeof stream.length === 'number') {\n\t\t\treturn onlength(stream.length);\n\t\t}\n\n\t\t// Support request module\n\t\tstream.on('response', function(res) {\n\t\t\tif (!res || !res.headers) return;\n\t\t\tif (res.headers['content-encoding'] === 'gzip') return;\n\t\t\tif (res.headers['content-length']) {\n\t\t\t\treturn onlength(parseInt(res.headers['content-length']));\n\t\t\t}\n\t\t});\n\t});\n\n\tif (drain) tr.resume();\n\tif (onprogress) tr.on('progress', onprogress);\n\n\ttr.progress = function() {\n\t\tupdate.speed = speed(0);\n\t\tupdate.eta = Math.round(update.remaining / update.speed);\n\n\t\treturn update;\n\t};\n\treturn tr;\n};\n"]},"metadata":{},"sourceType":"script"}