{"ast":null,"code":"/*jshint node:true*/\n'use strict';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar async = require('async');\n\nvar utils = require('./utils');\n/*\n *! Capability helpers\n */\n\n\nvar avCodecRegexp = /^\\s*([D ])([E ])([VAS])([S ])([D ])([T ]) ([^ ]+) +(.*)$/;\nvar ffCodecRegexp = /^\\s*([D\\.])([E\\.])([VAS])([I\\.])([L\\.])([S\\.]) ([^ ]+) +(.*)$/;\nvar ffEncodersRegexp = /\\(encoders:([^\\)]+)\\)/;\nvar ffDecodersRegexp = /\\(decoders:([^\\)]+)\\)/;\nvar encodersRegexp = /^\\s*([VAS\\.])([F\\.])([S\\.])([X\\.])([B\\.])([D\\.]) ([^ ]+) +(.*)$/;\nvar formatRegexp = /^\\s*([D ])([E ]) ([^ ]+) +(.*)$/;\nvar lineBreakRegexp = /\\r\\n|\\r|\\n/;\nvar filterRegexp = /^(?: [T\\.][S\\.][C\\.] )?([^ ]+) +(AA?|VV?|\\|)->(AA?|VV?|\\|) +(.*)$/;\nvar cache = {};\n\nmodule.exports = function (proto) {\n  /**\n   * Manually define the ffmpeg binary full path.\n   *\n   * @method FfmpegCommand#setFfmpegPath\n   *\n   * @param {String} ffmpegPath The full path to the ffmpeg binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfmpegPath = function (ffmpegPath) {\n    cache.ffmpegPath = ffmpegPath;\n    return this;\n  };\n  /**\n   * Manually define the ffprobe binary full path.\n   *\n   * @method FfmpegCommand#setFfprobePath\n   *\n   * @param {String} ffprobePath The full path to the ffprobe binary.\n   * @return FfmpegCommand\n   */\n\n\n  proto.setFfprobePath = function (ffprobePath) {\n    cache.ffprobePath = ffprobePath;\n    return this;\n  };\n  /**\n   * Manually define the flvtool2/flvmeta binary full path.\n   *\n   * @method FfmpegCommand#setFlvtoolPath\n   *\n   * @param {String} flvtool The full path to the flvtool2 or flvmeta binary.\n   * @return FfmpegCommand\n   */\n\n\n  proto.setFlvtoolPath = function (flvtool) {\n    cache.flvtoolPath = flvtool;\n    return this;\n  };\n  /**\n   * Forget executable paths\n   *\n   * (only used for testing purposes)\n   *\n   * @method FfmpegCommand#_forgetPaths\n   * @private\n   */\n\n\n  proto._forgetPaths = function () {\n    delete cache.ffmpegPath;\n    delete cache.ffprobePath;\n    delete cache.flvtoolPath;\n  };\n  /**\n   * Check for ffmpeg availability\n   *\n   * If the FFMPEG_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffmpeg in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFfmpegPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n\n\n  proto._getFfmpegPath = function (callback) {\n    if ('ffmpegPath' in cache) {\n      return callback(null, cache.ffmpegPath);\n    }\n\n    async.waterfall([// Try FFMPEG_PATH\n    function (cb) {\n      if (process.env.FFMPEG_PATH) {\n        fs.exists(process.env.FFMPEG_PATH, function (exists) {\n          if (exists) {\n            cb(null, process.env.FFMPEG_PATH);\n          } else {\n            cb(null, '');\n          }\n        });\n      } else {\n        cb(null, '');\n      }\n    }, // Search in the PATH\n    function (ffmpeg, cb) {\n      if (ffmpeg.length) {\n        return cb(null, ffmpeg);\n      }\n\n      utils.which('ffmpeg', function (err, ffmpeg) {\n        cb(err, ffmpeg);\n      });\n    }], function (err, ffmpeg) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffmpegPath = ffmpeg || '');\n      }\n    });\n  };\n  /**\n   * Check for ffprobe availability\n   *\n   * If the FFPROBE_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffprobe in the PATH instead.\n   * If this still fails, try to find ffprobe in the same directory as ffmpeg.\n   *\n   * @method FfmpegCommand#_getFfprobePath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n\n\n  proto._getFfprobePath = function (callback) {\n    var self = this;\n\n    if ('ffprobePath' in cache) {\n      return callback(null, cache.ffprobePath);\n    }\n\n    async.waterfall([// Try FFPROBE_PATH\n    function (cb) {\n      if (process.env.FFPROBE_PATH) {\n        fs.exists(process.env.FFPROBE_PATH, function (exists) {\n          cb(null, exists ? process.env.FFPROBE_PATH : '');\n        });\n      } else {\n        cb(null, '');\n      }\n    }, // Search in the PATH\n    function (ffprobe, cb) {\n      if (ffprobe.length) {\n        return cb(null, ffprobe);\n      }\n\n      utils.which('ffprobe', function (err, ffprobe) {\n        cb(err, ffprobe);\n      });\n    }, // Search in the same directory as ffmpeg\n    function (ffprobe, cb) {\n      if (ffprobe.length) {\n        return cb(null, ffprobe);\n      }\n\n      self._getFfmpegPath(function (err, ffmpeg) {\n        if (err) {\n          cb(err);\n        } else if (ffmpeg.length) {\n          var name = utils.isWindows ? 'ffprobe.exe' : 'ffprobe';\n          var ffprobe = path.join(path.dirname(ffmpeg), name);\n          fs.exists(ffprobe, function (exists) {\n            cb(null, exists ? ffprobe : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      });\n    }], function (err, ffprobe) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffprobePath = ffprobe || '');\n      }\n    });\n  };\n  /**\n   * Check for flvtool2/flvmeta availability\n   *\n   * If the FLVTOOL2_PATH or FLVMETA_PATH environment variable are set, try to use them.\n   * If both are either unset or incorrect, try to find flvtool2 or flvmeta in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFlvtoolPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n\n\n  proto._getFlvtoolPath = function (callback) {\n    if ('flvtoolPath' in cache) {\n      return callback(null, cache.flvtoolPath);\n    }\n\n    async.waterfall([// Try FLVMETA_PATH\n    function (cb) {\n      if (process.env.FLVMETA_PATH) {\n        fs.exists(process.env.FLVMETA_PATH, function (exists) {\n          cb(null, exists ? process.env.FLVMETA_PATH : '');\n        });\n      } else {\n        cb(null, '');\n      }\n    }, // Try FLVTOOL2_PATH\n    function (flvtool, cb) {\n      if (flvtool.length) {\n        return cb(null, flvtool);\n      }\n\n      if (process.env.FLVTOOL2_PATH) {\n        fs.exists(process.env.FLVTOOL2_PATH, function (exists) {\n          cb(null, exists ? process.env.FLVTOOL2_PATH : '');\n        });\n      } else {\n        cb(null, '');\n      }\n    }, // Search for flvmeta in the PATH\n    function (flvtool, cb) {\n      if (flvtool.length) {\n        return cb(null, flvtool);\n      }\n\n      utils.which('flvmeta', function (err, flvmeta) {\n        cb(err, flvmeta);\n      });\n    }, // Search for flvtool2 in the PATH\n    function (flvtool, cb) {\n      if (flvtool.length) {\n        return cb(null, flvtool);\n      }\n\n      utils.which('flvtool2', function (err, flvtool2) {\n        cb(err, flvtool2);\n      });\n    }], function (err, flvtool) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.flvtoolPath = flvtool || '');\n      }\n    });\n  };\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFilters}.\n   *\n   * @callback FfmpegCommand~filterCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} filters filter object with filter names as keys and the following\n   *   properties for each filter:\n   * @param {String} filters.description filter description\n   * @param {String} filters.input input type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleInputs whether the filter supports multiple inputs\n   * @param {String} filters.output output type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleOutputs whether the filter supports multiple outputs\n   */\n\n  /**\n   * Query ffmpeg for available filters\n   *\n   * @method FfmpegCommand#availableFilters\n   * @category Capabilities\n   * @aliases getAvailableFilters\n   *\n   * @param {FfmpegCommand~filterCallback} callback callback function\n   */\n\n\n  proto.availableFilters = proto.getAvailableFilters = function (callback) {\n    if ('filters' in cache) {\n      return callback(null, cache.filters);\n    }\n\n    this._spawnFfmpeg(['-filters'], {\n      captureStdout: true,\n      stdoutLines: 0\n    }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split('\\n');\n      var data = {};\n      var types = {\n        A: 'audio',\n        V: 'video',\n        '|': 'none'\n      };\n      lines.forEach(function (line) {\n        var match = line.match(filterRegexp);\n\n        if (match) {\n          data[match[1]] = {\n            description: match[4],\n            input: types[match[2].charAt(0)],\n            multipleInputs: match[2].length > 1,\n            output: types[match[3].charAt(0)],\n            multipleOutputs: match[3].length > 1\n          };\n        }\n      });\n      callback(null, cache.filters = data);\n    });\n  };\n  /**\n   * A callback passed to {@link FfmpegCommand#availableCodecs}.\n   *\n   * @callback FfmpegCommand~codecCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} codecs codec object with codec names as keys and the following\n   *   properties for each codec (more properties may be available depending on the\n   *   ffmpeg version used):\n   * @param {String} codecs.description codec description\n   * @param {Boolean} codecs.canDecode whether the codec is able to decode streams\n   * @param {Boolean} codecs.canEncode whether the codec is able to encode streams\n   */\n\n  /**\n   * Query ffmpeg for available codecs\n   *\n   * @method FfmpegCommand#availableCodecs\n   * @category Capabilities\n   * @aliases getAvailableCodecs\n   *\n   * @param {FfmpegCommand~codecCallback} callback callback function\n   */\n\n\n  proto.availableCodecs = proto.getAvailableCodecs = function (callback) {\n    if ('codecs' in cache) {\n      return callback(null, cache.codecs);\n    }\n\n    this._spawnFfmpeg(['-codecs'], {\n      captureStdout: true,\n      stdoutLines: 0\n    }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n      lines.forEach(function (line) {\n        var match = line.match(avCodecRegexp);\n\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: {\n              'V': 'video',\n              'A': 'audio',\n              'S': 'subtitle'\n            }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            drawHorizBand: match[4] === 'S',\n            directRendering: match[5] === 'D',\n            weirdFrameTruncation: match[6] === 'T'\n          };\n        }\n\n        match = line.match(ffCodecRegexp);\n\n        if (match && match[7] !== '=') {\n          var codecData = data[match[7]] = {\n            type: {\n              'V': 'video',\n              'A': 'audio',\n              'S': 'subtitle'\n            }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            intraFrameOnly: match[4] === 'I',\n            isLossy: match[5] === 'L',\n            isLossless: match[6] === 'S'\n          };\n          var encoders = codecData.description.match(ffEncodersRegexp);\n          encoders = encoders ? encoders[1].trim().split(' ') : [];\n          var decoders = codecData.description.match(ffDecodersRegexp);\n          decoders = decoders ? decoders[1].trim().split(' ') : [];\n\n          if (encoders.length || decoders.length) {\n            var coderData = {};\n            utils.copy(codecData, coderData);\n            delete coderData.canEncode;\n            delete coderData.canDecode;\n            encoders.forEach(function (name) {\n              data[name] = {};\n              utils.copy(coderData, data[name]);\n              data[name].canEncode = true;\n            });\n            decoders.forEach(function (name) {\n              if (name in data) {\n                data[name].canDecode = true;\n              } else {\n                data[name] = {};\n                utils.copy(coderData, data[name]);\n                data[name].canDecode = true;\n              }\n            });\n          }\n        }\n      });\n      callback(null, cache.codecs = data);\n    });\n  };\n  /**\n   * A callback passed to {@link FfmpegCommand#availableEncoders}.\n   *\n   * @callback FfmpegCommand~encodersCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} encoders encoders object with encoder names as keys and the following\n   *   properties for each encoder:\n   * @param {String} encoders.description codec description\n   * @param {Boolean} encoders.type \"audio\", \"video\" or \"subtitle\"\n   * @param {Boolean} encoders.frameMT whether the encoder is able to do frame-level multithreading\n   * @param {Boolean} encoders.sliceMT whether the encoder is able to do slice-level multithreading\n   * @param {Boolean} encoders.experimental whether the encoder is experimental\n   * @param {Boolean} encoders.drawHorizBand whether the encoder supports draw_horiz_band\n   * @param {Boolean} encoders.directRendering whether the encoder supports direct encoding method 1\n   */\n\n  /**\n   * Query ffmpeg for available encoders\n   *\n   * @method FfmpegCommand#availableEncoders\n   * @category Capabilities\n   * @aliases getAvailableEncoders\n   *\n   * @param {FfmpegCommand~encodersCallback} callback callback function\n   */\n\n\n  proto.availableEncoders = proto.getAvailableEncoders = function (callback) {\n    if ('encoders' in cache) {\n      return callback(null, cache.encoders);\n    }\n\n    this._spawnFfmpeg(['-encoders'], {\n      captureStdout: true,\n      stdoutLines: 0\n    }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n      lines.forEach(function (line) {\n        var match = line.match(encodersRegexp);\n\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: {\n              'V': 'video',\n              'A': 'audio',\n              'S': 'subtitle'\n            }[match[1]],\n            description: match[8],\n            frameMT: match[2] === 'F',\n            sliceMT: match[3] === 'S',\n            experimental: match[4] === 'X',\n            drawHorizBand: match[5] === 'B',\n            directRendering: match[6] === 'D'\n          };\n        }\n      });\n      callback(null, cache.encoders = data);\n    });\n  };\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFormats}.\n   *\n   * @callback FfmpegCommand~formatCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} formats format object with format names as keys and the following\n   *   properties for each format:\n   * @param {String} formats.description format description\n   * @param {Boolean} formats.canDemux whether the format is able to demux streams from an input file\n   * @param {Boolean} formats.canMux whether the format is able to mux streams into an output file\n   */\n\n  /**\n   * Query ffmpeg for available formats\n   *\n   * @method FfmpegCommand#availableFormats\n   * @category Capabilities\n   * @aliases getAvailableFormats\n   *\n   * @param {FfmpegCommand~formatCallback} callback callback function\n   */\n\n\n  proto.availableFormats = proto.getAvailableFormats = function (callback) {\n    if ('formats' in cache) {\n      return callback(null, cache.formats);\n    } // Run ffmpeg -formats\n\n\n    this._spawnFfmpeg(['-formats'], {\n      captureStdout: true,\n      stdoutLines: 0\n    }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      } // Parse output\n\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n      lines.forEach(function (line) {\n        var match = line.match(formatRegexp);\n\n        if (match) {\n          match[3].split(',').forEach(function (format) {\n            if (!(format in data)) {\n              data[format] = {\n                description: match[4],\n                canDemux: false,\n                canMux: false\n              };\n            }\n\n            if (match[1] === 'D') {\n              data[format].canDemux = true;\n            }\n\n            if (match[2] === 'E') {\n              data[format].canMux = true;\n            }\n          });\n        }\n      });\n      callback(null, cache.formats = data);\n    });\n  };\n  /**\n   * Check capabilities before executing a command\n   *\n   * Checks whether all used codecs and formats are indeed available\n   *\n   * @method FfmpegCommand#_checkCapabilities\n   * @param {Function} callback callback with signature (err)\n   * @private\n   */\n\n\n  proto._checkCapabilities = function (callback) {\n    var self = this;\n    async.waterfall([// Get available formats\n    function (cb) {\n      self.availableFormats(cb);\n    }, // Check whether specified formats are available\n    function (formats, cb) {\n      var unavailable; // Output format(s)\n\n      unavailable = self._outputs.reduce(function (fmts, output) {\n        var format = output.options.find('-f', 1);\n\n        if (format) {\n          if (!(format[0] in formats) || !formats[format[0]].canMux) {\n            fmts.push(format);\n          }\n        }\n\n        return fmts;\n      }, []);\n\n      if (unavailable.length === 1) {\n        return cb(new Error('Output format ' + unavailable[0] + ' is not available'));\n      } else if (unavailable.length > 1) {\n        return cb(new Error('Output formats ' + unavailable.join(', ') + ' are not available'));\n      } // Input format(s)\n\n\n      unavailable = self._inputs.reduce(function (fmts, input) {\n        var format = input.options.find('-f', 1);\n\n        if (format) {\n          if (!(format[0] in formats) || !formats[format[0]].canDemux) {\n            fmts.push(format[0]);\n          }\n        }\n\n        return fmts;\n      }, []);\n\n      if (unavailable.length === 1) {\n        return cb(new Error('Input format ' + unavailable[0] + ' is not available'));\n      } else if (unavailable.length > 1) {\n        return cb(new Error('Input formats ' + unavailable.join(', ') + ' are not available'));\n      }\n\n      cb();\n    }, // Get available codecs\n    function (cb) {\n      self.availableEncoders(cb);\n    }, // Check whether specified codecs are available and add strict experimental options if needed\n    function (encoders, cb) {\n      var unavailable; // Audio codec(s)\n\n      unavailable = self._outputs.reduce(function (cdcs, output) {\n        var acodec = output.audio.find('-acodec', 1);\n\n        if (acodec && acodec[0] !== 'copy') {\n          if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== 'audio') {\n            cdcs.push(acodec[0]);\n          }\n        }\n\n        return cdcs;\n      }, []);\n\n      if (unavailable.length === 1) {\n        return cb(new Error('Audio codec ' + unavailable[0] + ' is not available'));\n      } else if (unavailable.length > 1) {\n        return cb(new Error('Audio codecs ' + unavailable.join(', ') + ' are not available'));\n      } // Video codec(s)\n\n\n      unavailable = self._outputs.reduce(function (cdcs, output) {\n        var vcodec = output.video.find('-vcodec', 1);\n\n        if (vcodec && vcodec[0] !== 'copy') {\n          if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== 'video') {\n            cdcs.push(vcodec[0]);\n          }\n        }\n\n        return cdcs;\n      }, []);\n\n      if (unavailable.length === 1) {\n        return cb(new Error('Video codec ' + unavailable[0] + ' is not available'));\n      } else if (unavailable.length > 1) {\n        return cb(new Error('Video codecs ' + unavailable.join(', ') + ' are not available'));\n      }\n\n      cb();\n    }], callback);\n  };\n};","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/fluent-ffmpeg/lib/capabilities.js"],"names":["fs","require","path","async","utils","avCodecRegexp","ffCodecRegexp","ffEncodersRegexp","ffDecodersRegexp","encodersRegexp","formatRegexp","lineBreakRegexp","filterRegexp","cache","module","exports","proto","setFfmpegPath","ffmpegPath","setFfprobePath","ffprobePath","setFlvtoolPath","flvtool","flvtoolPath","_forgetPaths","_getFfmpegPath","callback","waterfall","cb","process","env","FFMPEG_PATH","exists","ffmpeg","length","which","err","_getFfprobePath","self","FFPROBE_PATH","ffprobe","name","isWindows","join","dirname","_getFlvtoolPath","FLVMETA_PATH","FLVTOOL2_PATH","flvmeta","flvtool2","availableFilters","getAvailableFilters","filters","_spawnFfmpeg","captureStdout","stdoutLines","stdoutRing","stdout","get","lines","split","data","types","A","V","forEach","line","match","description","input","charAt","multipleInputs","output","multipleOutputs","availableCodecs","getAvailableCodecs","codecs","type","canDecode","canEncode","drawHorizBand","directRendering","weirdFrameTruncation","codecData","intraFrameOnly","isLossy","isLossless","encoders","trim","decoders","coderData","copy","availableEncoders","getAvailableEncoders","frameMT","sliceMT","experimental","availableFormats","getAvailableFormats","formats","format","canDemux","canMux","_checkCapabilities","unavailable","_outputs","reduce","fmts","options","find","push","Error","_inputs","cdcs","acodec","audio","vcodec","video"],"mappings":"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","sourcesContent":["/*jshint node:true*/\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar async = require('async');\nvar utils = require('./utils');\n\n/*\n *! Capability helpers\n */\n\nvar avCodecRegexp = /^\\s*([D ])([E ])([VAS])([S ])([D ])([T ]) ([^ ]+) +(.*)$/;\nvar ffCodecRegexp = /^\\s*([D\\.])([E\\.])([VAS])([I\\.])([L\\.])([S\\.]) ([^ ]+) +(.*)$/;\nvar ffEncodersRegexp = /\\(encoders:([^\\)]+)\\)/;\nvar ffDecodersRegexp = /\\(decoders:([^\\)]+)\\)/;\nvar encodersRegexp = /^\\s*([VAS\\.])([F\\.])([S\\.])([X\\.])([B\\.])([D\\.]) ([^ ]+) +(.*)$/;\nvar formatRegexp = /^\\s*([D ])([E ]) ([^ ]+) +(.*)$/;\nvar lineBreakRegexp = /\\r\\n|\\r|\\n/;\nvar filterRegexp = /^(?: [T\\.][S\\.][C\\.] )?([^ ]+) +(AA?|VV?|\\|)->(AA?|VV?|\\|) +(.*)$/;\n\nvar cache = {};\n\nmodule.exports = function(proto) {\n  /**\n   * Manually define the ffmpeg binary full path.\n   *\n   * @method FfmpegCommand#setFfmpegPath\n   *\n   * @param {String} ffmpegPath The full path to the ffmpeg binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfmpegPath = function(ffmpegPath) {\n    cache.ffmpegPath = ffmpegPath;\n    return this;\n  };\n\n  /**\n   * Manually define the ffprobe binary full path.\n   *\n   * @method FfmpegCommand#setFfprobePath\n   *\n   * @param {String} ffprobePath The full path to the ffprobe binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfprobePath = function(ffprobePath) {\n    cache.ffprobePath = ffprobePath;\n    return this;\n  };\n\n  /**\n   * Manually define the flvtool2/flvmeta binary full path.\n   *\n   * @method FfmpegCommand#setFlvtoolPath\n   *\n   * @param {String} flvtool The full path to the flvtool2 or flvmeta binary.\n   * @return FfmpegCommand\n   */\n  proto.setFlvtoolPath = function(flvtool) {\n    cache.flvtoolPath = flvtool;\n    return this;\n  };\n\n  /**\n   * Forget executable paths\n   *\n   * (only used for testing purposes)\n   *\n   * @method FfmpegCommand#_forgetPaths\n   * @private\n   */\n  proto._forgetPaths = function() {\n    delete cache.ffmpegPath;\n    delete cache.ffprobePath;\n    delete cache.flvtoolPath;\n  };\n\n  /**\n   * Check for ffmpeg availability\n   *\n   * If the FFMPEG_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffmpeg in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFfmpegPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfmpegPath = function(callback) {\n    if ('ffmpegPath' in cache) {\n      return callback(null, cache.ffmpegPath);\n    }\n\n    async.waterfall([\n      // Try FFMPEG_PATH\n      function(cb) {\n        if (process.env.FFMPEG_PATH) {\n          fs.exists(process.env.FFMPEG_PATH, function(exists) {\n            if (exists) {\n              cb(null, process.env.FFMPEG_PATH);\n            } else {\n              cb(null, '');\n            }\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search in the PATH\n      function(ffmpeg, cb) {\n        if (ffmpeg.length) {\n          return cb(null, ffmpeg);\n        }\n\n        utils.which('ffmpeg', function(err, ffmpeg) {\n          cb(err, ffmpeg);\n        });\n      }\n    ], function(err, ffmpeg) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffmpegPath = (ffmpeg || ''));\n      }\n    });\n  };\n\n\n  /**\n   * Check for ffprobe availability\n   *\n   * If the FFPROBE_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffprobe in the PATH instead.\n   * If this still fails, try to find ffprobe in the same directory as ffmpeg.\n   *\n   * @method FfmpegCommand#_getFfprobePath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfprobePath = function(callback) {\n    var self = this;\n\n    if ('ffprobePath' in cache) {\n      return callback(null, cache.ffprobePath);\n    }\n\n    async.waterfall([\n      // Try FFPROBE_PATH\n      function(cb) {\n        if (process.env.FFPROBE_PATH) {\n          fs.exists(process.env.FFPROBE_PATH, function(exists) {\n            cb(null, exists ? process.env.FFPROBE_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search in the PATH\n      function(ffprobe, cb) {\n        if (ffprobe.length) {\n          return cb(null, ffprobe);\n        }\n\n        utils.which('ffprobe', function(err, ffprobe) {\n          cb(err, ffprobe);\n        });\n      },\n\n      // Search in the same directory as ffmpeg\n      function(ffprobe, cb) {\n        if (ffprobe.length) {\n          return cb(null, ffprobe);\n        }\n\n        self._getFfmpegPath(function(err, ffmpeg) {\n          if (err) {\n            cb(err);\n          } else if (ffmpeg.length) {\n            var name = utils.isWindows ? 'ffprobe.exe' : 'ffprobe';\n            var ffprobe = path.join(path.dirname(ffmpeg), name);\n            fs.exists(ffprobe, function(exists) {\n              cb(null, exists ? ffprobe : '');\n            });\n          } else {\n            cb(null, '');\n          }\n        });\n      }\n    ], function(err, ffprobe) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffprobePath = (ffprobe || ''));\n      }\n    });\n  };\n\n\n  /**\n   * Check for flvtool2/flvmeta availability\n   *\n   * If the FLVTOOL2_PATH or FLVMETA_PATH environment variable are set, try to use them.\n   * If both are either unset or incorrect, try to find flvtool2 or flvmeta in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFlvtoolPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n   proto._getFlvtoolPath = function(callback) {\n    if ('flvtoolPath' in cache) {\n      return callback(null, cache.flvtoolPath);\n    }\n\n    async.waterfall([\n      // Try FLVMETA_PATH\n      function(cb) {\n        if (process.env.FLVMETA_PATH) {\n          fs.exists(process.env.FLVMETA_PATH, function(exists) {\n            cb(null, exists ? process.env.FLVMETA_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Try FLVTOOL2_PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        if (process.env.FLVTOOL2_PATH) {\n          fs.exists(process.env.FLVTOOL2_PATH, function(exists) {\n            cb(null, exists ? process.env.FLVTOOL2_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search for flvmeta in the PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        utils.which('flvmeta', function(err, flvmeta) {\n          cb(err, flvmeta);\n        });\n      },\n\n      // Search for flvtool2 in the PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        utils.which('flvtool2', function(err, flvtool2) {\n          cb(err, flvtool2);\n        });\n      },\n    ], function(err, flvtool) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.flvtoolPath = (flvtool || ''));\n      }\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFilters}.\n   *\n   * @callback FfmpegCommand~filterCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} filters filter object with filter names as keys and the following\n   *   properties for each filter:\n   * @param {String} filters.description filter description\n   * @param {String} filters.input input type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleInputs whether the filter supports multiple inputs\n   * @param {String} filters.output output type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleOutputs whether the filter supports multiple outputs\n   */\n\n  /**\n   * Query ffmpeg for available filters\n   *\n   * @method FfmpegCommand#availableFilters\n   * @category Capabilities\n   * @aliases getAvailableFilters\n   *\n   * @param {FfmpegCommand~filterCallback} callback callback function\n   */\n  proto.availableFilters =\n  proto.getAvailableFilters = function(callback) {\n    if ('filters' in cache) {\n      return callback(null, cache.filters);\n    }\n\n    this._spawnFfmpeg(['-filters'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split('\\n');\n      var data = {};\n      var types = { A: 'audio', V: 'video', '|': 'none' };\n\n      lines.forEach(function(line) {\n        var match = line.match(filterRegexp);\n        if (match) {\n          data[match[1]] = {\n            description: match[4],\n            input: types[match[2].charAt(0)],\n            multipleInputs: match[2].length > 1,\n            output: types[match[3].charAt(0)],\n            multipleOutputs: match[3].length > 1\n          };\n        }\n      });\n\n      callback(null, cache.filters = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableCodecs}.\n   *\n   * @callback FfmpegCommand~codecCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} codecs codec object with codec names as keys and the following\n   *   properties for each codec (more properties may be available depending on the\n   *   ffmpeg version used):\n   * @param {String} codecs.description codec description\n   * @param {Boolean} codecs.canDecode whether the codec is able to decode streams\n   * @param {Boolean} codecs.canEncode whether the codec is able to encode streams\n   */\n\n  /**\n   * Query ffmpeg for available codecs\n   *\n   * @method FfmpegCommand#availableCodecs\n   * @category Capabilities\n   * @aliases getAvailableCodecs\n   *\n   * @param {FfmpegCommand~codecCallback} callback callback function\n   */\n  proto.availableCodecs =\n  proto.getAvailableCodecs = function(callback) {\n    if ('codecs' in cache) {\n      return callback(null, cache.codecs);\n    }\n\n    this._spawnFfmpeg(['-codecs'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(avCodecRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            drawHorizBand: match[4] === 'S',\n            directRendering: match[5] === 'D',\n            weirdFrameTruncation: match[6] === 'T'\n          };\n        }\n\n        match = line.match(ffCodecRegexp);\n        if (match && match[7] !== '=') {\n          var codecData = data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            intraFrameOnly: match[4] === 'I',\n            isLossy: match[5] === 'L',\n            isLossless: match[6] === 'S'\n          };\n\n          var encoders = codecData.description.match(ffEncodersRegexp);\n          encoders = encoders ? encoders[1].trim().split(' ') : [];\n\n          var decoders = codecData.description.match(ffDecodersRegexp);\n          decoders = decoders ? decoders[1].trim().split(' ') : [];\n\n          if (encoders.length || decoders.length) {\n            var coderData = {};\n            utils.copy(codecData, coderData);\n            delete coderData.canEncode;\n            delete coderData.canDecode;\n\n            encoders.forEach(function(name) {\n              data[name] = {};\n              utils.copy(coderData, data[name]);\n              data[name].canEncode = true;\n            });\n\n            decoders.forEach(function(name) {\n              if (name in data) {\n                data[name].canDecode = true;\n              } else {\n                data[name] = {};\n                utils.copy(coderData, data[name]);\n                data[name].canDecode = true;\n              }\n            });\n          }\n        }\n      });\n\n      callback(null, cache.codecs = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableEncoders}.\n   *\n   * @callback FfmpegCommand~encodersCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} encoders encoders object with encoder names as keys and the following\n   *   properties for each encoder:\n   * @param {String} encoders.description codec description\n   * @param {Boolean} encoders.type \"audio\", \"video\" or \"subtitle\"\n   * @param {Boolean} encoders.frameMT whether the encoder is able to do frame-level multithreading\n   * @param {Boolean} encoders.sliceMT whether the encoder is able to do slice-level multithreading\n   * @param {Boolean} encoders.experimental whether the encoder is experimental\n   * @param {Boolean} encoders.drawHorizBand whether the encoder supports draw_horiz_band\n   * @param {Boolean} encoders.directRendering whether the encoder supports direct encoding method 1\n   */\n\n  /**\n   * Query ffmpeg for available encoders\n   *\n   * @method FfmpegCommand#availableEncoders\n   * @category Capabilities\n   * @aliases getAvailableEncoders\n   *\n   * @param {FfmpegCommand~encodersCallback} callback callback function\n   */\n  proto.availableEncoders =\n  proto.getAvailableEncoders = function(callback) {\n    if ('encoders' in cache) {\n      return callback(null, cache.encoders);\n    }\n\n    this._spawnFfmpeg(['-encoders'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(encodersRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[1]],\n            description: match[8],\n            frameMT: match[2] === 'F',\n            sliceMT: match[3] === 'S',\n            experimental: match[4] === 'X',\n            drawHorizBand: match[5] === 'B',\n            directRendering: match[6] === 'D'\n          };\n        }\n      });\n\n      callback(null, cache.encoders = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFormats}.\n   *\n   * @callback FfmpegCommand~formatCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} formats format object with format names as keys and the following\n   *   properties for each format:\n   * @param {String} formats.description format description\n   * @param {Boolean} formats.canDemux whether the format is able to demux streams from an input file\n   * @param {Boolean} formats.canMux whether the format is able to mux streams into an output file\n   */\n\n  /**\n   * Query ffmpeg for available formats\n   *\n   * @method FfmpegCommand#availableFormats\n   * @category Capabilities\n   * @aliases getAvailableFormats\n   *\n   * @param {FfmpegCommand~formatCallback} callback callback function\n   */\n  proto.availableFormats =\n  proto.getAvailableFormats = function(callback) {\n    if ('formats' in cache) {\n      return callback(null, cache.formats);\n    }\n\n    // Run ffmpeg -formats\n    this._spawnFfmpeg(['-formats'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Parse output\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(formatRegexp);\n        if (match) {\n          match[3].split(',').forEach(function(format) {\n            if (!(format in data)) {\n              data[format] = {\n                description: match[4],\n                canDemux: false,\n                canMux: false\n              };\n            }\n\n            if (match[1] === 'D') {\n              data[format].canDemux = true;\n            }\n            if (match[2] === 'E') {\n              data[format].canMux = true;\n            }\n          });\n        }\n      });\n\n      callback(null, cache.formats = data);\n    });\n  };\n\n\n  /**\n   * Check capabilities before executing a command\n   *\n   * Checks whether all used codecs and formats are indeed available\n   *\n   * @method FfmpegCommand#_checkCapabilities\n   * @param {Function} callback callback with signature (err)\n   * @private\n   */\n  proto._checkCapabilities = function(callback) {\n    var self = this;\n    async.waterfall([\n      // Get available formats\n      function(cb) {\n        self.availableFormats(cb);\n      },\n\n      // Check whether specified formats are available\n      function(formats, cb) {\n        var unavailable;\n\n        // Output format(s)\n        unavailable = self._outputs\n          .reduce(function(fmts, output) {\n            var format = output.options.find('-f', 1);\n            if (format) {\n              if (!(format[0] in formats) || !(formats[format[0]].canMux)) {\n                fmts.push(format);\n              }\n            }\n\n            return fmts;\n          }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Output format ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Output formats ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        // Input format(s)\n        unavailable = self._inputs\n          .reduce(function(fmts, input) {\n            var format = input.options.find('-f', 1);\n            if (format) {\n              if (!(format[0] in formats) || !(formats[format[0]].canDemux)) {\n                fmts.push(format[0]);\n              }\n            }\n\n            return fmts;\n          }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Input format ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Input formats ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        cb();\n      },\n\n      // Get available codecs\n      function(cb) {\n        self.availableEncoders(cb);\n      },\n\n      // Check whether specified codecs are available and add strict experimental options if needed\n      function(encoders, cb) {\n        var unavailable;\n\n        // Audio codec(s)\n        unavailable = self._outputs.reduce(function(cdcs, output) {\n          var acodec = output.audio.find('-acodec', 1);\n          if (acodec && acodec[0] !== 'copy') {\n            if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== 'audio') {\n              cdcs.push(acodec[0]);\n            }\n          }\n\n          return cdcs;\n        }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Audio codec ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Audio codecs ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        // Video codec(s)\n        unavailable = self._outputs.reduce(function(cdcs, output) {\n          var vcodec = output.video.find('-vcodec', 1);\n          if (vcodec && vcodec[0] !== 'copy') {\n            if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== 'video') {\n              cdcs.push(vcodec[0]);\n            }\n          }\n\n          return cdcs;\n        }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Video codec ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Video codecs ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        cb();\n      }\n    ], callback);\n  };\n};\n"]},"metadata":{},"sourceType":"script"}