{"ast":null,"code":"const utils = require('./utils');\n\nconst FORMATS = require('./formats'); // Use these to help sort formats, higher index is better.\n\n\nconst audioEncodingRanks = ['mp4a', 'mp3', 'vorbis', 'aac', 'opus', 'flac'];\nconst videoEncodingRanks = ['mp4v', 'avc1', 'Sorenson H.283', 'MPEG-4 Visual', 'VP8', 'VP9', 'H.264'];\n\nconst getVideoBitrate = format => format.bitrate || 0;\n\nconst getVideoEncodingRank = format => videoEncodingRanks.findIndex(enc => format.codecs && format.codecs.includes(enc));\n\nconst getAudioBitrate = format => format.audioBitrate || 0;\n\nconst getAudioEncodingRank = format => audioEncodingRanks.findIndex(enc => format.codecs && format.codecs.includes(enc));\n/**\n * Sort formats by a list of functions.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Array.<Function>} sortBy\n * @returns {number}\n */\n\n\nconst sortFormatsBy = (a, b, sortBy) => {\n  let res = 0;\n\n  for (let fn of sortBy) {\n    res = fn(b) - fn(a);\n\n    if (res !== 0) {\n      break;\n    }\n  }\n\n  return res;\n};\n\nconst sortFormatsByVideo = (a, b) => sortFormatsBy(a, b, [format => parseInt(format.qualityLabel), getVideoBitrate, getVideoEncodingRank]);\n\nconst sortFormatsByAudio = (a, b) => sortFormatsBy(a, b, [getAudioBitrate, getAudioEncodingRank]);\n/**\n * Sort formats from highest quality to lowest.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {number}\n */\n\n\nexports.sortFormats = (a, b) => sortFormatsBy(a, b, [// Formats with both video and audio are ranked highest.\nformat => +!!format.isHLS, format => +!!format.isDashMPD, format => +(format.contentLength > 0), format => +(format.hasVideo && format.hasAudio), format => +format.hasVideo, format => parseInt(format.qualityLabel) || 0, getVideoBitrate, getAudioBitrate, getVideoEncodingRank, getAudioEncodingRank]);\n/**\n * Choose a format depending on the given options.\n *\n * @param {Array.<Object>} formats\n * @param {Object} options\n * @returns {Object}\n * @throws {Error} when no format matches the filter/format rules\n */\n\n\nexports.chooseFormat = (formats, options) => {\n  if (typeof options.format === 'object') {\n    if (!options.format.url) {\n      throw Error('Invalid format given, did you use `ytdl.getInfo()`?');\n    }\n\n    return options.format;\n  }\n\n  if (options.filter) {\n    formats = exports.filterFormats(formats, options.filter);\n  }\n\n  let format;\n  const quality = options.quality || 'highest';\n\n  switch (quality) {\n    case 'highest':\n      format = formats[0];\n      break;\n\n    case 'lowest':\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestaudio':\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      format = formats[0];\n      break;\n\n    case 'lowestaudio':\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestvideo':\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      format = formats[0];\n      break;\n\n    case 'lowestvideo':\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      format = formats[formats.length - 1];\n      break;\n\n    default:\n      format = getFormatByQuality(quality, formats);\n      break;\n  }\n\n  if (!format) {\n    throw Error(`No such format found: ${quality}`);\n  }\n\n  return format;\n};\n/**\n * Gets a format based on quality or array of quality's\n *\n * @param {string|[string]} quality\n * @param {[Object]} formats\n * @returns {Object}\n */\n\n\nconst getFormatByQuality = (quality, formats) => {\n  let getFormat = itag => formats.find(format => `${format.itag}` === `${itag}`);\n\n  if (Array.isArray(quality)) {\n    return getFormat(quality.find(q => getFormat(q)));\n  } else {\n    return getFormat(quality);\n  }\n};\n/**\n * @param {Array.<Object>} formats\n * @param {Function} filter\n * @returns {Array.<Object>}\n */\n\n\nexports.filterFormats = (formats, filter) => {\n  let fn;\n\n  switch (filter) {\n    case 'videoandaudio':\n    case 'audioandvideo':\n      fn = format => format.hasVideo && format.hasAudio;\n\n      break;\n\n    case 'video':\n      fn = format => format.hasVideo;\n\n      break;\n\n    case 'videoonly':\n      fn = format => format.hasVideo && !format.hasAudio;\n\n      break;\n\n    case 'audio':\n      fn = format => format.hasAudio;\n\n      break;\n\n    case 'audioonly':\n      fn = format => !format.hasVideo && format.hasAudio;\n\n      break;\n\n    default:\n      if (typeof filter === 'function') {\n        fn = filter;\n      } else {\n        throw TypeError(`Given filter (${filter}) is not supported`);\n      }\n\n  }\n\n  return formats.filter(format => !!format.url && fn(format));\n};\n/**\n * @param {Object} format\n * @returns {Object}\n */\n\n\nexports.addFormatMeta = format => {\n  format = Object.assign({}, FORMATS[format.itag], format);\n  format.hasVideo = !!format.qualityLabel;\n  format.hasAudio = !!format.audioBitrate;\n  format.container = format.mimeType ? format.mimeType.split(';')[0].split('/')[1] : null;\n  format.codecs = format.mimeType ? utils.between(format.mimeType, 'codecs=\"', '\"') : null;\n  format.videoCodec = format.hasVideo && format.codecs ? format.codecs.split(', ')[0] : null;\n  format.audioCodec = format.hasAudio && format.codecs ? format.codecs.split(', ').slice(-1)[0] : null;\n  format.isLive = /\\bsource[/=]yt_live_broadcast\\b/.test(format.url);\n  format.isHLS = /\\/manifest\\/hls_(variant|playlist)\\//.test(format.url);\n  format.isDashMPD = /\\/manifest\\/dash\\//.test(format.url);\n  return format;\n};","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/ytdl-core/lib/format-utils.js"],"names":["utils","require","FORMATS","audioEncodingRanks","videoEncodingRanks","getVideoBitrate","format","bitrate","getVideoEncodingRank","findIndex","enc","codecs","includes","getAudioBitrate","audioBitrate","getAudioEncodingRank","sortFormatsBy","a","b","sortBy","res","fn","sortFormatsByVideo","parseInt","qualityLabel","sortFormatsByAudio","exports","sortFormats","isHLS","isDashMPD","contentLength","hasVideo","hasAudio","chooseFormat","formats","options","url","Error","filter","filterFormats","quality","length","sort","getFormatByQuality","getFormat","itag","find","Array","isArray","q","TypeError","addFormatMeta","Object","assign","container","mimeType","split","between","videoCodec","audioCodec","slice","isLive","test"],"mappings":"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","sourcesContent":["const utils = require('./utils');\nconst FORMATS = require('./formats');\n\n\n// Use these to help sort formats, higher index is better.\nconst audioEncodingRanks = [\n  'mp4a',\n  'mp3',\n  'vorbis',\n  'aac',\n  'opus',\n  'flac',\n];\nconst videoEncodingRanks = [\n  'mp4v',\n  'avc1',\n  'Sorenson H.283',\n  'MPEG-4 Visual',\n  'VP8',\n  'VP9',\n  'H.264',\n];\n\nconst getVideoBitrate = format => format.bitrate || 0;\nconst getVideoEncodingRank = format =>\n  videoEncodingRanks.findIndex(enc => format.codecs && format.codecs.includes(enc));\nconst getAudioBitrate = format => format.audioBitrate || 0;\nconst getAudioEncodingRank = format =>\n  audioEncodingRanks.findIndex(enc => format.codecs && format.codecs.includes(enc));\n\n\n/**\n * Sort formats by a list of functions.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Array.<Function>} sortBy\n * @returns {number}\n */\nconst sortFormatsBy = (a, b, sortBy) => {\n  let res = 0;\n  for (let fn of sortBy) {\n    res = fn(b) - fn(a);\n    if (res !== 0) {\n      break;\n    }\n  }\n  return res;\n};\n\n\nconst sortFormatsByVideo = (a, b) => sortFormatsBy(a, b, [\n  format => parseInt(format.qualityLabel),\n  getVideoBitrate,\n  getVideoEncodingRank,\n]);\n\n\nconst sortFormatsByAudio = (a, b) => sortFormatsBy(a, b, [\n  getAudioBitrate,\n  getAudioEncodingRank,\n]);\n\n\n/**\n * Sort formats from highest quality to lowest.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {number}\n */\nexports.sortFormats = (a, b) => sortFormatsBy(a, b, [\n  // Formats with both video and audio are ranked highest.\n  format => +!!format.isHLS,\n  format => +!!format.isDashMPD,\n  format => +(format.contentLength > 0),\n  format => +(format.hasVideo && format.hasAudio),\n  format => +format.hasVideo,\n  format => parseInt(format.qualityLabel) || 0,\n  getVideoBitrate,\n  getAudioBitrate,\n  getVideoEncodingRank,\n  getAudioEncodingRank,\n]);\n\n\n/**\n * Choose a format depending on the given options.\n *\n * @param {Array.<Object>} formats\n * @param {Object} options\n * @returns {Object}\n * @throws {Error} when no format matches the filter/format rules\n */\nexports.chooseFormat = (formats, options) => {\n  if (typeof options.format === 'object') {\n    if (!options.format.url) {\n      throw Error('Invalid format given, did you use `ytdl.getInfo()`?');\n    }\n    return options.format;\n  }\n\n  if (options.filter) {\n    formats = exports.filterFormats(formats, options.filter);\n  }\n\n  let format;\n  const quality = options.quality || 'highest';\n  switch (quality) {\n    case 'highest':\n      format = formats[0];\n      break;\n\n    case 'lowest':\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestaudio':\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      format = formats[0];\n      break;\n\n    case 'lowestaudio':\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestvideo':\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      format = formats[0];\n      break;\n\n    case 'lowestvideo':\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      format = formats[formats.length - 1];\n      break;\n\n    default:\n      format = getFormatByQuality(quality, formats);\n      break;\n  }\n\n  if (!format) {\n    throw Error(`No such format found: ${quality}`);\n  }\n  return format;\n};\n\n/**\n * Gets a format based on quality or array of quality's\n *\n * @param {string|[string]} quality\n * @param {[Object]} formats\n * @returns {Object}\n */\nconst getFormatByQuality = (quality, formats) => {\n  let getFormat = itag => formats.find(format => `${format.itag}` === `${itag}`);\n  if (Array.isArray(quality)) {\n    return getFormat(quality.find(q => getFormat(q)));\n  } else {\n    return getFormat(quality);\n  }\n};\n\n\n/**\n * @param {Array.<Object>} formats\n * @param {Function} filter\n * @returns {Array.<Object>}\n */\nexports.filterFormats = (formats, filter) => {\n  let fn;\n  switch (filter) {\n    case 'videoandaudio':\n    case 'audioandvideo':\n      fn = format => format.hasVideo && format.hasAudio;\n      break;\n\n    case 'video':\n      fn = format => format.hasVideo;\n      break;\n\n    case 'videoonly':\n      fn = format => format.hasVideo && !format.hasAudio;\n      break;\n\n    case 'audio':\n      fn = format => format.hasAudio;\n      break;\n\n    case 'audioonly':\n      fn = format => !format.hasVideo && format.hasAudio;\n      break;\n\n    default:\n      if (typeof filter === 'function') {\n        fn = filter;\n      } else {\n        throw TypeError(`Given filter (${filter}) is not supported`);\n      }\n  }\n  return formats.filter(format => !!format.url && fn(format));\n};\n\n\n/**\n * @param {Object} format\n * @returns {Object}\n */\nexports.addFormatMeta = format => {\n  format = Object.assign({}, FORMATS[format.itag], format);\n  format.hasVideo = !!format.qualityLabel;\n  format.hasAudio = !!format.audioBitrate;\n  format.container = format.mimeType ?\n    format.mimeType.split(';')[0].split('/')[1] : null;\n  format.codecs = format.mimeType ?\n    utils.between(format.mimeType, 'codecs=\"', '\"') : null;\n  format.videoCodec = format.hasVideo && format.codecs ?\n    format.codecs.split(', ')[0] : null;\n  format.audioCodec = format.hasAudio && format.codecs ?\n    format.codecs.split(', ').slice(-1)[0] : null;\n  format.isLive = /\\bsource[/=]yt_live_broadcast\\b/.test(format.url);\n  format.isHLS = /\\/manifest\\/hls_(variant|playlist)\\//.test(format.url);\n  format.isDashMPD = /\\/manifest\\/dash\\//.test(format.url);\n  return format;\n};\n"]},"metadata":{},"sourceType":"script"}