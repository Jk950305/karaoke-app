{"ast":null,"code":"/*jshint node:true*/\n'use strict';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar PassThrough = require('stream').PassThrough;\n\nvar async = require('async');\n\nvar utils = require('./utils');\n/*\n * Useful recipes for commands\n */\n\n\nmodule.exports = function recipes(proto) {\n  /**\n   * Execute ffmpeg command and save output to a file\n   *\n   * @method FfmpegCommand#save\n   * @category Processing\n   * @aliases saveToFile\n   *\n   * @param {String} output file path\n   * @return FfmpegCommand\n   */\n  proto.saveToFile = proto.save = function (output) {\n    this.output(output).run();\n    return this;\n  };\n  /**\n   * Execute ffmpeg command and save output to a stream\n   *\n   * If 'stream' is not specified, a PassThrough stream is created and returned.\n   * 'options' will be used when piping ffmpeg output to the output stream\n   * (@see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)\n   *\n   * @method FfmpegCommand#pipe\n   * @category Processing\n   * @aliases stream,writeToStream\n   *\n   * @param {stream.Writable} [stream] output stream\n   * @param {Object} [options={}] pipe options\n   * @return Output stream\n   */\n\n\n  proto.writeToStream = proto.pipe = proto.stream = function (stream, options) {\n    if (stream && !('writable' in stream)) {\n      options = stream;\n      stream = undefined;\n    }\n\n    if (!stream) {\n      if (process.version.match(/v0\\.8\\./)) {\n        throw new Error('PassThrough stream is not supported on node v0.8');\n      }\n\n      stream = new PassThrough();\n    }\n\n    this.output(stream, options).run();\n    return stream;\n  };\n  /**\n   * Generate images from a video\n   *\n   * Note: this method makes the command emit a 'filenames' event with an array of\n   * the generated image filenames.\n   *\n   * @method FfmpegCommand#screenshots\n   * @category Processing\n   * @aliases takeScreenshots,thumbnail,thumbnails,screenshot\n   *\n   * @param {Number|Object} [config=1] screenshot count or configuration object with\n   *   the following keys:\n   * @param {Number} [config.count] number of screenshots to take; using this option\n   *   takes screenshots at regular intervals (eg. count=4 would take screens at 20%, 40%,\n   *   60% and 80% of the video length).\n   * @param {String} [config.folder='.'] output folder\n   * @param {String} [config.filename='tn.png'] output filename pattern, may contain the following\n   *   tokens:\n   *   - '%s': offset in seconds\n   *   - '%w': screenshot width\n   *   - '%h': screenshot height\n   *   - '%r': screenshot resolution (same as '%wx%h')\n   *   - '%f': input filename\n   *   - '%b': input basename (filename w/o extension)\n   *   - '%i': index of screenshot in timemark array (can be zero-padded by using it like `%000i`)\n   * @param {Number[]|String[]} [config.timemarks] array of timemarks to take screenshots\n   *   at; each timemark may be a number of seconds, a '[[hh:]mm:]ss[.xxx]' string or a\n   *   'XX%' string.  Overrides 'count' if present.\n   * @param {Number[]|String[]} [config.timestamps] alias for 'timemarks'\n   * @param {Boolean} [config.fastSeek] use fast seek (less accurate)\n   * @param {String} [config.size] screenshot size, with the same syntax as {@link FfmpegCommand#size}\n   * @param {String} [folder] output folder (legacy alias for 'config.folder')\n   * @return FfmpegCommand\n   */\n\n\n  proto.takeScreenshots = proto.thumbnail = proto.thumbnails = proto.screenshot = proto.screenshots = function (config, folder) {\n    var self = this;\n    var source = this._currentInput.source;\n    config = config || {\n      count: 1\n    }; // Accept a number of screenshots instead of a config object\n\n    if (typeof config === 'number') {\n      config = {\n        count: config\n      };\n    } // Accept a second 'folder' parameter instead of config.folder\n\n\n    if (!('folder' in config)) {\n      config.folder = folder || '.';\n    } // Accept 'timestamps' instead of 'timemarks'\n\n\n    if ('timestamps' in config) {\n      config.timemarks = config.timestamps;\n    } // Compute timemarks from count if not present\n\n\n    if (!('timemarks' in config)) {\n      if (!config.count) {\n        throw new Error('Cannot take screenshots: neither a count nor a timemark list are specified');\n      }\n\n      var interval = 100 / (1 + config.count);\n      config.timemarks = [];\n\n      for (var i = 0; i < config.count; i++) {\n        config.timemarks.push(interval * (i + 1) + '%');\n      }\n    } // Parse size option\n\n\n    if ('size' in config) {\n      var fixedSize = config.size.match(/^(\\d+)x(\\d+)$/);\n      var fixedWidth = config.size.match(/^(\\d+)x\\?$/);\n      var fixedHeight = config.size.match(/^\\?x(\\d+)$/);\n      var percentSize = config.size.match(/^(\\d+)%$/);\n\n      if (!fixedSize && !fixedWidth && !fixedHeight && !percentSize) {\n        throw new Error('Invalid size parameter: ' + config.size);\n      }\n    } // Metadata helper\n\n\n    var metadata;\n\n    function getMetadata(cb) {\n      if (metadata) {\n        cb(null, metadata);\n      } else {\n        self.ffprobe(function (err, meta) {\n          metadata = meta;\n          cb(err, meta);\n        });\n      }\n    }\n\n    async.waterfall([// Compute percent timemarks if any\n    function computeTimemarks(next) {\n      if (config.timemarks.some(function (t) {\n        return ('' + t).match(/^[\\d.]+%$/);\n      })) {\n        if (typeof source !== 'string') {\n          return next(new Error('Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks'));\n        }\n\n        getMetadata(function (err, meta) {\n          if (err) {\n            next(err);\n          } else {\n            // Select video stream with the highest resolution\n            var vstream = meta.streams.reduce(function (biggest, stream) {\n              if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                return stream;\n              } else {\n                return biggest;\n              }\n            }, {\n              width: 0,\n              height: 0\n            });\n\n            if (vstream.width === 0) {\n              return next(new Error('No video stream in input, cannot take screenshots'));\n            }\n\n            var duration = Number(vstream.duration);\n\n            if (isNaN(duration)) {\n              duration = Number(meta.format.duration);\n            }\n\n            if (isNaN(duration)) {\n              return next(new Error('Could not get input duration, please specify fixed timemarks'));\n            }\n\n            config.timemarks = config.timemarks.map(function (mark) {\n              if (('' + mark).match(/^([\\d.]+)%$/)) {\n                return duration * parseFloat(mark) / 100;\n              } else {\n                return mark;\n              }\n            });\n            next();\n          }\n        });\n      } else {\n        next();\n      }\n    }, // Turn all timemarks into numbers and sort them\n    function normalizeTimemarks(next) {\n      config.timemarks = config.timemarks.map(function (mark) {\n        return utils.timemarkToSeconds(mark);\n      }).sort(function (a, b) {\n        return a - b;\n      });\n      next();\n    }, // Add '_%i' to pattern when requesting multiple screenshots and no variable token is present\n    function fixPattern(next) {\n      var pattern = config.filename || 'tn.png';\n\n      if (pattern.indexOf('.') === -1) {\n        pattern += '.png';\n      }\n\n      if (config.timemarks.length > 1 && !pattern.match(/%(s|0*i)/)) {\n        var ext = path.extname(pattern);\n        pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + '_%i' + ext);\n      }\n\n      next(null, pattern);\n    }, // Replace filename tokens (%f, %b) in pattern\n    function replaceFilenameTokens(pattern, next) {\n      if (pattern.match(/%[bf]/)) {\n        if (typeof source !== 'string') {\n          return next(new Error('Cannot replace %f or %b when using an input stream'));\n        }\n\n        pattern = pattern.replace(/%f/g, path.basename(source)).replace(/%b/g, path.basename(source, path.extname(source)));\n      }\n\n      next(null, pattern);\n    }, // Compute size if needed\n    function getSize(pattern, next) {\n      if (pattern.match(/%[whr]/)) {\n        if (fixedSize) {\n          return next(null, pattern, fixedSize[1], fixedSize[2]);\n        }\n\n        getMetadata(function (err, meta) {\n          if (err) {\n            return next(new Error('Could not determine video resolution to replace %w, %h or %r'));\n          }\n\n          var vstream = meta.streams.reduce(function (biggest, stream) {\n            if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n              return stream;\n            } else {\n              return biggest;\n            }\n          }, {\n            width: 0,\n            height: 0\n          });\n\n          if (vstream.width === 0) {\n            return next(new Error('No video stream in input, cannot replace %w, %h or %r'));\n          }\n\n          var width = vstream.width;\n          var height = vstream.height;\n\n          if (fixedWidth) {\n            height = height * Number(fixedWidth[1]) / width;\n            width = Number(fixedWidth[1]);\n          } else if (fixedHeight) {\n            width = width * Number(fixedHeight[1]) / height;\n            height = Number(fixedHeight[1]);\n          } else if (percentSize) {\n            width = width * Number(percentSize[1]) / 100;\n            height = height * Number(percentSize[1]) / 100;\n          }\n\n          next(null, pattern, Math.round(width / 2) * 2, Math.round(height / 2) * 2);\n        });\n      } else {\n        next(null, pattern, -1, -1);\n      }\n    }, // Replace size tokens (%w, %h, %r) in pattern\n    function replaceSizeTokens(pattern, width, height, next) {\n      pattern = pattern.replace(/%r/g, '%wx%h').replace(/%w/g, width).replace(/%h/g, height);\n      next(null, pattern);\n    }, // Replace variable tokens in pattern (%s, %i) and generate filename list\n    function replaceVariableTokens(pattern, next) {\n      var filenames = config.timemarks.map(function (t, i) {\n        return pattern.replace(/%s/g, utils.timemarkToSeconds(t)).replace(/%(0*)i/g, function (match, padding) {\n          var idx = '' + (i + 1);\n          return padding.substr(0, Math.max(0, padding.length + 1 - idx.length)) + idx;\n        });\n      });\n      self.emit('filenames', filenames);\n      next(null, filenames);\n    }, // Create output directory\n    function createDirectory(filenames, next) {\n      fs.exists(config.folder, function (exists) {\n        if (!exists) {\n          fs.mkdir(config.folder, function (err) {\n            if (err) {\n              next(err);\n            } else {\n              next(null, filenames);\n            }\n          });\n        } else {\n          next(null, filenames);\n        }\n      });\n    }], function runCommand(err, filenames) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var count = config.timemarks.length;\n      var split;\n      var filters = [split = {\n        filter: 'split',\n        options: count,\n        outputs: []\n      }];\n\n      if ('size' in config) {\n        // Set size to generate size filters\n        self.size(config.size); // Get size filters and chain them with 'sizeN' stream names\n\n        var sizeFilters = self._currentOutput.sizeFilters.get().map(function (f, i) {\n          if (i > 0) {\n            f.inputs = 'size' + (i - 1);\n          }\n\n          f.outputs = 'size' + i;\n          return f;\n        }); // Input last size filter output into split filter\n\n\n        split.inputs = 'size' + (sizeFilters.length - 1); // Add size filters in front of split filter\n\n        filters = sizeFilters.concat(filters); // Remove size filters\n\n        self._currentOutput.sizeFilters.clear();\n      }\n\n      var first = 0;\n\n      for (var i = 0; i < count; i++) {\n        var stream = 'screen' + i;\n        split.outputs.push(stream);\n\n        if (i === 0) {\n          first = config.timemarks[i];\n          self.seekInput(first);\n        }\n\n        self.output(path.join(config.folder, filenames[i])).frames(1).map(stream);\n\n        if (i > 0) {\n          self.seek(config.timemarks[i] - first);\n        }\n      }\n\n      self.complexFilter(filters);\n      self.run();\n    });\n    return this;\n  };\n  /**\n   * Merge (concatenate) inputs to a single file\n   *\n   * @method FfmpegCommand#concat\n   * @category Processing\n   * @aliases concatenate,mergeToFile\n   *\n   * @param {String|Writable} target output file or writable stream\n   * @param {Object} [options] pipe options (only used when outputting to a writable stream)\n   * @return FfmpegCommand\n   */\n\n\n  proto.mergeToFile = proto.concatenate = proto.concat = function (target, options) {\n    // Find out which streams are present in the first non-stream input\n    var fileInput = this._inputs.filter(function (input) {\n      return !input.isStream;\n    })[0];\n\n    var self = this;\n    this.ffprobe(this._inputs.indexOf(fileInput), function (err, data) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var hasAudioStreams = data.streams.some(function (stream) {\n        return stream.codec_type === 'audio';\n      });\n      var hasVideoStreams = data.streams.some(function (stream) {\n        return stream.codec_type === 'video';\n      }); // Setup concat filter and start processing\n\n      self.output(target, options).complexFilter({\n        filter: 'concat',\n        options: {\n          n: self._inputs.length,\n          v: hasVideoStreams ? 1 : 0,\n          a: hasAudioStreams ? 1 : 0\n        }\n      }).run();\n    });\n    return this;\n  };\n};","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/fluent-ffmpeg/lib/recipes.js"],"names":["fs","require","path","PassThrough","async","utils","module","exports","recipes","proto","saveToFile","save","output","run","writeToStream","pipe","stream","options","undefined","process","version","match","Error","takeScreenshots","thumbnail","thumbnails","screenshot","screenshots","config","folder","self","source","_currentInput","count","timemarks","timestamps","interval","i","push","fixedSize","size","fixedWidth","fixedHeight","percentSize","metadata","getMetadata","cb","ffprobe","err","meta","waterfall","computeTimemarks","next","some","t","vstream","streams","reduce","biggest","codec_type","width","height","duration","Number","isNaN","format","map","mark","parseFloat","normalizeTimemarks","timemarkToSeconds","sort","a","b","fixPattern","pattern","filename","indexOf","length","ext","extname","join","dirname","basename","replaceFilenameTokens","replace","getSize","Math","round","replaceSizeTokens","replaceVariableTokens","filenames","padding","idx","substr","max","emit","createDirectory","exists","mkdir","runCommand","split","filters","filter","outputs","sizeFilters","_currentOutput","get","f","inputs","concat","clear","first","seekInput","frames","seek","complexFilter","mergeToFile","concatenate","target","fileInput","_inputs","input","isStream","data","hasAudioStreams","hasVideoStreams","n","v"],"mappings":"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","sourcesContent":["/*jshint node:true*/\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar PassThrough = require('stream').PassThrough;\nvar async = require('async');\nvar utils = require('./utils');\n\n\n/*\n * Useful recipes for commands\n */\n\nmodule.exports = function recipes(proto) {\n  /**\n   * Execute ffmpeg command and save output to a file\n   *\n   * @method FfmpegCommand#save\n   * @category Processing\n   * @aliases saveToFile\n   *\n   * @param {String} output file path\n   * @return FfmpegCommand\n   */\n  proto.saveToFile =\n  proto.save = function(output) {\n    this.output(output).run();\n    return this;\n  };\n\n\n  /**\n   * Execute ffmpeg command and save output to a stream\n   *\n   * If 'stream' is not specified, a PassThrough stream is created and returned.\n   * 'options' will be used when piping ffmpeg output to the output stream\n   * (@see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)\n   *\n   * @method FfmpegCommand#pipe\n   * @category Processing\n   * @aliases stream,writeToStream\n   *\n   * @param {stream.Writable} [stream] output stream\n   * @param {Object} [options={}] pipe options\n   * @return Output stream\n   */\n  proto.writeToStream =\n  proto.pipe =\n  proto.stream = function(stream, options) {\n    if (stream && !('writable' in stream)) {\n      options = stream;\n      stream = undefined;\n    }\n\n    if (!stream) {\n      if (process.version.match(/v0\\.8\\./)) {\n        throw new Error('PassThrough stream is not supported on node v0.8');\n      }\n\n      stream = new PassThrough();\n    }\n\n    this.output(stream, options).run();\n    return stream;\n  };\n\n\n  /**\n   * Generate images from a video\n   *\n   * Note: this method makes the command emit a 'filenames' event with an array of\n   * the generated image filenames.\n   *\n   * @method FfmpegCommand#screenshots\n   * @category Processing\n   * @aliases takeScreenshots,thumbnail,thumbnails,screenshot\n   *\n   * @param {Number|Object} [config=1] screenshot count or configuration object with\n   *   the following keys:\n   * @param {Number} [config.count] number of screenshots to take; using this option\n   *   takes screenshots at regular intervals (eg. count=4 would take screens at 20%, 40%,\n   *   60% and 80% of the video length).\n   * @param {String} [config.folder='.'] output folder\n   * @param {String} [config.filename='tn.png'] output filename pattern, may contain the following\n   *   tokens:\n   *   - '%s': offset in seconds\n   *   - '%w': screenshot width\n   *   - '%h': screenshot height\n   *   - '%r': screenshot resolution (same as '%wx%h')\n   *   - '%f': input filename\n   *   - '%b': input basename (filename w/o extension)\n   *   - '%i': index of screenshot in timemark array (can be zero-padded by using it like `%000i`)\n   * @param {Number[]|String[]} [config.timemarks] array of timemarks to take screenshots\n   *   at; each timemark may be a number of seconds, a '[[hh:]mm:]ss[.xxx]' string or a\n   *   'XX%' string.  Overrides 'count' if present.\n   * @param {Number[]|String[]} [config.timestamps] alias for 'timemarks'\n   * @param {Boolean} [config.fastSeek] use fast seek (less accurate)\n   * @param {String} [config.size] screenshot size, with the same syntax as {@link FfmpegCommand#size}\n   * @param {String} [folder] output folder (legacy alias for 'config.folder')\n   * @return FfmpegCommand\n   */\n  proto.takeScreenshots =\n  proto.thumbnail =\n  proto.thumbnails =\n  proto.screenshot =\n  proto.screenshots = function(config, folder) {\n    var self = this;\n    var source = this._currentInput.source;\n    config = config || { count: 1 };\n\n    // Accept a number of screenshots instead of a config object\n    if (typeof config === 'number') {\n      config = {\n        count: config\n      };\n    }\n\n    // Accept a second 'folder' parameter instead of config.folder\n    if (!('folder' in config)) {\n      config.folder = folder || '.';\n    }\n\n    // Accept 'timestamps' instead of 'timemarks'\n    if ('timestamps' in config) {\n      config.timemarks = config.timestamps;\n    }\n\n    // Compute timemarks from count if not present\n    if (!('timemarks' in config)) {\n      if (!config.count) {\n        throw new Error('Cannot take screenshots: neither a count nor a timemark list are specified');\n      }\n\n      var interval = 100 / (1 + config.count);\n      config.timemarks = [];\n      for (var i = 0; i < config.count; i++) {\n        config.timemarks.push((interval * (i + 1)) + '%');\n      }\n    }\n\n    // Parse size option\n    if ('size' in config) {\n      var fixedSize = config.size.match(/^(\\d+)x(\\d+)$/);\n      var fixedWidth = config.size.match(/^(\\d+)x\\?$/);\n      var fixedHeight = config.size.match(/^\\?x(\\d+)$/);\n      var percentSize = config.size.match(/^(\\d+)%$/);\n\n      if (!fixedSize && !fixedWidth && !fixedHeight && !percentSize) {\n        throw new Error('Invalid size parameter: ' + config.size);\n      }\n    }\n\n    // Metadata helper\n    var metadata;\n    function getMetadata(cb) {\n      if (metadata) {\n        cb(null, metadata);\n      } else {\n        self.ffprobe(function(err, meta) {\n          metadata = meta;\n          cb(err, meta);\n        });\n      }\n    }\n\n    async.waterfall([\n      // Compute percent timemarks if any\n      function computeTimemarks(next) {\n        if (config.timemarks.some(function(t) { return ('' + t).match(/^[\\d.]+%$/); })) {\n          if (typeof source !== 'string') {\n            return next(new Error('Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks'));\n          }\n\n          getMetadata(function(err, meta) {\n            if (err) {\n              next(err);\n            } else {\n              // Select video stream with the highest resolution\n              var vstream = meta.streams.reduce(function(biggest, stream) {\n                if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                  return stream;\n                } else {\n                  return biggest;\n                }\n              }, { width: 0, height: 0 });\n\n              if (vstream.width === 0) {\n                return next(new Error('No video stream in input, cannot take screenshots'));\n              }\n\n              var duration = Number(vstream.duration);\n              if (isNaN(duration)) {\n                duration = Number(meta.format.duration);\n              }\n\n              if (isNaN(duration)) {\n                return next(new Error('Could not get input duration, please specify fixed timemarks'));\n              }\n\n              config.timemarks = config.timemarks.map(function(mark) {\n                if (('' + mark).match(/^([\\d.]+)%$/)) {\n                  return duration * parseFloat(mark) / 100;\n                } else {\n                  return mark;\n                }\n              });\n\n              next();\n            }\n          });\n        } else {\n          next();\n        }\n      },\n\n      // Turn all timemarks into numbers and sort them\n      function normalizeTimemarks(next) {\n        config.timemarks = config.timemarks.map(function(mark) {\n          return utils.timemarkToSeconds(mark);\n        }).sort(function(a, b) { return a - b; });\n\n        next();\n      },\n\n      // Add '_%i' to pattern when requesting multiple screenshots and no variable token is present\n      function fixPattern(next) {\n        var pattern = config.filename || 'tn.png';\n\n        if (pattern.indexOf('.') === -1) {\n          pattern += '.png';\n        }\n\n        if (config.timemarks.length > 1 && !pattern.match(/%(s|0*i)/)) {\n          var ext = path.extname(pattern);\n          pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + '_%i' + ext);\n        }\n\n        next(null, pattern);\n      },\n\n      // Replace filename tokens (%f, %b) in pattern\n      function replaceFilenameTokens(pattern, next) {\n        if (pattern.match(/%[bf]/)) {\n          if (typeof source !== 'string') {\n            return next(new Error('Cannot replace %f or %b when using an input stream'));\n          }\n\n          pattern = pattern\n            .replace(/%f/g, path.basename(source))\n            .replace(/%b/g, path.basename(source, path.extname(source)));\n        }\n\n        next(null, pattern);\n      },\n\n      // Compute size if needed\n      function getSize(pattern, next) {\n        if (pattern.match(/%[whr]/)) {\n          if (fixedSize) {\n            return next(null, pattern, fixedSize[1], fixedSize[2]);\n          }\n\n          getMetadata(function(err, meta) {\n            if (err) {\n              return next(new Error('Could not determine video resolution to replace %w, %h or %r'));\n            }\n\n            var vstream = meta.streams.reduce(function(biggest, stream) {\n              if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                return stream;\n              } else {\n                return biggest;\n              }\n            }, { width: 0, height: 0 });\n\n            if (vstream.width === 0) {\n              return next(new Error('No video stream in input, cannot replace %w, %h or %r'));\n            }\n\n            var width = vstream.width;\n            var height = vstream.height;\n\n            if (fixedWidth) {\n              height = height * Number(fixedWidth[1]) / width;\n              width = Number(fixedWidth[1]);\n            } else if (fixedHeight) {\n              width = width * Number(fixedHeight[1]) / height;\n              height = Number(fixedHeight[1]);\n            } else if (percentSize) {\n              width = width * Number(percentSize[1]) / 100;\n              height = height * Number(percentSize[1]) / 100;\n            }\n\n            next(null, pattern, Math.round(width / 2) * 2, Math.round(height / 2) * 2);\n          });\n        } else {\n          next(null, pattern, -1, -1);\n        }\n      },\n\n      // Replace size tokens (%w, %h, %r) in pattern\n      function replaceSizeTokens(pattern, width, height, next) {\n        pattern = pattern\n          .replace(/%r/g, '%wx%h')\n          .replace(/%w/g, width)\n          .replace(/%h/g, height);\n\n        next(null, pattern);\n      },\n\n      // Replace variable tokens in pattern (%s, %i) and generate filename list\n      function replaceVariableTokens(pattern, next) {\n        var filenames = config.timemarks.map(function(t, i) {\n          return pattern\n            .replace(/%s/g, utils.timemarkToSeconds(t))\n            .replace(/%(0*)i/g, function(match, padding) {\n              var idx = '' + (i + 1);\n              return padding.substr(0, Math.max(0, padding.length + 1 - idx.length)) + idx;\n            });\n        });\n\n        self.emit('filenames', filenames);\n        next(null, filenames);\n      },\n\n      // Create output directory\n      function createDirectory(filenames, next) {\n        fs.exists(config.folder, function(exists) {\n          if (!exists) {\n            fs.mkdir(config.folder, function(err) {\n              if (err) {\n                next(err);\n              } else {\n                next(null, filenames);\n              }\n            });\n          } else {\n            next(null, filenames);\n          }\n        });\n      }\n    ], function runCommand(err, filenames) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var count = config.timemarks.length;\n      var split;\n      var filters = [split = {\n        filter: 'split',\n        options: count,\n        outputs: []\n      }];\n\n      if ('size' in config) {\n        // Set size to generate size filters\n        self.size(config.size);\n\n        // Get size filters and chain them with 'sizeN' stream names\n        var sizeFilters =  self._currentOutput.sizeFilters.get().map(function(f, i) {\n          if (i > 0) {\n            f.inputs = 'size' + (i - 1);\n          }\n\n          f.outputs = 'size' + i;\n\n          return f;\n        });\n\n        // Input last size filter output into split filter\n        split.inputs = 'size' + (sizeFilters.length - 1);\n\n        // Add size filters in front of split filter\n        filters = sizeFilters.concat(filters);\n\n        // Remove size filters\n        self._currentOutput.sizeFilters.clear();\n      }\n\n      var first = 0;\n      for (var i = 0; i < count; i++) {\n        var stream = 'screen' + i;\n        split.outputs.push(stream);\n\n        if (i === 0) {\n          first = config.timemarks[i];\n          self.seekInput(first);\n        }\n\n        self.output(path.join(config.folder, filenames[i]))\n          .frames(1)\n          .map(stream);\n\n        if (i > 0) {\n          self.seek(config.timemarks[i] - first);\n        }\n      }\n\n      self.complexFilter(filters);\n      self.run();\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Merge (concatenate) inputs to a single file\n   *\n   * @method FfmpegCommand#concat\n   * @category Processing\n   * @aliases concatenate,mergeToFile\n   *\n   * @param {String|Writable} target output file or writable stream\n   * @param {Object} [options] pipe options (only used when outputting to a writable stream)\n   * @return FfmpegCommand\n   */\n  proto.mergeToFile =\n  proto.concatenate =\n  proto.concat = function(target, options) {\n    // Find out which streams are present in the first non-stream input\n    var fileInput = this._inputs.filter(function(input) {\n      return !input.isStream;\n    })[0];\n\n    var self = this;\n    this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var hasAudioStreams = data.streams.some(function(stream) {\n        return stream.codec_type === 'audio';\n      });\n\n      var hasVideoStreams = data.streams.some(function(stream) {\n        return stream.codec_type === 'video';\n      });\n\n      // Setup concat filter and start processing\n      self.output(target, options)\n        .complexFilter({\n          filter: 'concat',\n          options: {\n            n: self._inputs.length,\n            v: hasVideoStreams ? 1 : 0,\n            a: hasAudioStreams ? 1 : 0\n          }\n        })\n        .run();\n    });\n\n    return this;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}