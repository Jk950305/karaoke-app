{"ast":null,"code":"const getInfo = require('./info');\n\nconst utils = require('./utils');\n\nconst formatUtils = require('./format-utils');\n\nconst urlUtils = require('./url-utils');\n\nconst sig = require('./sig');\n\nconst {\n  parseTimestamp\n} = require(\"./__REACT_NATIVE_YTDL_CUSTOM_MODULES__/m3u8stream\");\n/**\n * @param {string} link\n * @param {!Object} options\n * @returns {Promise<Array.<Object>>}\n */\n\n\nconst ytdl = (link, options) => {\n  return ytdl.getInfo(link, options).then(info => {\n    return getURLsFromInfoCallback(info, options);\n  });\n};\n\nytdl.getBasicInfo = getInfo.getBasicInfo;\nytdl.getInfo = getInfo.getInfo;\nytdl.chooseFormat = formatUtils.chooseFormat;\nytdl.filterFormats = formatUtils.filterFormats;\nytdl.validateID = urlUtils.validateID;\nytdl.validateURL = urlUtils.validateURL;\nytdl.getURLVideoID = urlUtils.getURLVideoID;\nytdl.getVideoID = urlUtils.getVideoID;\nytdl.cache = {\n  sig: sig.cache,\n  info: getInfo.cache,\n  cookie: getInfo.cookieCache\n};\n/**\n * Gets downloadable URLs\n *\n * @param {Object} info\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\n\nconst getURLsFromInfoCallback = (info, options) => new Promise(async (resolve, reject) => {\n  options = options || {};\n  let err = utils.playError(info.player_response, ['UNPLAYABLE', 'LIVE_STREAM_OFFLINE', 'LOGIN_REQUIRED']);\n\n  if (err) {\n    reject(err);\n    return;\n  }\n\n  if (!info.formats.length) {\n    reject(Error('This video is unavailable'));\n    return;\n  }\n\n  let format;\n\n  try {\n    format = formatUtils.chooseFormat(info.formats, options);\n  } catch (e) {\n    reject(e);\n    return;\n  }\n\n  const ret = [];\n\n  if (!format.isHLS && !format.isDashMPD) {\n    if (options.begin) {\n      format.url += `&begin=${parseTimestamp(options.begin)}`;\n    }\n\n    const currentStream = {\n      url: format.url,\n      headers: []\n    };\n\n    if (options.range && (options.range.start || options.range.end)) {\n      currentStream.headers.push({\n        'Range': `bytes=${options.range.start || '0'}-${options.range.end || ''}`\n      });\n    }\n\n    ret.push(currentStream);\n  } else {\n    ret.push({\n      url: format.url,\n      headers: []\n    });\n  }\n\n  resolve(ret);\n});\n\nexport default ytdl;","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/react-native-ytdl/lib/index.js"],"names":["getInfo","require","utils","formatUtils","urlUtils","sig","parseTimestamp","ytdl","link","options","then","info","getURLsFromInfoCallback","getBasicInfo","chooseFormat","filterFormats","validateID","validateURL","getURLVideoID","getVideoID","cache","cookie","cookieCache","Promise","resolve","reject","err","playError","player_response","formats","length","Error","format","e","ret","isHLS","isDashMPD","begin","url","currentStream","headers","range","start","end","push"],"mappings":"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","sourcesContent":["const getInfo = require('./info');\nconst utils = require('./utils');\nconst formatUtils = require('./format-utils');\nconst urlUtils = require('./url-utils');\nconst sig = require('./sig');\nconst { parseTimestamp } = require(\"./__REACT_NATIVE_YTDL_CUSTOM_MODULES__/m3u8stream\");\n\n/**\n * @param {string} link\n * @param {!Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst ytdl = (link, options) => {\n  return ytdl.getInfo(link, options).then(info => {\n    return getURLsFromInfoCallback(info, options);\n  });\n};\n\nytdl.getBasicInfo = getInfo.getBasicInfo;\nytdl.getInfo = getInfo.getInfo;\nytdl.chooseFormat = formatUtils.chooseFormat;\nytdl.filterFormats = formatUtils.filterFormats;\nytdl.validateID = urlUtils.validateID;\nytdl.validateURL = urlUtils.validateURL;\nytdl.getURLVideoID = urlUtils.getURLVideoID;\nytdl.getVideoID = urlUtils.getVideoID;\nytdl.cache = {\n  sig: sig.cache,\n  info: getInfo.cache,\n  cookie: getInfo.cookieCache,\n};\n\n\n/**\n * Gets downloadable URLs\n *\n * @param {Object} info\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getURLsFromInfoCallback = (info, options) => new Promise(async (resolve, reject) => {\n  options = options || {};\n\n  let err = utils.playError(info.player_response, ['UNPLAYABLE', 'LIVE_STREAM_OFFLINE', 'LOGIN_REQUIRED']);\n  if (err) {\n    reject(err);\n    return;\n  }\n\n  if (!info.formats.length) {\n    reject(Error('This video is unavailable'));\n    return;\n  }\n\n  let format;\n  try {\n    format = formatUtils.chooseFormat(info.formats, options);\n  } catch (e) {\n    reject(e);\n    return;\n  }\n\n  const ret = [];\n  if (!format.isHLS && !format.isDashMPD) {\n\n    if (options.begin) {\n      format.url += `&begin=${parseTimestamp(options.begin)}`;\n    }\n\n    const currentStream = {\n      url: format.url,\n      headers: []\n    }\n    if (options.range && (options.range.start || options.range.end)) {\n      currentStream.headers.push({\n        'Range': `bytes=${options.range.start || '0'}-${options.range.end || ''}`\n      })\n    }\n\n    ret.push(currentStream);\n\n  } else {\n\n    ret.push({\n      url: format.url,\n      headers: []\n    })\n\n  }\n\n  resolve(ret)\n\n});\n\n\nexport default ytdl;\n"]},"metadata":{},"sourceType":"module"}