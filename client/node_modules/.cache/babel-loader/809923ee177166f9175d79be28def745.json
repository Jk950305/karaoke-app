{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst stream_1 = require(\"stream\");\n\nconst sax_1 = __importDefault(require(\"sax\"));\n\nconst parse_time_1 = require(\"./parse-time\");\n/**\n * A wrapper around sax that emits segments.\n */\n\n\nclass DashMPDParser extends stream_1.Writable {\n  constructor(targetID) {\n    super();\n    this._parser = sax_1.default.createStream(false, {\n      lowercase: true\n    });\n\n    this._parser.on('error', this.destroy.bind(this));\n\n    let lastTag;\n    let currtime = 0;\n    let seq = 0;\n    let segmentTemplate;\n    let timescale, offset, duration, baseURL;\n    let timeline = [];\n    let getSegments = false;\n    let gotSegments = false;\n    let isStatic;\n    let treeLevel;\n    let periodStart;\n\n    const tmpl = str => {\n      const context = {\n        RepresentationID: targetID,\n        Number: seq,\n        Time: currtime\n      };\n      return str.replace(/\\$(\\w+)\\$/g, (m, p1) => context[p1] + '');\n    };\n\n    this._parser.on('opentag', node => {\n      switch (node.name) {\n        case 'mpd':\n          currtime = node.attributes.availabilitystarttime ? new Date(node.attributes.availabilitystarttime).getTime() : 0;\n          isStatic = node.attributes.type !== 'dynamic';\n          break;\n\n        case 'period':\n          // Reset everything on <Period> tag.\n          seq = 0;\n          timescale = 1000;\n          duration = 0;\n          offset = 0;\n          baseURL = [];\n          treeLevel = 0;\n          periodStart = parse_time_1.durationStr(node.attributes.start) || 0;\n          break;\n\n        case 'segmentlist':\n          seq = parseInt(node.attributes.startnumber) || seq;\n          timescale = parseInt(node.attributes.timescale) || timescale;\n          duration = parseInt(node.attributes.duration) || duration;\n          offset = parseInt(node.attributes.presentationtimeoffset) || offset;\n          break;\n\n        case 'segmenttemplate':\n          segmentTemplate = node.attributes;\n          seq = parseInt(node.attributes.startnumber) || seq;\n          timescale = parseInt(node.attributes.timescale) || timescale;\n          break;\n\n        case 'segmenttimeline':\n        case 'baseurl':\n          lastTag = node.name;\n          break;\n\n        case 's':\n          timeline.push({\n            duration: parseInt(node.attributes.d),\n            repeat: parseInt(node.attributes.r),\n            time: parseInt(node.attributes.t)\n          });\n          break;\n\n        case 'adaptationset':\n        case 'representation':\n          treeLevel++;\n\n          if (targetID == null) {\n            targetID = node.attributes.id;\n          }\n\n          getSegments = node.attributes.id === targetID + '';\n\n          if (getSegments) {\n            if (periodStart) {\n              currtime += periodStart;\n            }\n\n            if (offset) {\n              currtime -= offset / timescale * 1000;\n            }\n\n            this.emit('starttime', currtime);\n          }\n\n          break;\n\n        case 'initialization':\n          if (getSegments) {\n            this.emit('item', {\n              url: baseURL.filter(s => !!s).join('') + node.attributes.sourceurl,\n              seq: seq,\n              init: true,\n              duration: 0\n            });\n          }\n\n          break;\n\n        case 'segmenturl':\n          if (getSegments) {\n            gotSegments = true;\n            let tl = timeline.shift();\n            let segmentDuration = (tl && tl.duration || duration) / timescale * 1000;\n            this.emit('item', {\n              url: baseURL.filter(s => !!s).join('') + node.attributes.media,\n              seq: seq++,\n              duration: segmentDuration\n            });\n            currtime += segmentDuration;\n          }\n\n          break;\n      }\n    });\n\n    const onEnd = () => {\n      if (isStatic) {\n        this.emit('endlist');\n      }\n\n      if (!getSegments) {\n        this.destroy(Error(`Representation '${targetID}' not found`));\n      } else {\n        this.emit('end');\n      }\n    };\n\n    this._parser.on('closetag', tagName => {\n      switch (tagName) {\n        case 'adaptationset':\n        case 'representation':\n          treeLevel--;\n\n          if (segmentTemplate && timeline.length) {\n            gotSegments = true;\n\n            if (segmentTemplate.initialization) {\n              this.emit('item', {\n                url: baseURL.filter(s => !!s).join('') + tmpl(segmentTemplate.initialization),\n                seq: seq,\n                init: true,\n                duration: 0\n              });\n            }\n\n            for (let {\n              duration,\n              repeat,\n              time\n            } of timeline) {\n              duration = duration / timescale * 1000;\n              repeat = repeat || 1;\n              currtime = time || currtime;\n\n              for (let i = 0; i < repeat; i++) {\n                this.emit('item', {\n                  url: baseURL.filter(s => !!s).join('') + tmpl(segmentTemplate.media),\n                  seq: seq++,\n                  duration\n                });\n                currtime += duration;\n              }\n            }\n          }\n\n          if (gotSegments) {\n            this.emit('endearly');\n            onEnd();\n\n            this._parser.removeAllListeners();\n\n            this.removeAllListeners('finish');\n          }\n\n          break;\n      }\n    });\n\n    this._parser.on('text', text => {\n      if (lastTag === 'baseurl') {\n        baseURL[treeLevel] = text;\n        lastTag = null;\n      }\n    });\n\n    this.on('finish', onEnd);\n  }\n\n  _write(chunk, encoding, callback) {\n    this._parser.write(chunk, encoding);\n\n    callback();\n  }\n\n}\n\nexports.default = DashMPDParser;","map":{"version":3,"sources":["../src/dash-mpd-parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stream_1 = require(\"stream\");\nconst sax_1 = __importDefault(require(\"sax\"));\nconst parse_time_1 = require(\"./parse-time\");\n/**\n * A wrapper around sax that emits segments.\n */\nclass DashMPDParser extends stream_1.Writable {\n    constructor(targetID) {\n        super();\n        this._parser = sax_1.default.createStream(false, { lowercase: true });\n        this._parser.on('error', this.destroy.bind(this));\n        let lastTag;\n        let currtime = 0;\n        let seq = 0;\n        let segmentTemplate;\n        let timescale, offset, duration, baseURL;\n        let timeline = [];\n        let getSegments = false;\n        let gotSegments = false;\n        let isStatic;\n        let treeLevel;\n        let periodStart;\n        const tmpl = (str) => {\n            const context = {\n                RepresentationID: targetID,\n                Number: seq,\n                Time: currtime,\n            };\n            return str.replace(/\\$(\\w+)\\$/g, (m, p1) => context[p1] + '');\n        };\n        this._parser.on('opentag', (node) => {\n            switch (node.name) {\n                case 'mpd':\n                    currtime =\n                        node.attributes.availabilitystarttime ?\n                            new Date(node.attributes.availabilitystarttime).getTime() : 0;\n                    isStatic = node.attributes.type !== 'dynamic';\n                    break;\n                case 'period':\n                    // Reset everything on <Period> tag.\n                    seq = 0;\n                    timescale = 1000;\n                    duration = 0;\n                    offset = 0;\n                    baseURL = [];\n                    treeLevel = 0;\n                    periodStart = parse_time_1.durationStr(node.attributes.start) || 0;\n                    break;\n                case 'segmentlist':\n                    seq = parseInt(node.attributes.startnumber) || seq;\n                    timescale = parseInt(node.attributes.timescale) || timescale;\n                    duration = parseInt(node.attributes.duration) || duration;\n                    offset = parseInt(node.attributes.presentationtimeoffset) || offset;\n                    break;\n                case 'segmenttemplate':\n                    segmentTemplate = node.attributes;\n                    seq = parseInt(node.attributes.startnumber) || seq;\n                    timescale = parseInt(node.attributes.timescale) || timescale;\n                    break;\n                case 'segmenttimeline':\n                case 'baseurl':\n                    lastTag = node.name;\n                    break;\n                case 's':\n                    timeline.push({\n                        duration: parseInt(node.attributes.d),\n                        repeat: parseInt(node.attributes.r),\n                        time: parseInt(node.attributes.t),\n                    });\n                    break;\n                case 'adaptationset':\n                case 'representation':\n                    treeLevel++;\n                    if (targetID == null) {\n                        targetID = node.attributes.id;\n                    }\n                    getSegments = node.attributes.id === targetID + '';\n                    if (getSegments) {\n                        if (periodStart) {\n                            currtime += periodStart;\n                        }\n                        if (offset) {\n                            currtime -= offset / timescale * 1000;\n                        }\n                        this.emit('starttime', currtime);\n                    }\n                    break;\n                case 'initialization':\n                    if (getSegments) {\n                        this.emit('item', {\n                            url: baseURL.filter(s => !!s).join('') + node.attributes.sourceurl,\n                            seq: seq,\n                            init: true,\n                            duration: 0,\n                        });\n                    }\n                    break;\n                case 'segmenturl':\n                    if (getSegments) {\n                        gotSegments = true;\n                        let tl = timeline.shift();\n                        let segmentDuration = (tl && tl.duration || duration) / timescale * 1000;\n                        this.emit('item', {\n                            url: baseURL.filter(s => !!s).join('') + node.attributes.media,\n                            seq: seq++,\n                            duration: segmentDuration,\n                        });\n                        currtime += segmentDuration;\n                    }\n                    break;\n            }\n        });\n        const onEnd = () => {\n            if (isStatic) {\n                this.emit('endlist');\n            }\n            if (!getSegments) {\n                this.destroy(Error(`Representation '${targetID}' not found`));\n            }\n            else {\n                this.emit('end');\n            }\n        };\n        this._parser.on('closetag', (tagName) => {\n            switch (tagName) {\n                case 'adaptationset':\n                case 'representation':\n                    treeLevel--;\n                    if (segmentTemplate && timeline.length) {\n                        gotSegments = true;\n                        if (segmentTemplate.initialization) {\n                            this.emit('item', {\n                                url: baseURL.filter(s => !!s).join('') +\n                                    tmpl(segmentTemplate.initialization),\n                                seq: seq,\n                                init: true,\n                                duration: 0,\n                            });\n                        }\n                        for (let { duration, repeat, time } of timeline) {\n                            duration = duration / timescale * 1000;\n                            repeat = repeat || 1;\n                            currtime = time || currtime;\n                            for (let i = 0; i < repeat; i++) {\n                                this.emit('item', {\n                                    url: baseURL.filter(s => !!s).join('') +\n                                        tmpl(segmentTemplate.media),\n                                    seq: seq++,\n                                    duration,\n                                });\n                                currtime += duration;\n                            }\n                        }\n                    }\n                    if (gotSegments) {\n                        this.emit('endearly');\n                        onEnd();\n                        this._parser.removeAllListeners();\n                        this.removeAllListeners('finish');\n                    }\n                    break;\n            }\n        });\n        this._parser.on('text', (text) => {\n            if (lastTag === 'baseurl') {\n                baseURL[treeLevel] = text;\n                lastTag = null;\n            }\n        });\n        this.on('finish', onEnd);\n    }\n    _write(chunk, encoding, callback) {\n        this._parser.write(chunk, encoding);\n        callback();\n    }\n}\nexports.default = DashMPDParser;\n//# sourceMappingURL=dash-mpd-parser.js.map"]},"metadata":{},"sourceType":"script"}