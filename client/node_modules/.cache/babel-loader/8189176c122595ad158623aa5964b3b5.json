{"ast":null,"code":"'use strict';\n\nvar os = require('os');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar ffmpeg = require('fluent-ffmpeg');\n\nvar ytdl = require('ytdl-core');\n\nvar async = require('async');\n\nvar progress = require('progress-stream');\n\nvar sanitize = require('sanitize-filename');\n\nclass YoutubeMp3Downloader extends EventEmitter {\n  constructor(options) {\n    super();\n    this.youtubeBaseUrl = 'http://www.youtube.com/watch?v=';\n    this.youtubeVideoQuality = options && options.youtubeVideoQuality ? options.youtubeVideoQuality : 'highestaudio';\n    this.outputPath = options && options.outputPath ? options.outputPath : os.homedir();\n    this.queueParallelism = options && options.queueParallelism ? options.queueParallelism : 1;\n    this.progressTimeout = options && options.progressTimeout ? options.progressTimeout : 1000;\n    this.fileNameReplacements = [[/'/g, ''], [/\\|/g, ''], [/'/g, ''], [/\\//g, ''], [/\\?/g, ''], [/:/g, ''], [/;/g, '']];\n    this.requestOptions = options && options.requestOptions ? options.requestOptions : {\n      maxRedirects: 5\n    };\n    this.outputOptions = options && options.outputOptions ? options.outputOptions : [];\n    this.allowWebm = options && options.allowWebm ? options.allowWebm : false;\n\n    if (options && options.ffmpegPath) {\n      ffmpeg.setFfmpegPath(options.ffmpegPath);\n    }\n\n    this.setupQueue();\n  }\n\n  setupQueue() {\n    let self = this; //Async download/transcode queue\n\n    this.downloadQueue = async.queue(function (task, callback) {\n      self.emit('queueSize', self.downloadQueue.running() + self.downloadQueue.length());\n      self.performDownload(task, function (err, result) {\n        callback(err, result);\n      });\n    }, self.queueParallelism);\n  }\n\n  cleanFileName(fileName) {\n    this.fileNameReplacements.forEach(function (replacement) {\n      fileName = fileName.replace(replacement[0], replacement[1]);\n    });\n    return fileName;\n  }\n\n  download(videoId, fileName) {\n    let self = this;\n    const task = {\n      videoId: videoId,\n      fileName: fileName\n    };\n    this.downloadQueue.push(task, function (err, data) {\n      self.emit('queueSize', self.downloadQueue.running() + self.downloadQueue.length());\n\n      if (err) {\n        self.emit('error', err, data);\n      } else {\n        self.emit('finished', err, data);\n      }\n    });\n  }\n\n  async performDownload(task, callback) {\n    let self = this;\n    let info;\n    const videoUrl = this.youtubeBaseUrl + task.videoId;\n    let resultObj = {\n      videoId: task.videoId\n    };\n\n    try {\n      info = await ytdl.getInfo(videoUrl, {\n        quality: this.youtubeVideoQuality\n      });\n    } catch (err) {\n      callback(err);\n    }\n\n    var videoTitle = this.cleanFileName(info.videoDetails.title);\n    var artist = 'Unknown';\n    var title = 'Unknown';\n    var thumbnail = info.videoDetails.thumbnail.thumbnails[0].url || null;\n\n    if (videoTitle.indexOf('-') > -1) {\n      var temp = videoTitle.split('-');\n\n      if (temp.length >= 2) {\n        artist = temp[0].trim();\n        title = temp[1].trim();\n      }\n    } else {\n      title = videoTitle;\n    } //Derive file name, if given, use it, if not, from video title\n\n\n    const fileName = task.fileName ? self.outputPath + '/' + task.fileName : self.outputPath + '/' + (sanitize(videoTitle) || info.videoId) + '.mp3'; //Stream setup\n\n    const streamOptions = {\n      quality: self.youtubeVideoQuality,\n      requestOptions: self.requestOptions\n    };\n\n    if (!self.allowWebm) {\n      streamOptions.filter = format => format.container === 'mp4';\n    }\n\n    const stream = ytdl.downloadFromInfo(info, streamOptions);\n    stream.on('error', function (err) {\n      callback(err, null);\n    });\n    stream.on('response', function (httpResponse) {\n      //Setup of progress module\n      const str = progress({\n        length: parseInt(httpResponse.headers['content-length']),\n        time: self.progressTimeout\n      }); //Add progress event listener\n\n      str.on('progress', function (progress) {\n        if (progress.percentage === 100) {\n          resultObj.stats = {\n            transferredBytes: progress.transferred,\n            runtime: progress.runtime,\n            averageSpeed: parseFloat(progress.speed.toFixed(2))\n          };\n        }\n\n        self.emit('progress', {\n          videoId: task.videoId,\n          progress: progress\n        });\n      });\n      let outputOptions = ['-id3v2_version', '4', '-metadata', 'title=' + title, '-metadata', 'artist=' + artist];\n\n      if (self.outputOptions) {\n        outputOptions = outputOptions.concat(self.outputOptions);\n      }\n\n      const audioBitrate = info.formats.find(format => !!format.audioBitrate).audioBitrate; //Start encoding\n\n      const proc = new ffmpeg({\n        source: stream.pipe(str)\n      }).audioBitrate(audioBitrate || 192).withAudioCodec('libmp3lame').toFormat('mp3').outputOptions(...outputOptions).on('error', function (err) {\n        callback(err.message, null);\n      }).on('end', function () {\n        resultObj.file = fileName;\n        resultObj.youtubeUrl = videoUrl;\n        resultObj.videoTitle = videoTitle;\n        resultObj.artist = artist;\n        resultObj.title = title;\n        resultObj.thumbnail = thumbnail;\n        callback(null, resultObj);\n      }).saveToFile(fileName);\n    });\n  }\n\n}\n\nmodule.exports = YoutubeMp3Downloader;","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/youtube-mp3-downloader/lib/YoutubeMp3Downloader.js"],"names":["os","require","EventEmitter","ffmpeg","ytdl","async","progress","sanitize","YoutubeMp3Downloader","constructor","options","youtubeBaseUrl","youtubeVideoQuality","outputPath","homedir","queueParallelism","progressTimeout","fileNameReplacements","requestOptions","maxRedirects","outputOptions","allowWebm","ffmpegPath","setFfmpegPath","setupQueue","self","downloadQueue","queue","task","callback","emit","running","length","performDownload","err","result","cleanFileName","fileName","forEach","replacement","replace","download","videoId","push","data","info","videoUrl","resultObj","getInfo","quality","videoTitle","videoDetails","title","artist","thumbnail","thumbnails","url","indexOf","temp","split","trim","streamOptions","filter","format","container","stream","downloadFromInfo","on","httpResponse","str","parseInt","headers","time","percentage","stats","transferredBytes","transferred","runtime","averageSpeed","parseFloat","speed","toFixed","concat","audioBitrate","formats","find","proc","source","pipe","withAudioCodec","toFormat","message","file","youtubeUrl","saveToFile","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nvar os = require('os');\nvar EventEmitter = require('events').EventEmitter;\nvar ffmpeg = require('fluent-ffmpeg');\nvar ytdl = require('ytdl-core');\nvar async = require('async');\nvar progress = require('progress-stream');\nvar sanitize = require('sanitize-filename');\n\nclass YoutubeMp3Downloader extends EventEmitter {\n\n    constructor(options) {\n        super();\n        this.youtubeBaseUrl = 'http://www.youtube.com/watch?v=';\n        this.youtubeVideoQuality = (options && options.youtubeVideoQuality ? options.youtubeVideoQuality : 'highestaudio');\n        this.outputPath = options && options.outputPath ? options.outputPath : os.homedir();\n        this.queueParallelism = (options && options.queueParallelism ? options.queueParallelism : 1);\n        this.progressTimeout = (options && options.progressTimeout ? options.progressTimeout : 1000);\n        this.fileNameReplacements = [[/'/g, ''], [/\\|/g, ''], [/'/g, ''], [/\\//g, ''], [/\\?/g, ''], [/:/g, ''], [/;/g, '']];\n        this.requestOptions = (options && options.requestOptions ? options.requestOptions : { maxRedirects: 5 });\n        this.outputOptions = (options && options.outputOptions ? options.outputOptions : []);\n        this.allowWebm = (options && options.allowWebm ? options.allowWebm : false);\n\n        if (options && options.ffmpegPath) {\n            ffmpeg.setFfmpegPath(options.ffmpegPath);\n        }\n\n        this.setupQueue();\n    }\n\n    setupQueue() {\n        let self = this;\n        //Async download/transcode queue\n        this.downloadQueue = async.queue(function (task, callback) {\n\n            self.emit('queueSize', self.downloadQueue.running() + self.downloadQueue.length());\n\n            self.performDownload(task, function(err, result) {\n                callback(err, result);\n            });\n\n        }, self.queueParallelism);\n    }\n\n    cleanFileName (fileName) {\n        this.fileNameReplacements.forEach(function(replacement) {\n            fileName = fileName.replace(replacement[0], replacement[1]);\n        });\n        return fileName;\n    };\n\n    download (videoId, fileName) {\n        let self = this;\n        const task = {\n            videoId: videoId,\n            fileName: fileName\n        };\n    \n        this.downloadQueue.push(task, function (err, data) {\n    \n            self.emit('queueSize', self.downloadQueue.running() + self.downloadQueue.length());\n    \n            if (err) {\n                self.emit('error', err, data);\n            } else {\n                self.emit('finished', err, data);\n            }\n        });\n    \n    };\n\n    async performDownload(task, callback) {\n        let self = this;\n        let info;\n        const videoUrl = this.youtubeBaseUrl+task.videoId;\n        let resultObj = {\n            videoId: task.videoId\n        };\n\n         try {\n            info = await ytdl.getInfo(videoUrl, { quality: this.youtubeVideoQuality })\n         } catch (err){\n            callback(err);\n         }\n    \n        var videoTitle = this.cleanFileName(info.videoDetails.title);\n        var artist = 'Unknown';\n        var title = 'Unknown';\n        var thumbnail = info.videoDetails.thumbnail.thumbnails[0].url || null;\n    \n        if (videoTitle.indexOf('-') > -1) {\n            var temp = videoTitle.split('-');\n            if (temp.length >= 2) {\n                artist = temp[0].trim();\n                title = temp[1].trim();\n            }\n        } else {\n            title = videoTitle;\n        }\n\n        //Derive file name, if given, use it, if not, from video title\n        const fileName = (task.fileName ? self.outputPath + '/' + task.fileName : self.outputPath + '/' + (sanitize(videoTitle) || info.videoId) + '.mp3');\n\n        //Stream setup\n\n        const streamOptions =  {\n            quality: self.youtubeVideoQuality,\n            requestOptions: self.requestOptions\n        };\n\n        if (!self.allowWebm) {\n            streamOptions.filter = format => format.container === 'mp4';\n        }\n\n        const stream = ytdl.downloadFromInfo(info, streamOptions);\n\n        stream.on('error', function(err){\n          callback(err, null);\n        });\n\n        stream.on('response', function(httpResponse) {\n\n            //Setup of progress module\n            const str = progress({\n                length: parseInt(httpResponse.headers['content-length']),\n                time: self.progressTimeout\n            });\n\n            //Add progress event listener\n            str.on('progress', function(progress) {\n                if (progress.percentage === 100) {\n                    resultObj.stats= {\n                        transferredBytes: progress.transferred,\n                        runtime: progress.runtime,\n                        averageSpeed: parseFloat(progress.speed.toFixed(2))\n                    }\n                }\n                self.emit('progress', {videoId: task.videoId, progress: progress})\n            });\n            let outputOptions = [\n                '-id3v2_version', '4',\n                '-metadata', 'title=' + title,\n                '-metadata', 'artist=' + artist\n            ];\n            if (self.outputOptions) {\n                outputOptions = outputOptions.concat(self.outputOptions);\n            }\n            \n            const audioBitrate =\n                info.formats.find(format => !!format.audioBitrate).audioBitrate\n\n            //Start encoding\n            const proc = new ffmpeg({\n                source: stream.pipe(str)\n            })\n            .audioBitrate(audioBitrate || 192)\n            .withAudioCodec('libmp3lame')\n            .toFormat('mp3')\n            .outputOptions(...outputOptions)\n            .on('error', function(err) {\n                callback(err.message, null);\n            })\n            .on('end', function() {\n                resultObj.file =  fileName;\n                resultObj.youtubeUrl = videoUrl;\n                resultObj.videoTitle = videoTitle;\n                resultObj.artist = artist;\n                resultObj.title = title;\n                resultObj.thumbnail = thumbnail;\n                callback(null, resultObj);\n            })\n            .saveToFile(fileName);\n\n        });\n    \n    };\n\n}\n\nmodule.exports = YoutubeMp3Downloader;\n"]},"metadata":{},"sourceType":"script"}