{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst stream_1 = require(\"stream\");\n/**\n * A very simple m3u8 playlist file parser that detects tags and segments.\n */\n\n\nclass m3u8Parser extends stream_1.Writable {\n  constructor() {\n    super();\n    this._lastLine = '';\n    this._seq = 0;\n    this._nextItemDuration = null;\n    this._nextItemRange = null;\n    this._lastItemRangeEnd = 0;\n    this.on('finish', () => {\n      this._parseLine(this._lastLine);\n\n      this.emit('end');\n    });\n  }\n\n  _parseAttrList(value) {\n    let attrs = {};\n    let regex = /([A-Z0-9-]+)=(?:\"([^\"]*?)\"|([^,]*?))/g;\n    let match;\n\n    while ((match = regex.exec(value)) != null) {\n      attrs[match[1]] = match[2] || match[3];\n    }\n\n    return attrs;\n  }\n\n  _parseRange(value) {\n    if (!value) return null;\n    let svalue = value.split('@');\n    let start = svalue[1] ? parseInt(svalue[1]) : this._lastItemRangeEnd + 1;\n    let end = start + parseInt(svalue[0]) - 1;\n    let range = {\n      start,\n      end\n    };\n    this._lastItemRangeEnd = range.end;\n    return range;\n  }\n\n  _parseLine(line) {\n    let match = line.match(/^#(EXT[A-Z0-9-]+)(?::(.*))?/);\n\n    if (match) {\n      // This is a tag.\n      const tag = match[1];\n      const value = match[2] || '';\n\n      switch (tag) {\n        case 'EXT-X-PROGRAM-DATE-TIME':\n          this.emit('starttime', new Date(value).getTime());\n          break;\n\n        case 'EXT-X-MEDIA-SEQUENCE':\n          this._seq = parseInt(value);\n          break;\n\n        case 'EXT-X-MAP':\n          {\n            let attrs = this._parseAttrList(value);\n\n            if (!attrs.URI) {\n              this.destroy(new Error('`EXT-X-MAP` found without required attribute `URI`'));\n              return;\n            }\n\n            this.emit('item', {\n              url: attrs.URI,\n              seq: this._seq,\n              init: true,\n              duration: 0,\n              range: this._parseRange(attrs.BYTERANGE)\n            });\n            break;\n          }\n\n        case 'EXT-X-BYTERANGE':\n          {\n            this._nextItemRange = this._parseRange(value);\n            break;\n          }\n\n        case 'EXTINF':\n          this._nextItemDuration = Math.round(parseFloat(value.split(',')[0]) * 1000);\n          break;\n\n        case 'EXT-X-ENDLIST':\n          this.emit('endlist');\n          break;\n      }\n    } else if (!/^#/.test(line) && line.trim()) {\n      // This is a segment\n      this.emit('item', {\n        url: line.trim(),\n        seq: this._seq++,\n        duration: this._nextItemDuration,\n        range: this._nextItemRange\n      });\n      this._nextItemRange = null;\n    }\n  }\n\n  _write(chunk, encoding, callback) {\n    let lines = chunk.toString('utf8').split('\\n');\n\n    if (this._lastLine) {\n      lines[0] = this._lastLine + lines[0];\n    }\n\n    lines.forEach((line, i) => {\n      if (this.destroyed) return;\n\n      if (i < lines.length - 1) {\n        this._parseLine(line);\n      } else {\n        // Save the last line in case it has been broken up.\n        this._lastLine = line;\n      }\n    });\n    callback();\n  }\n\n}\n\nexports.default = m3u8Parser;","map":{"version":3,"sources":["../src/m3u8-parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stream_1 = require(\"stream\");\n/**\n * A very simple m3u8 playlist file parser that detects tags and segments.\n */\nclass m3u8Parser extends stream_1.Writable {\n    constructor() {\n        super();\n        this._lastLine = '';\n        this._seq = 0;\n        this._nextItemDuration = null;\n        this._nextItemRange = null;\n        this._lastItemRangeEnd = 0;\n        this.on('finish', () => {\n            this._parseLine(this._lastLine);\n            this.emit('end');\n        });\n    }\n    _parseAttrList(value) {\n        let attrs = {};\n        let regex = /([A-Z0-9-]+)=(?:\"([^\"]*?)\"|([^,]*?))/g;\n        let match;\n        while ((match = regex.exec(value)) != null) {\n            attrs[match[1]] = match[2] || match[3];\n        }\n        return attrs;\n    }\n    _parseRange(value) {\n        if (!value)\n            return null;\n        let svalue = value.split('@');\n        let start = svalue[1] ? parseInt(svalue[1]) : this._lastItemRangeEnd + 1;\n        let end = start + parseInt(svalue[0]) - 1;\n        let range = { start, end };\n        this._lastItemRangeEnd = range.end;\n        return range;\n    }\n    _parseLine(line) {\n        let match = line.match(/^#(EXT[A-Z0-9-]+)(?::(.*))?/);\n        if (match) {\n            // This is a tag.\n            const tag = match[1];\n            const value = match[2] || '';\n            switch (tag) {\n                case 'EXT-X-PROGRAM-DATE-TIME':\n                    this.emit('starttime', new Date(value).getTime());\n                    break;\n                case 'EXT-X-MEDIA-SEQUENCE':\n                    this._seq = parseInt(value);\n                    break;\n                case 'EXT-X-MAP': {\n                    let attrs = this._parseAttrList(value);\n                    if (!attrs.URI) {\n                        this.destroy(new Error('`EXT-X-MAP` found without required attribute `URI`'));\n                        return;\n                    }\n                    this.emit('item', {\n                        url: attrs.URI,\n                        seq: this._seq,\n                        init: true,\n                        duration: 0,\n                        range: this._parseRange(attrs.BYTERANGE),\n                    });\n                    break;\n                }\n                case 'EXT-X-BYTERANGE': {\n                    this._nextItemRange = this._parseRange(value);\n                    break;\n                }\n                case 'EXTINF':\n                    this._nextItemDuration =\n                        Math.round(parseFloat(value.split(',')[0]) * 1000);\n                    break;\n                case 'EXT-X-ENDLIST':\n                    this.emit('endlist');\n                    break;\n            }\n        }\n        else if (!/^#/.test(line) && line.trim()) {\n            // This is a segment\n            this.emit('item', {\n                url: line.trim(),\n                seq: this._seq++,\n                duration: this._nextItemDuration,\n                range: this._nextItemRange,\n            });\n            this._nextItemRange = null;\n        }\n    }\n    _write(chunk, encoding, callback) {\n        let lines = chunk.toString('utf8').split('\\n');\n        if (this._lastLine) {\n            lines[0] = this._lastLine + lines[0];\n        }\n        lines.forEach((line, i) => {\n            if (this.destroyed)\n                return;\n            if (i < lines.length - 1) {\n                this._parseLine(line);\n            }\n            else {\n                // Save the last line in case it has been broken up.\n                this._lastLine = line;\n            }\n        });\n        callback();\n    }\n}\nexports.default = m3u8Parser;\n//# sourceMappingURL=m3u8-parser.js.map"]},"metadata":{},"sourceType":"script"}