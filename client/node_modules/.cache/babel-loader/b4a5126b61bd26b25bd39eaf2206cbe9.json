{"ast":null,"code":"/*jshint node:true*/\n'use strict';\n\nvar exec = require('child_process').exec;\n\nvar isWindows = require('os').platform().match(/win(32|64)/);\n\nvar which = require('which');\n\nvar nlRegexp = /\\r\\n|\\r|\\n/g;\nvar streamRegexp = /^\\[?(.*?)\\]?$/;\nvar filterEscapeRegexp = /[,]/;\nvar whichCache = {};\n/**\n * Parse progress line from ffmpeg stderr\n *\n * @param {String} line progress line\n * @return progress object\n * @private\n */\n\nfunction parseProgressLine(line) {\n  var progress = {}; // Remove all spaces after = and trim\n\n  line = line.replace(/=\\s+/g, '=').trim();\n  var progressParts = line.split(' '); // Split every progress part by \"=\" to get key and value\n\n  for (var i = 0; i < progressParts.length; i++) {\n    var progressSplit = progressParts[i].split('=', 2);\n    var key = progressSplit[0];\n    var value = progressSplit[1]; // This is not a progress line\n\n    if (typeof value === 'undefined') return null;\n    progress[key] = value;\n  }\n\n  return progress;\n}\n\nvar utils = module.exports = {\n  isWindows: isWindows,\n  streamRegexp: streamRegexp,\n\n  /**\n   * Copy an object keys into another one\n   *\n   * @param {Object} source source object\n   * @param {Object} dest destination object\n   * @private\n   */\n  copy: function (source, dest) {\n    Object.keys(source).forEach(function (key) {\n      dest[key] = source[key];\n    });\n  },\n\n  /**\n   * Create an argument list\n   *\n   * Returns a function that adds new arguments to the list.\n   * It also has the following methods:\n   * - clear() empties the argument list\n   * - get() returns the argument list\n   * - find(arg, count) finds 'arg' in the list and return the following 'count' items, or undefined if not found\n   * - remove(arg, count) remove 'arg' in the list as well as the following 'count' items\n   *\n   * @private\n   */\n  args: function () {\n    var list = []; // Append argument(s) to the list\n\n    var argfunc = function () {\n      if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        list = list.concat(arguments[0]);\n      } else {\n        list = list.concat([].slice.call(arguments));\n      }\n    }; // Clear argument list\n\n\n    argfunc.clear = function () {\n      list = [];\n    }; // Return argument list\n\n\n    argfunc.get = function () {\n      return list;\n    }; // Find argument 'arg' in list, and if found, return an array of the 'count' items that follow it\n\n\n    argfunc.find = function (arg, count) {\n      var index = list.indexOf(arg);\n\n      if (index !== -1) {\n        return list.slice(index + 1, index + 1 + (count || 0));\n      }\n    }; // Find argument 'arg' in list, and if found, remove it as well as the 'count' items that follow it\n\n\n    argfunc.remove = function (arg, count) {\n      var index = list.indexOf(arg);\n\n      if (index !== -1) {\n        list.splice(index, (count || 0) + 1);\n      }\n    }; // Clone argument list\n\n\n    argfunc.clone = function () {\n      var cloned = utils.args();\n      cloned(list);\n      return cloned;\n    };\n\n    return argfunc;\n  },\n\n  /**\n   * Generate filter strings\n   *\n   * @param {String[]|Object[]} filters filter specifications. When using objects,\n   *   each must have the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|Array} [filters.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [filters.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [filters.options] filter options, can be omitted to not set any options\n   * @return String[]\n   * @private\n   */\n  makeFilterStrings: function (filters) {\n    return filters.map(function (filterSpec) {\n      if (typeof filterSpec === 'string') {\n        return filterSpec;\n      }\n\n      var filterString = ''; // Filter string format is:\n      // [input1][input2]...filter[output1][output2]...\n      // The 'filter' part can optionaly have arguments:\n      //   filter=arg1:arg2:arg3\n      //   filter=arg1=v1:arg2=v2:arg3=v3\n      // Add inputs\n\n      if (Array.isArray(filterSpec.inputs)) {\n        filterString += filterSpec.inputs.map(function (streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.inputs === 'string') {\n        filterString += filterSpec.inputs.replace(streamRegexp, '[$1]');\n      } // Add filter\n\n\n      filterString += filterSpec.filter; // Add options\n\n      if (filterSpec.options) {\n        if (typeof filterSpec.options === 'string' || typeof filterSpec.options === 'number') {\n          // Option string\n          filterString += '=' + filterSpec.options;\n        } else if (Array.isArray(filterSpec.options)) {\n          // Option array (unnamed options)\n          filterString += '=' + filterSpec.options.map(function (option) {\n            if (typeof option === 'string' && option.match(filterEscapeRegexp)) {\n              return '\\'' + option + '\\'';\n            } else {\n              return option;\n            }\n          }).join(':');\n        } else if (Object.keys(filterSpec.options).length) {\n          // Option object (named options)\n          filterString += '=' + Object.keys(filterSpec.options).map(function (option) {\n            var value = filterSpec.options[option];\n\n            if (typeof value === 'string' && value.match(filterEscapeRegexp)) {\n              value = '\\'' + value + '\\'';\n            }\n\n            return option + '=' + value;\n          }).join(':');\n        }\n      } // Add outputs\n\n\n      if (Array.isArray(filterSpec.outputs)) {\n        filterString += filterSpec.outputs.map(function (streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.outputs === 'string') {\n        filterString += filterSpec.outputs.replace(streamRegexp, '[$1]');\n      }\n\n      return filterString;\n    });\n  },\n\n  /**\n   * Search for an executable\n   *\n   * Uses 'which' or 'where' depending on platform\n   *\n   * @param {String} name executable name\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  which: function (name, callback) {\n    if (name in whichCache) {\n      return callback(null, whichCache[name]);\n    }\n\n    which(name, function (err, result) {\n      if (err) {\n        // Treat errors as not found\n        return callback(null, whichCache[name] = '');\n      }\n\n      callback(null, whichCache[name] = result);\n    });\n  },\n\n  /**\n   * Convert a [[hh:]mm:]ss[.xxx] timemark into seconds\n   *\n   * @param {String} timemark timemark string\n   * @return Number\n   * @private\n   */\n  timemarkToSeconds: function (timemark) {\n    if (typeof timemark === 'number') {\n      return timemark;\n    }\n\n    if (timemark.indexOf(':') === -1 && timemark.indexOf('.') >= 0) {\n      return Number(timemark);\n    }\n\n    var parts = timemark.split(':'); // add seconds\n\n    var secs = Number(parts.pop());\n\n    if (parts.length) {\n      // add minutes\n      secs += Number(parts.pop()) * 60;\n    }\n\n    if (parts.length) {\n      // add hours\n      secs += Number(parts.pop()) * 3600;\n    }\n\n    return secs;\n  },\n\n  /**\n   * Extract codec data from ffmpeg stderr and emit 'codecData' event if appropriate\n   * Call it with an initially empty codec object once with each line of stderr output until it returns true\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr output line\n   * @param {Object} codecObject object used to accumulate codec data between calls\n   * @return {Boolean} true if codec data is complete (and event was emitted), false otherwise\n   * @private\n   */\n  extractCodecData: function (command, stderrLine, codecsObject) {\n    var inputPattern = /Input #[0-9]+, ([^ ]+),/;\n    var durPattern = /Duration\\: ([^,]+)/;\n    var audioPattern = /Audio\\: (.*)/;\n    var videoPattern = /Video\\: (.*)/;\n\n    if (!('inputStack' in codecsObject)) {\n      codecsObject.inputStack = [];\n      codecsObject.inputIndex = -1;\n      codecsObject.inInput = false;\n    }\n\n    var inputStack = codecsObject.inputStack;\n    var inputIndex = codecsObject.inputIndex;\n    var inInput = codecsObject.inInput;\n    var format, dur, audio, video;\n\n    if (format = stderrLine.match(inputPattern)) {\n      inInput = codecsObject.inInput = true;\n      inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;\n      inputStack[inputIndex] = {\n        format: format[1],\n        audio: '',\n        video: '',\n        duration: ''\n      };\n    } else if (inInput && (dur = stderrLine.match(durPattern))) {\n      inputStack[inputIndex].duration = dur[1];\n    } else if (inInput && (audio = stderrLine.match(audioPattern))) {\n      audio = audio[1].split(', ');\n      inputStack[inputIndex].audio = audio[0];\n      inputStack[inputIndex].audio_details = audio;\n    } else if (inInput && (video = stderrLine.match(videoPattern))) {\n      video = video[1].split(', ');\n      inputStack[inputIndex].video = video[0];\n      inputStack[inputIndex].video_details = video;\n    } else if (/Output #\\d+/.test(stderrLine)) {\n      inInput = codecsObject.inInput = false;\n    } else if (/Stream mapping:|Press (\\[q\\]|ctrl-c) to stop/.test(stderrLine)) {\n      command.emit.apply(command, ['codecData'].concat(inputStack));\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Extract progress data from ffmpeg stderr and emit 'progress' event if appropriate\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr data\n   * @private\n   */\n  extractProgress: function (command, stderrLine) {\n    var progress = parseProgressLine(stderrLine);\n\n    if (progress) {\n      // build progress report object\n      var ret = {\n        frames: parseInt(progress.frame, 10),\n        currentFps: parseInt(progress.fps, 10),\n        currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace('kbits/s', '')) : 0,\n        targetSize: parseInt(progress.size || progress.Lsize, 10),\n        timemark: progress.time\n      }; // calculate percent progress using duration\n\n      if (command._ffprobeData && command._ffprobeData.format && command._ffprobeData.format.duration) {\n        var duration = Number(command._ffprobeData.format.duration);\n        if (!isNaN(duration)) ret.percent = utils.timemarkToSeconds(ret.timemark) / duration * 100;\n      }\n\n      command.emit('progress', ret);\n    }\n  },\n\n  /**\n   * Extract error message(s) from ffmpeg stderr\n   *\n   * @param {String} stderr ffmpeg stderr data\n   * @return {String}\n   * @private\n   */\n  extractError: function (stderr) {\n    // Only return the last stderr lines that don't start with a space or a square bracket\n    return stderr.split(nlRegexp).reduce(function (messages, message) {\n      if (message.charAt(0) === ' ' || message.charAt(0) === '[') {\n        return [];\n      } else {\n        messages.push(message);\n        return messages;\n      }\n    }, []).join('\\n');\n  },\n\n  /**\n   * Creates a line ring buffer object with the following methods:\n   * - append(str) : appends a string or buffer\n   * - get() : returns the whole string\n   * - close() : prevents further append() calls and does a last call to callbacks\n   * - callback(cb) : calls cb for each line (incl. those already in the ring)\n   *\n   * @param {Numebr} maxLines maximum number of lines to store (<= 0 for unlimited)\n   */\n  linesRing: function (maxLines) {\n    var cbs = [];\n    var lines = [];\n    var current = null;\n    var closed = false;\n    var max = maxLines - 1;\n\n    function emit(line) {\n      cbs.forEach(function (cb) {\n        cb(line);\n      });\n    }\n\n    return {\n      callback: function (cb) {\n        lines.forEach(function (l) {\n          cb(l);\n        });\n        cbs.push(cb);\n      },\n      append: function (str) {\n        if (closed) return;\n        if (str instanceof Buffer) str = '' + str;\n        if (!str || str.length === 0) return;\n        var newLines = str.split(nlRegexp);\n\n        if (newLines.length === 1) {\n          if (current !== null) {\n            current = current + newLines.shift();\n          } else {\n            current = newLines.shift();\n          }\n        } else {\n          if (current !== null) {\n            current = current + newLines.shift();\n            emit(current);\n            lines.push(current);\n          }\n\n          current = newLines.pop();\n          newLines.forEach(function (l) {\n            emit(l);\n            lines.push(l);\n          });\n\n          if (max > -1 && lines.length > max) {\n            lines.splice(0, lines.length - max);\n          }\n        }\n      },\n      get: function () {\n        if (current !== null) {\n          return lines.concat([current]).join('\\n');\n        } else {\n          return lines.join('\\n');\n        }\n      },\n      close: function () {\n        if (closed) return;\n\n        if (current !== null) {\n          emit(current);\n          lines.push(current);\n\n          if (max > -1 && lines.length > max) {\n            lines.shift();\n          }\n\n          current = null;\n        }\n\n        closed = true;\n      }\n    };\n  }\n};","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/fluent-ffmpeg/lib/utils.js"],"names":["exec","require","isWindows","platform","match","which","nlRegexp","streamRegexp","filterEscapeRegexp","whichCache","parseProgressLine","line","progress","replace","trim","progressParts","split","i","length","progressSplit","key","value","utils","module","exports","copy","source","dest","Object","keys","forEach","args","list","argfunc","arguments","Array","isArray","concat","slice","call","clear","get","find","arg","count","index","indexOf","remove","splice","clone","cloned","makeFilterStrings","filters","map","filterSpec","filterString","inputs","streamSpec","join","filter","options","option","outputs","name","callback","err","result","timemarkToSeconds","timemark","Number","parts","secs","pop","extractCodecData","command","stderrLine","codecsObject","inputPattern","durPattern","audioPattern","videoPattern","inputStack","inputIndex","inInput","format","dur","audio","video","duration","audio_details","video_details","test","emit","apply","extractProgress","ret","frames","parseInt","frame","currentFps","fps","currentKbps","bitrate","parseFloat","targetSize","size","Lsize","time","_ffprobeData","isNaN","percent","extractError","stderr","reduce","messages","message","charAt","push","linesRing","maxLines","cbs","lines","current","closed","max","cb","l","append","str","Buffer","newLines","shift","close"],"mappings":"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","sourcesContent":["/*jshint node:true*/\n'use strict';\n\nvar exec = require('child_process').exec;\nvar isWindows = require('os').platform().match(/win(32|64)/);\nvar which = require('which');\n\nvar nlRegexp = /\\r\\n|\\r|\\n/g;\nvar streamRegexp = /^\\[?(.*?)\\]?$/;\nvar filterEscapeRegexp = /[,]/;\nvar whichCache = {};\n\n/**\n * Parse progress line from ffmpeg stderr\n *\n * @param {String} line progress line\n * @return progress object\n * @private\n */\nfunction parseProgressLine(line) {\n  var progress = {};\n\n  // Remove all spaces after = and trim\n  line  = line.replace(/=\\s+/g, '=').trim();\n  var progressParts = line.split(' ');\n\n  // Split every progress part by \"=\" to get key and value\n  for(var i = 0; i < progressParts.length; i++) {\n    var progressSplit = progressParts[i].split('=', 2);\n    var key = progressSplit[0];\n    var value = progressSplit[1];\n\n    // This is not a progress line\n    if(typeof value === 'undefined')\n      return null;\n\n    progress[key] = value;\n  }\n\n  return progress;\n}\n\n\nvar utils = module.exports = {\n  isWindows: isWindows,\n  streamRegexp: streamRegexp,\n\n\n  /**\n   * Copy an object keys into another one\n   *\n   * @param {Object} source source object\n   * @param {Object} dest destination object\n   * @private\n   */\n  copy: function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n      dest[key] = source[key];\n    });\n  },\n\n\n  /**\n   * Create an argument list\n   *\n   * Returns a function that adds new arguments to the list.\n   * It also has the following methods:\n   * - clear() empties the argument list\n   * - get() returns the argument list\n   * - find(arg, count) finds 'arg' in the list and return the following 'count' items, or undefined if not found\n   * - remove(arg, count) remove 'arg' in the list as well as the following 'count' items\n   *\n   * @private\n   */\n  args: function() {\n    var list = [];\n\n    // Append argument(s) to the list\n    var argfunc = function() {\n      if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        list = list.concat(arguments[0]);\n      } else {\n        list = list.concat([].slice.call(arguments));\n      }\n    };\n\n    // Clear argument list\n    argfunc.clear = function() {\n      list = [];\n    };\n\n    // Return argument list\n    argfunc.get = function() {\n      return list;\n    };\n\n    // Find argument 'arg' in list, and if found, return an array of the 'count' items that follow it\n    argfunc.find = function(arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        return list.slice(index + 1, index + 1 + (count || 0));\n      }\n    };\n\n    // Find argument 'arg' in list, and if found, remove it as well as the 'count' items that follow it\n    argfunc.remove = function(arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        list.splice(index, (count || 0) + 1);\n      }\n    };\n\n    // Clone argument list\n    argfunc.clone = function() {\n      var cloned = utils.args();\n      cloned(list);\n      return cloned;\n    };\n\n    return argfunc;\n  },\n\n\n  /**\n   * Generate filter strings\n   *\n   * @param {String[]|Object[]} filters filter specifications. When using objects,\n   *   each must have the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|Array} [filters.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [filters.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [filters.options] filter options, can be omitted to not set any options\n   * @return String[]\n   * @private\n   */\n  makeFilterStrings: function(filters) {\n    return filters.map(function(filterSpec) {\n      if (typeof filterSpec === 'string') {\n        return filterSpec;\n      }\n\n      var filterString = '';\n\n      // Filter string format is:\n      // [input1][input2]...filter[output1][output2]...\n      // The 'filter' part can optionaly have arguments:\n      //   filter=arg1:arg2:arg3\n      //   filter=arg1=v1:arg2=v2:arg3=v3\n\n      // Add inputs\n      if (Array.isArray(filterSpec.inputs)) {\n        filterString += filterSpec.inputs.map(function(streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.inputs === 'string') {\n        filterString += filterSpec.inputs.replace(streamRegexp, '[$1]');\n      }\n\n      // Add filter\n      filterString += filterSpec.filter;\n\n      // Add options\n      if (filterSpec.options) {\n        if (typeof filterSpec.options === 'string' || typeof filterSpec.options === 'number') {\n          // Option string\n          filterString += '=' + filterSpec.options;\n        } else if (Array.isArray(filterSpec.options)) {\n          // Option array (unnamed options)\n          filterString += '=' + filterSpec.options.map(function(option) {\n            if (typeof option === 'string' && option.match(filterEscapeRegexp)) {\n              return '\\'' + option + '\\'';\n            } else {\n              return option;\n            }\n          }).join(':');\n        } else if (Object.keys(filterSpec.options).length) {\n          // Option object (named options)\n          filterString += '=' + Object.keys(filterSpec.options).map(function(option) {\n            var value = filterSpec.options[option];\n\n            if (typeof value === 'string' && value.match(filterEscapeRegexp)) {\n              value = '\\'' + value + '\\'';\n            }\n\n            return option + '=' + value;\n          }).join(':');\n        }\n      }\n\n      // Add outputs\n      if (Array.isArray(filterSpec.outputs)) {\n        filterString += filterSpec.outputs.map(function(streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.outputs === 'string') {\n        filterString += filterSpec.outputs.replace(streamRegexp, '[$1]');\n      }\n\n      return filterString;\n    });\n  },\n\n\n  /**\n   * Search for an executable\n   *\n   * Uses 'which' or 'where' depending on platform\n   *\n   * @param {String} name executable name\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  which: function(name, callback) {\n    if (name in whichCache) {\n      return callback(null, whichCache[name]);\n    }\n\n    which(name, function(err, result){\n      if (err) {\n        // Treat errors as not found\n        return callback(null, whichCache[name] = '');\n      }\n      callback(null, whichCache[name] = result);\n    });\n  },\n\n\n  /**\n   * Convert a [[hh:]mm:]ss[.xxx] timemark into seconds\n   *\n   * @param {String} timemark timemark string\n   * @return Number\n   * @private\n   */\n  timemarkToSeconds: function(timemark) {\n    if (typeof timemark === 'number') {\n      return timemark;\n    }\n\n    if (timemark.indexOf(':') === -1 && timemark.indexOf('.') >= 0) {\n      return Number(timemark);\n    }\n\n    var parts = timemark.split(':');\n\n    // add seconds\n    var secs = Number(parts.pop());\n\n    if (parts.length) {\n      // add minutes\n      secs += Number(parts.pop()) * 60;\n    }\n\n    if (parts.length) {\n      // add hours\n      secs += Number(parts.pop()) * 3600;\n    }\n\n    return secs;\n  },\n\n\n  /**\n   * Extract codec data from ffmpeg stderr and emit 'codecData' event if appropriate\n   * Call it with an initially empty codec object once with each line of stderr output until it returns true\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr output line\n   * @param {Object} codecObject object used to accumulate codec data between calls\n   * @return {Boolean} true if codec data is complete (and event was emitted), false otherwise\n   * @private\n   */\n  extractCodecData: function(command, stderrLine, codecsObject) {\n    var inputPattern = /Input #[0-9]+, ([^ ]+),/;\n    var durPattern = /Duration\\: ([^,]+)/;\n    var audioPattern = /Audio\\: (.*)/;\n    var videoPattern = /Video\\: (.*)/;\n\n    if (!('inputStack' in codecsObject)) {\n      codecsObject.inputStack = [];\n      codecsObject.inputIndex = -1;\n      codecsObject.inInput = false;\n    }\n\n    var inputStack = codecsObject.inputStack;\n    var inputIndex = codecsObject.inputIndex;\n    var inInput = codecsObject.inInput;\n\n    var format, dur, audio, video;\n\n    if (format = stderrLine.match(inputPattern)) {\n      inInput = codecsObject.inInput = true;\n      inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;\n\n      inputStack[inputIndex] = { format: format[1], audio: '', video: '', duration: '' };\n    } else if (inInput && (dur = stderrLine.match(durPattern))) {\n      inputStack[inputIndex].duration = dur[1];\n    } else if (inInput && (audio = stderrLine.match(audioPattern))) {\n      audio = audio[1].split(', ');\n      inputStack[inputIndex].audio = audio[0];\n      inputStack[inputIndex].audio_details = audio;\n    } else if (inInput && (video = stderrLine.match(videoPattern))) {\n      video = video[1].split(', ');\n      inputStack[inputIndex].video = video[0];\n      inputStack[inputIndex].video_details = video;\n    } else if (/Output #\\d+/.test(stderrLine)) {\n      inInput = codecsObject.inInput = false;\n    } else if (/Stream mapping:|Press (\\[q\\]|ctrl-c) to stop/.test(stderrLine)) {\n      command.emit.apply(command, ['codecData'].concat(inputStack));\n      return true;\n    }\n\n    return false;\n  },\n\n\n  /**\n   * Extract progress data from ffmpeg stderr and emit 'progress' event if appropriate\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr data\n   * @private\n   */\n  extractProgress: function(command, stderrLine) {\n    var progress = parseProgressLine(stderrLine);\n\n    if (progress) {\n      // build progress report object\n      var ret = {\n        frames: parseInt(progress.frame, 10),\n        currentFps: parseInt(progress.fps, 10),\n        currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace('kbits/s', '')) : 0,\n        targetSize: parseInt(progress.size || progress.Lsize, 10),\n        timemark: progress.time\n      };\n\n      // calculate percent progress using duration\n      if (command._ffprobeData && command._ffprobeData.format && command._ffprobeData.format.duration) {\n        var duration = Number(command._ffprobeData.format.duration);\n        if (!isNaN(duration))\n          ret.percent = (utils.timemarkToSeconds(ret.timemark) / duration) * 100;\n      }\n      command.emit('progress', ret);\n    }\n  },\n\n\n  /**\n   * Extract error message(s) from ffmpeg stderr\n   *\n   * @param {String} stderr ffmpeg stderr data\n   * @return {String}\n   * @private\n   */\n  extractError: function(stderr) {\n    // Only return the last stderr lines that don't start with a space or a square bracket\n    return stderr.split(nlRegexp).reduce(function(messages, message) {\n      if (message.charAt(0) === ' ' || message.charAt(0) === '[') {\n        return [];\n      } else {\n        messages.push(message);\n        return messages;\n      }\n    }, []).join('\\n');\n  },\n\n\n  /**\n   * Creates a line ring buffer object with the following methods:\n   * - append(str) : appends a string or buffer\n   * - get() : returns the whole string\n   * - close() : prevents further append() calls and does a last call to callbacks\n   * - callback(cb) : calls cb for each line (incl. those already in the ring)\n   *\n   * @param {Numebr} maxLines maximum number of lines to store (<= 0 for unlimited)\n   */\n  linesRing: function(maxLines) {\n    var cbs = [];\n    var lines = [];\n    var current = null;\n    var closed = false\n    var max = maxLines - 1;\n\n    function emit(line) {\n      cbs.forEach(function(cb) { cb(line); });\n    }\n\n    return {\n      callback: function(cb) {\n        lines.forEach(function(l) { cb(l); });\n        cbs.push(cb);\n      },\n\n      append: function(str) {\n        if (closed) return;\n        if (str instanceof Buffer) str = '' + str;\n        if (!str || str.length === 0) return;\n\n        var newLines = str.split(nlRegexp);\n\n        if (newLines.length === 1) {\n          if (current !== null) {\n            current = current + newLines.shift();\n          } else {\n            current = newLines.shift();\n          }\n        } else {\n          if (current !== null) {\n            current = current + newLines.shift();\n            emit(current);\n            lines.push(current);\n          }\n\n          current = newLines.pop();\n\n          newLines.forEach(function(l) {\n            emit(l);\n            lines.push(l);\n          });\n\n          if (max > -1 && lines.length > max) {\n            lines.splice(0, lines.length - max);\n          }\n        }\n      },\n\n      get: function() {\n        if (current !== null) {\n          return lines.concat([current]).join('\\n');\n        } else {\n          return lines.join('\\n');\n        }\n      },\n\n      close: function() {\n        if (closed) return;\n\n        if (current !== null) {\n          emit(current);\n          lines.push(current);\n\n          if (max > -1 && lines.length > max) {\n            lines.shift();\n          }\n\n          current = null;\n        }\n\n        closed = true;\n      }\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"script"}