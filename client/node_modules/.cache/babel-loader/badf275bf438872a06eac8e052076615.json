{"ast":null,"code":"/*jshint node:true, laxcomma:true*/\n'use strict';\n\nvar spawn = require('child_process').spawn;\n\nfunction legacyTag(key) {\n  return key.match(/^TAG:/);\n}\n\nfunction legacyDisposition(key) {\n  return key.match(/^DISPOSITION:/);\n}\n\nfunction parseFfprobeOutput(out) {\n  var lines = out.split(/\\r\\n|\\r|\\n/);\n  lines = lines.filter(function (line) {\n    return line.length > 0;\n  });\n  var data = {\n    streams: [],\n    format: {},\n    chapters: []\n  };\n\n  function parseBlock(name) {\n    var data = {};\n    var line = lines.shift();\n\n    while (typeof line !== 'undefined') {\n      if (line.toLowerCase() == '[/' + name + ']') {\n        return data;\n      } else if (line.match(/^\\[/)) {\n        line = lines.shift();\n        continue;\n      }\n\n      var kv = line.match(/^([^=]+)=(.*)$/);\n\n      if (kv) {\n        if (!kv[1].match(/^TAG:/) && kv[2].match(/^[0-9]+(\\.[0-9]+)?$/)) {\n          data[kv[1]] = Number(kv[2]);\n        } else {\n          data[kv[1]] = kv[2];\n        }\n      }\n\n      line = lines.shift();\n    }\n\n    return data;\n  }\n\n  var line = lines.shift();\n\n  while (typeof line !== 'undefined') {\n    if (line.match(/^\\[stream/i)) {\n      var stream = parseBlock('stream');\n      data.streams.push(stream);\n    } else if (line.match(/^\\[chapter/i)) {\n      var chapter = parseBlock('chapter');\n      data.chapters.push(chapter);\n    } else if (line.toLowerCase() === '[format]') {\n      data.format = parseBlock('format');\n    }\n\n    line = lines.shift();\n  }\n\n  return data;\n}\n\nmodule.exports = function (proto) {\n  /**\n   * A callback passed to the {@link FfmpegCommand#ffprobe} method.\n   *\n   * @callback FfmpegCommand~ffprobeCallback\n   *\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} ffprobeData ffprobe output data; this object\n   *   has the same format as what the following command returns:\n   *\n   *     `ffprobe -print_format json -show_streams -show_format INPUTFILE`\n   * @param {Array} ffprobeData.streams stream information\n   * @param {Object} ffprobeData.format format information\n   */\n\n  /**\n   * Run ffprobe on last specified input\n   *\n   * @method FfmpegCommand#ffprobe\n   * @category Metadata\n   *\n   * @param {?Number} [index] 0-based index of input to probe (defaults to last input)\n   * @param {?String[]} [options] array of output options to return\n   * @param {FfmpegCommand~ffprobeCallback} callback callback function\n   *\n   */\n  proto.ffprobe = function () {\n    var input,\n        index = null,\n        options = [],\n        callback; // the last argument should be the callback\n\n    var callback = arguments[arguments.length - 1];\n    var ended = false;\n\n    function handleCallback(err, data) {\n      if (!ended) {\n        ended = true;\n        callback(err, data);\n      }\n    }\n\n    ; // map the arguments to the correct variable names\n\n    switch (arguments.length) {\n      case 3:\n        index = arguments[0];\n        options = arguments[1];\n        break;\n\n      case 2:\n        if (typeof arguments[0] === 'number') {\n          index = arguments[0];\n        } else if (Array.isArray(arguments[0])) {\n          options = arguments[0];\n        }\n\n        break;\n    }\n\n    if (index === null) {\n      if (!this._currentInput) {\n        return handleCallback(new Error('No input specified'));\n      }\n\n      input = this._currentInput;\n    } else {\n      input = this._inputs[index];\n\n      if (!input) {\n        return handleCallback(new Error('Invalid input index'));\n      }\n    } // Find ffprobe\n\n\n    this._getFfprobePath(function (err, path) {\n      if (err) {\n        return handleCallback(err);\n      } else if (!path) {\n        return handleCallback(new Error('Cannot find ffprobe'));\n      }\n\n      var stdout = '';\n      var stdoutClosed = false;\n      var stderr = '';\n      var stderrClosed = false; // Spawn ffprobe\n\n      var src = input.isStream ? 'pipe:0' : input.source;\n      var ffprobe = spawn(path, ['-show_streams', '-show_format'].concat(options, src));\n\n      if (input.isStream) {\n        // Skip errors on stdin. These get thrown when ffprobe is complete and\n        // there seems to be no way hook in and close stdin before it throws.\n        ffprobe.stdin.on('error', function (err) {\n          if (['ECONNRESET', 'EPIPE'].indexOf(err.code) >= 0) {\n            return;\n          }\n\n          handleCallback(err);\n        }); // Once ffprobe's input stream closes, we need no more data from the\n        // input\n\n        ffprobe.stdin.on('close', function () {\n          input.source.pause();\n          input.source.unpipe(ffprobe.stdin);\n        });\n        input.source.pipe(ffprobe.stdin);\n      }\n\n      ffprobe.on('error', callback); // Ensure we wait for captured streams to end before calling callback\n\n      var exitError = null;\n\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && stdoutClosed && stderrClosed) {\n          if (exitError) {\n            if (stderr) {\n              exitError.message += '\\n' + stderr;\n            }\n\n            return handleCallback(exitError);\n          } // Process output\n\n\n          var data = parseFfprobeOutput(stdout); // Handle legacy output with \"TAG:x\" and \"DISPOSITION:x\" keys\n\n          [data.format].concat(data.streams).forEach(function (target) {\n            if (target) {\n              var legacyTagKeys = Object.keys(target).filter(legacyTag);\n\n              if (legacyTagKeys.length) {\n                target.tags = target.tags || {};\n                legacyTagKeys.forEach(function (tagKey) {\n                  target.tags[tagKey.substr(4)] = target[tagKey];\n                  delete target[tagKey];\n                });\n              }\n\n              var legacyDispositionKeys = Object.keys(target).filter(legacyDisposition);\n\n              if (legacyDispositionKeys.length) {\n                target.disposition = target.disposition || {};\n                legacyDispositionKeys.forEach(function (dispositionKey) {\n                  target.disposition[dispositionKey.substr(12)] = target[dispositionKey];\n                  delete target[dispositionKey];\n                });\n              }\n            }\n          });\n          handleCallback(null, data);\n        }\n      } // Handle ffprobe exit\n\n\n      var processExited = false;\n      ffprobe.on('exit', function (code, signal) {\n        processExited = true;\n\n        if (code) {\n          handleExit(new Error('ffprobe exited with code ' + code));\n        } else if (signal) {\n          handleExit(new Error('ffprobe was killed with signal ' + signal));\n        } else {\n          handleExit();\n        }\n      }); // Handle stdout/stderr streams\n\n      ffprobe.stdout.on('data', function (data) {\n        stdout += data;\n      });\n      ffprobe.stdout.on('close', function () {\n        stdoutClosed = true;\n        handleExit();\n      });\n      ffprobe.stderr.on('data', function (data) {\n        stderr += data;\n      });\n      ffprobe.stderr.on('close', function () {\n        stderrClosed = true;\n        handleExit();\n      });\n    });\n  };\n};","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/fluent-ffmpeg/lib/ffprobe.js"],"names":["spawn","require","legacyTag","key","match","legacyDisposition","parseFfprobeOutput","out","lines","split","filter","line","length","data","streams","format","chapters","parseBlock","name","shift","toLowerCase","kv","Number","stream","push","chapter","module","exports","proto","ffprobe","input","index","options","callback","arguments","ended","handleCallback","err","Array","isArray","_currentInput","Error","_inputs","_getFfprobePath","path","stdout","stdoutClosed","stderr","stderrClosed","src","isStream","source","concat","stdin","on","indexOf","code","pause","unpipe","pipe","exitError","handleExit","processExited","message","forEach","target","legacyTagKeys","Object","keys","tags","tagKey","substr","legacyDispositionKeys","disposition","dispositionKey","signal"],"mappings":"AAAA;AACA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,eAAD,CAAP,CAAyBD,KAArC;;AAGA,SAASE,SAAT,CAAmBC,GAAnB,EAAwB;AAAE,SAAOA,GAAG,CAACC,KAAJ,CAAU,OAAV,CAAP;AAA4B;;AACtD,SAASC,iBAAT,CAA2BF,GAA3B,EAAgC;AAAE,SAAOA,GAAG,CAACC,KAAJ,CAAU,eAAV,CAAP;AAAoC;;AAEtE,SAASE,kBAAT,CAA4BC,GAA5B,EAAiC;AAC/B,MAAIC,KAAK,GAAGD,GAAG,CAACE,KAAJ,CAAU,YAAV,CAAZ;AAEAD,EAAAA,KAAK,GAAGA,KAAK,CAACE,MAAN,CAAa,UAAUC,IAAV,EAAgB;AACnC,WAAOA,IAAI,CAACC,MAAL,GAAc,CAArB;AACD,GAFO,CAAR;AAIA,MAAIC,IAAI,GAAG;AACTC,IAAAA,OAAO,EAAE,EADA;AAETC,IAAAA,MAAM,EAAE,EAFC;AAGTC,IAAAA,QAAQ,EAAE;AAHD,GAAX;;AAMA,WAASC,UAAT,CAAoBC,IAApB,EAA0B;AACxB,QAAIL,IAAI,GAAG,EAAX;AAEA,QAAIF,IAAI,GAAGH,KAAK,CAACW,KAAN,EAAX;;AACA,WAAO,OAAOR,IAAP,KAAgB,WAAvB,EAAoC;AAClC,UAAIA,IAAI,CAACS,WAAL,MAAsB,OAAKF,IAAL,GAAU,GAApC,EAAyC;AACvC,eAAOL,IAAP;AACD,OAFD,MAEO,IAAIF,IAAI,CAACP,KAAL,CAAW,KAAX,CAAJ,EAAuB;AAC5BO,QAAAA,IAAI,GAAGH,KAAK,CAACW,KAAN,EAAP;AACA;AACD;;AAED,UAAIE,EAAE,GAAGV,IAAI,CAACP,KAAL,CAAW,gBAAX,CAAT;;AACA,UAAIiB,EAAJ,EAAQ;AACN,YAAI,CAAEA,EAAE,CAAC,CAAD,CAAF,CAAMjB,KAAN,CAAY,OAAZ,CAAF,IAA2BiB,EAAE,CAAC,CAAD,CAAF,CAAMjB,KAAN,CAAY,qBAAZ,CAA/B,EAAmE;AACjES,UAAAA,IAAI,CAACQ,EAAE,CAAC,CAAD,CAAH,CAAJ,GAAcC,MAAM,CAACD,EAAE,CAAC,CAAD,CAAH,CAApB;AACD,SAFD,MAEO;AACLR,UAAAA,IAAI,CAACQ,EAAE,CAAC,CAAD,CAAH,CAAJ,GAAcA,EAAE,CAAC,CAAD,CAAhB;AACD;AACF;;AAEDV,MAAAA,IAAI,GAAGH,KAAK,CAACW,KAAN,EAAP;AACD;;AAED,WAAON,IAAP;AACD;;AAED,MAAIF,IAAI,GAAGH,KAAK,CAACW,KAAN,EAAX;;AACA,SAAO,OAAOR,IAAP,KAAgB,WAAvB,EAAoC;AAClC,QAAIA,IAAI,CAACP,KAAL,CAAW,YAAX,CAAJ,EAA8B;AAC5B,UAAImB,MAAM,GAAGN,UAAU,CAAC,QAAD,CAAvB;AACAJ,MAAAA,IAAI,CAACC,OAAL,CAAaU,IAAb,CAAkBD,MAAlB;AACD,KAHD,MAGO,IAAIZ,IAAI,CAACP,KAAL,CAAW,aAAX,CAAJ,EAA+B;AACpC,UAAIqB,OAAO,GAAGR,UAAU,CAAC,SAAD,CAAxB;AACAJ,MAAAA,IAAI,CAACG,QAAL,CAAcQ,IAAd,CAAmBC,OAAnB;AACD,KAHM,MAGA,IAAId,IAAI,CAACS,WAAL,OAAuB,UAA3B,EAAuC;AAC5CP,MAAAA,IAAI,CAACE,MAAL,GAAcE,UAAU,CAAC,QAAD,CAAxB;AACD;;AAEDN,IAAAA,IAAI,GAAGH,KAAK,CAACW,KAAN,EAAP;AACD;;AAED,SAAON,IAAP;AACD;;AAIDa,MAAM,CAACC,OAAP,GAAiB,UAASC,KAAT,EAAgB;AAC/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEA,EAAAA,KAAK,CAACC,OAAN,GAAgB,YAAW;AACzB,QAAIC,KAAJ;AAAA,QAAWC,KAAK,GAAG,IAAnB;AAAA,QAAyBC,OAAO,GAAG,EAAnC;AAAA,QAAuCC,QAAvC,CADyB,CAGzB;;AACA,QAAIA,QAAQ,GAAGC,SAAS,CAACA,SAAS,CAACtB,MAAV,GAAmB,CAApB,CAAxB;AAEA,QAAIuB,KAAK,GAAG,KAAZ;;AACA,aAASC,cAAT,CAAwBC,GAAxB,EAA6BxB,IAA7B,EAAmC;AACjC,UAAI,CAACsB,KAAL,EAAY;AACVA,QAAAA,KAAK,GAAG,IAAR;AACAF,QAAAA,QAAQ,CAACI,GAAD,EAAMxB,IAAN,CAAR;AACD;AACF;;AAAA,KAZwB,CAczB;;AACA,YAAQqB,SAAS,CAACtB,MAAlB;AACE,WAAK,CAAL;AACEmB,QAAAA,KAAK,GAAGG,SAAS,CAAC,CAAD,CAAjB;AACAF,QAAAA,OAAO,GAAGE,SAAS,CAAC,CAAD,CAAnB;AACA;;AACF,WAAK,CAAL;AACE,YAAI,OAAOA,SAAS,CAAC,CAAD,CAAhB,KAAwB,QAA5B,EAAsC;AACpCH,UAAAA,KAAK,GAAGG,SAAS,CAAC,CAAD,CAAjB;AACD,SAFD,MAEO,IAAII,KAAK,CAACC,OAAN,CAAcL,SAAS,CAAC,CAAD,CAAvB,CAAJ,EAAiC;AACtCF,UAAAA,OAAO,GAAGE,SAAS,CAAC,CAAD,CAAnB;AACD;;AACD;AAXJ;;AAeA,QAAIH,KAAK,KAAK,IAAd,EAAoB;AAClB,UAAI,CAAC,KAAKS,aAAV,EAAyB;AACvB,eAAOJ,cAAc,CAAC,IAAIK,KAAJ,CAAU,oBAAV,CAAD,CAArB;AACD;;AAEDX,MAAAA,KAAK,GAAG,KAAKU,aAAb;AACD,KAND,MAMO;AACLV,MAAAA,KAAK,GAAG,KAAKY,OAAL,CAAaX,KAAb,CAAR;;AAEA,UAAI,CAACD,KAAL,EAAY;AACV,eAAOM,cAAc,CAAC,IAAIK,KAAJ,CAAU,qBAAV,CAAD,CAArB;AACD;AACF,KA1CwB,CA4CzB;;;AACA,SAAKE,eAAL,CAAqB,UAASN,GAAT,EAAcO,IAAd,EAAoB;AACvC,UAAIP,GAAJ,EAAS;AACP,eAAOD,cAAc,CAACC,GAAD,CAArB;AACD,OAFD,MAEO,IAAI,CAACO,IAAL,EAAW;AAChB,eAAOR,cAAc,CAAC,IAAIK,KAAJ,CAAU,qBAAV,CAAD,CAArB;AACD;;AAED,UAAII,MAAM,GAAG,EAAb;AACA,UAAIC,YAAY,GAAG,KAAnB;AACA,UAAIC,MAAM,GAAG,EAAb;AACA,UAAIC,YAAY,GAAG,KAAnB,CAVuC,CAYvC;;AACA,UAAIC,GAAG,GAAGnB,KAAK,CAACoB,QAAN,GAAiB,QAAjB,GAA4BpB,KAAK,CAACqB,MAA5C;AACA,UAAItB,OAAO,GAAG7B,KAAK,CAAC4C,IAAD,EAAO,CAAC,eAAD,EAAkB,cAAlB,EAAkCQ,MAAlC,CAAyCpB,OAAzC,EAAkDiB,GAAlD,CAAP,CAAnB;;AAEA,UAAInB,KAAK,CAACoB,QAAV,EAAoB;AAClB;AACA;AACArB,QAAAA,OAAO,CAACwB,KAAR,CAAcC,EAAd,CAAiB,OAAjB,EAA0B,UAASjB,GAAT,EAAc;AACtC,cAAI,CAAC,YAAD,EAAe,OAAf,EAAwBkB,OAAxB,CAAgClB,GAAG,CAACmB,IAApC,KAA6C,CAAjD,EAAoD;AAAE;AAAS;;AAC/DpB,UAAAA,cAAc,CAACC,GAAD,CAAd;AACD,SAHD,EAHkB,CAQlB;AACA;;AACAR,QAAAA,OAAO,CAACwB,KAAR,CAAcC,EAAd,CAAiB,OAAjB,EAA0B,YAAW;AACjCxB,UAAAA,KAAK,CAACqB,MAAN,CAAaM,KAAb;AACA3B,UAAAA,KAAK,CAACqB,MAAN,CAAaO,MAAb,CAAoB7B,OAAO,CAACwB,KAA5B;AACH,SAHD;AAKAvB,QAAAA,KAAK,CAACqB,MAAN,CAAaQ,IAAb,CAAkB9B,OAAO,CAACwB,KAA1B;AACD;;AAEDxB,MAAAA,OAAO,CAACyB,EAAR,CAAW,OAAX,EAAoBrB,QAApB,EAlCuC,CAoCvC;;AACA,UAAI2B,SAAS,GAAG,IAAhB;;AACA,eAASC,UAAT,CAAoBxB,GAApB,EAAyB;AACvB,YAAIA,GAAJ,EAAS;AACPuB,UAAAA,SAAS,GAAGvB,GAAZ;AACD;;AAED,YAAIyB,aAAa,IAAIhB,YAAjB,IAAiCE,YAArC,EAAmD;AACjD,cAAIY,SAAJ,EAAe;AACb,gBAAIb,MAAJ,EAAY;AACVa,cAAAA,SAAS,CAACG,OAAV,IAAqB,OAAOhB,MAA5B;AACD;;AAED,mBAAOX,cAAc,CAACwB,SAAD,CAArB;AACD,WAPgD,CASjD;;;AACA,cAAI/C,IAAI,GAAGP,kBAAkB,CAACuC,MAAD,CAA7B,CAViD,CAYjD;;AACA,WAAChC,IAAI,CAACE,MAAN,EAAcqC,MAAd,CAAqBvC,IAAI,CAACC,OAA1B,EAAmCkD,OAAnC,CAA2C,UAASC,MAAT,EAAiB;AAC1D,gBAAIA,MAAJ,EAAY;AACV,kBAAIC,aAAa,GAAGC,MAAM,CAACC,IAAP,CAAYH,MAAZ,EAAoBvD,MAApB,CAA2BR,SAA3B,CAApB;;AAEA,kBAAIgE,aAAa,CAACtD,MAAlB,EAA0B;AACxBqD,gBAAAA,MAAM,CAACI,IAAP,GAAcJ,MAAM,CAACI,IAAP,IAAe,EAA7B;AAEAH,gBAAAA,aAAa,CAACF,OAAd,CAAsB,UAASM,MAAT,EAAiB;AACrCL,kBAAAA,MAAM,CAACI,IAAP,CAAYC,MAAM,CAACC,MAAP,CAAc,CAAd,CAAZ,IAAgCN,MAAM,CAACK,MAAD,CAAtC;AACA,yBAAOL,MAAM,CAACK,MAAD,CAAb;AACD,iBAHD;AAID;;AAED,kBAAIE,qBAAqB,GAAGL,MAAM,CAACC,IAAP,CAAYH,MAAZ,EAAoBvD,MAApB,CAA2BL,iBAA3B,CAA5B;;AAEA,kBAAImE,qBAAqB,CAAC5D,MAA1B,EAAkC;AAChCqD,gBAAAA,MAAM,CAACQ,WAAP,GAAqBR,MAAM,CAACQ,WAAP,IAAsB,EAA3C;AAEAD,gBAAAA,qBAAqB,CAACR,OAAtB,CAA8B,UAASU,cAAT,EAAyB;AACrDT,kBAAAA,MAAM,CAACQ,WAAP,CAAmBC,cAAc,CAACH,MAAf,CAAsB,EAAtB,CAAnB,IAAgDN,MAAM,CAACS,cAAD,CAAtD;AACA,yBAAOT,MAAM,CAACS,cAAD,CAAb;AACD,iBAHD;AAID;AACF;AACF,WAxBD;AA0BAtC,UAAAA,cAAc,CAAC,IAAD,EAAOvB,IAAP,CAAd;AACD;AACF,OApFsC,CAsFvC;;;AACA,UAAIiD,aAAa,GAAG,KAApB;AACAjC,MAAAA,OAAO,CAACyB,EAAR,CAAW,MAAX,EAAmB,UAASE,IAAT,EAAemB,MAAf,EAAuB;AACxCb,QAAAA,aAAa,GAAG,IAAhB;;AAEA,YAAIN,IAAJ,EAAU;AACRK,UAAAA,UAAU,CAAC,IAAIpB,KAAJ,CAAU,8BAA8Be,IAAxC,CAAD,CAAV;AACD,SAFD,MAEO,IAAImB,MAAJ,EAAY;AACjBd,UAAAA,UAAU,CAAC,IAAIpB,KAAJ,CAAU,oCAAoCkC,MAA9C,CAAD,CAAV;AACD,SAFM,MAEA;AACLd,UAAAA,UAAU;AACX;AACF,OAVD,EAxFuC,CAoGvC;;AACAhC,MAAAA,OAAO,CAACgB,MAAR,CAAeS,EAAf,CAAkB,MAAlB,EAA0B,UAASzC,IAAT,EAAe;AACvCgC,QAAAA,MAAM,IAAIhC,IAAV;AACD,OAFD;AAIAgB,MAAAA,OAAO,CAACgB,MAAR,CAAeS,EAAf,CAAkB,OAAlB,EAA2B,YAAW;AACpCR,QAAAA,YAAY,GAAG,IAAf;AACAe,QAAAA,UAAU;AACX,OAHD;AAKAhC,MAAAA,OAAO,CAACkB,MAAR,CAAeO,EAAf,CAAkB,MAAlB,EAA0B,UAASzC,IAAT,EAAe;AACvCkC,QAAAA,MAAM,IAAIlC,IAAV;AACD,OAFD;AAIAgB,MAAAA,OAAO,CAACkB,MAAR,CAAeO,EAAf,CAAkB,OAAlB,EAA2B,YAAW;AACpCN,QAAAA,YAAY,GAAG,IAAf;AACAa,QAAAA,UAAU;AACX,OAHD;AAID,KAtHD;AAuHD,GApKD;AAqKD,CA/LD","sourcesContent":["/*jshint node:true, laxcomma:true*/\n'use strict';\n\nvar spawn = require('child_process').spawn;\n\n\nfunction legacyTag(key) { return key.match(/^TAG:/); }\nfunction legacyDisposition(key) { return key.match(/^DISPOSITION:/); }\n\nfunction parseFfprobeOutput(out) {\n  var lines = out.split(/\\r\\n|\\r|\\n/);\n\n  lines = lines.filter(function (line) {\n    return line.length > 0;\n  });\n\n  var data = {\n    streams: [],\n    format: {},\n    chapters: []\n  };\n\n  function parseBlock(name) {\n    var data = {};\n\n    var line = lines.shift();\n    while (typeof line !== 'undefined') {\n      if (line.toLowerCase() == '[/'+name+']') {\n        return data;\n      } else if (line.match(/^\\[/)) {\n        line = lines.shift();\n        continue;\n      }\n\n      var kv = line.match(/^([^=]+)=(.*)$/);\n      if (kv) {\n        if (!(kv[1].match(/^TAG:/)) && kv[2].match(/^[0-9]+(\\.[0-9]+)?$/)) {\n          data[kv[1]] = Number(kv[2]);\n        } else {\n          data[kv[1]] = kv[2];\n        }\n      }\n\n      line = lines.shift();\n    }\n\n    return data;\n  }\n\n  var line = lines.shift();\n  while (typeof line !== 'undefined') {\n    if (line.match(/^\\[stream/i)) {\n      var stream = parseBlock('stream');\n      data.streams.push(stream);\n    } else if (line.match(/^\\[chapter/i)) {\n      var chapter = parseBlock('chapter');\n      data.chapters.push(chapter);\n    } else if (line.toLowerCase() === '[format]') {\n      data.format = parseBlock('format');\n    }\n\n    line = lines.shift();\n  }\n\n  return data;\n}\n\n\n\nmodule.exports = function(proto) {\n  /**\n   * A callback passed to the {@link FfmpegCommand#ffprobe} method.\n   *\n   * @callback FfmpegCommand~ffprobeCallback\n   *\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} ffprobeData ffprobe output data; this object\n   *   has the same format as what the following command returns:\n   *\n   *     `ffprobe -print_format json -show_streams -show_format INPUTFILE`\n   * @param {Array} ffprobeData.streams stream information\n   * @param {Object} ffprobeData.format format information\n   */\n\n  /**\n   * Run ffprobe on last specified input\n   *\n   * @method FfmpegCommand#ffprobe\n   * @category Metadata\n   *\n   * @param {?Number} [index] 0-based index of input to probe (defaults to last input)\n   * @param {?String[]} [options] array of output options to return\n   * @param {FfmpegCommand~ffprobeCallback} callback callback function\n   *\n   */\n  proto.ffprobe = function() {\n    var input, index = null, options = [], callback;\n\n    // the last argument should be the callback\n    var callback = arguments[arguments.length - 1];\n\n    var ended = false\n    function handleCallback(err, data) {\n      if (!ended) {\n        ended = true;\n        callback(err, data);\n      }\n    };\n\n    // map the arguments to the correct variable names\n    switch (arguments.length) {\n      case 3:\n        index = arguments[0];\n        options = arguments[1];\n        break;\n      case 2:\n        if (typeof arguments[0] === 'number') {\n          index = arguments[0];\n        } else if (Array.isArray(arguments[0])) {\n          options = arguments[0];\n        }\n        break;\n    }\n\n\n    if (index === null) {\n      if (!this._currentInput) {\n        return handleCallback(new Error('No input specified'));\n      }\n\n      input = this._currentInput;\n    } else {\n      input = this._inputs[index];\n\n      if (!input) {\n        return handleCallback(new Error('Invalid input index'));\n      }\n    }\n\n    // Find ffprobe\n    this._getFfprobePath(function(err, path) {\n      if (err) {\n        return handleCallback(err);\n      } else if (!path) {\n        return handleCallback(new Error('Cannot find ffprobe'));\n      }\n\n      var stdout = '';\n      var stdoutClosed = false;\n      var stderr = '';\n      var stderrClosed = false;\n\n      // Spawn ffprobe\n      var src = input.isStream ? 'pipe:0' : input.source;\n      var ffprobe = spawn(path, ['-show_streams', '-show_format'].concat(options, src));\n\n      if (input.isStream) {\n        // Skip errors on stdin. These get thrown when ffprobe is complete and\n        // there seems to be no way hook in and close stdin before it throws.\n        ffprobe.stdin.on('error', function(err) {\n          if (['ECONNRESET', 'EPIPE'].indexOf(err.code) >= 0) { return; }\n          handleCallback(err);\n        });\n\n        // Once ffprobe's input stream closes, we need no more data from the\n        // input\n        ffprobe.stdin.on('close', function() {\n            input.source.pause();\n            input.source.unpipe(ffprobe.stdin);\n        });\n\n        input.source.pipe(ffprobe.stdin);\n      }\n\n      ffprobe.on('error', callback);\n\n      // Ensure we wait for captured streams to end before calling callback\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && stdoutClosed && stderrClosed) {\n          if (exitError) {\n            if (stderr) {\n              exitError.message += '\\n' + stderr;\n            }\n\n            return handleCallback(exitError);\n          }\n\n          // Process output\n          var data = parseFfprobeOutput(stdout);\n\n          // Handle legacy output with \"TAG:x\" and \"DISPOSITION:x\" keys\n          [data.format].concat(data.streams).forEach(function(target) {\n            if (target) {\n              var legacyTagKeys = Object.keys(target).filter(legacyTag);\n\n              if (legacyTagKeys.length) {\n                target.tags = target.tags || {};\n\n                legacyTagKeys.forEach(function(tagKey) {\n                  target.tags[tagKey.substr(4)] = target[tagKey];\n                  delete target[tagKey];\n                });\n              }\n\n              var legacyDispositionKeys = Object.keys(target).filter(legacyDisposition);\n\n              if (legacyDispositionKeys.length) {\n                target.disposition = target.disposition || {};\n\n                legacyDispositionKeys.forEach(function(dispositionKey) {\n                  target.disposition[dispositionKey.substr(12)] = target[dispositionKey];\n                  delete target[dispositionKey];\n                });\n              }\n            }\n          });\n\n          handleCallback(null, data);\n        }\n      }\n\n      // Handle ffprobe exit\n      var processExited = false;\n      ffprobe.on('exit', function(code, signal) {\n        processExited = true;\n\n        if (code) {\n          handleExit(new Error('ffprobe exited with code ' + code));\n        } else if (signal) {\n          handleExit(new Error('ffprobe was killed with signal ' + signal));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Handle stdout/stderr streams\n      ffprobe.stdout.on('data', function(data) {\n        stdout += data;\n      });\n\n      ffprobe.stdout.on('close', function() {\n        stdoutClosed = true;\n        handleExit();\n      });\n\n      ffprobe.stderr.on('data', function(data) {\n        stderr += data;\n      });\n\n      ffprobe.stderr.on('close', function() {\n        stderrClosed = true;\n        handleExit();\n      });\n    });\n  };\n};\n"]},"metadata":{},"sourceType":"script"}