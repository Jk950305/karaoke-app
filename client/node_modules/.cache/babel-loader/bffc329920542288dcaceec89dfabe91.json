{"ast":null,"code":"/*jshint node:true*/\n'use strict';\n/*\n *! Size helpers\n */\n\n/**\n * Return filters to pad video to width*height,\n *\n * @param {Number} width output width\n * @param {Number} height output height\n * @param {Number} aspect video aspect ratio (without padding)\n * @param {Number} color padding color\n * @return scale/pad filters\n * @private\n */\n\nfunction getScalePadFilters(width, height, aspect, color) {\n  /*\n    let a be the input aspect ratio, A be the requested aspect ratio\n     if a > A, padding is done on top and bottom\n    if a < A, padding is done on left and right\n   */\n  return [\n  /*\n    In both cases, we first have to scale the input to match the requested size.\n    When using computed width/height, we truncate them to multiples of 2\n   */\n  {\n    filter: 'scale',\n    options: {\n      w: 'if(gt(a,' + aspect + '),' + width + ',trunc(' + height + '*a/2)*2)',\n      h: 'if(lt(a,' + aspect + '),' + height + ',trunc(' + width + '/a/2)*2)'\n    }\n  },\n  /*\n    Then we pad the scaled input to match the target size\n    (here iw and ih refer to the padding input, i.e the scaled output)\n   */\n  {\n    filter: 'pad',\n    options: {\n      w: width,\n      h: height,\n      x: 'if(gt(a,' + aspect + '),0,(' + width + '-iw)/2)',\n      y: 'if(lt(a,' + aspect + '),0,(' + height + '-ih)/2)',\n      color: color\n    }\n  }];\n}\n/**\n * Recompute size filters\n *\n * @param {Object} output\n * @param {String} key newly-added parameter name ('size', 'aspect' or 'pad')\n * @param {String} value newly-added parameter value\n * @return filter string array\n * @private\n */\n\n\nfunction createSizeFilters(output, key, value) {\n  // Store parameters\n  var data = output.sizeData = output.sizeData || {};\n  data[key] = value;\n\n  if (!('size' in data)) {\n    // No size requested, keep original size\n    return [];\n  } // Try to match the different size string formats\n\n\n  var fixedSize = data.size.match(/([0-9]+)x([0-9]+)/);\n  var fixedWidth = data.size.match(/([0-9]+)x\\?/);\n  var fixedHeight = data.size.match(/\\?x([0-9]+)/);\n  var percentRatio = data.size.match(/\\b([0-9]{1,3})%/);\n  var width, height, aspect;\n\n  if (percentRatio) {\n    var ratio = Number(percentRatio[1]) / 100;\n    return [{\n      filter: 'scale',\n      options: {\n        w: 'trunc(iw*' + ratio + '/2)*2',\n        h: 'trunc(ih*' + ratio + '/2)*2'\n      }\n    }];\n  } else if (fixedSize) {\n    // Round target size to multiples of 2\n    width = Math.round(Number(fixedSize[1]) / 2) * 2;\n    height = Math.round(Number(fixedSize[2]) / 2) * 2;\n    aspect = width / height;\n\n    if (data.pad) {\n      return getScalePadFilters(width, height, aspect, data.pad);\n    } else {\n      // No autopad requested, rescale to target size\n      return [{\n        filter: 'scale',\n        options: {\n          w: width,\n          h: height\n        }\n      }];\n    }\n  } else if (fixedWidth || fixedHeight) {\n    if ('aspect' in data) {\n      // Specified aspect ratio\n      width = fixedWidth ? fixedWidth[1] : Math.round(Number(fixedHeight[1]) * data.aspect);\n      height = fixedHeight ? fixedHeight[1] : Math.round(Number(fixedWidth[1]) / data.aspect); // Round to multiples of 2\n\n      width = Math.round(width / 2) * 2;\n      height = Math.round(height / 2) * 2;\n\n      if (data.pad) {\n        return getScalePadFilters(width, height, data.aspect, data.pad);\n      } else {\n        // No autopad requested, rescale to target size\n        return [{\n          filter: 'scale',\n          options: {\n            w: width,\n            h: height\n          }\n        }];\n      }\n    } else {\n      // Keep input aspect ratio\n      if (fixedWidth) {\n        return [{\n          filter: 'scale',\n          options: {\n            w: Math.round(Number(fixedWidth[1]) / 2) * 2,\n            h: 'trunc(ow/a/2)*2'\n          }\n        }];\n      } else {\n        return [{\n          filter: 'scale',\n          options: {\n            w: 'trunc(oh*a/2)*2',\n            h: Math.round(Number(fixedHeight[1]) / 2) * 2\n          }\n        }];\n      }\n    }\n  } else {\n    throw new Error('Invalid size specified: ' + data.size);\n  }\n}\n/*\n *! Video size-related methods\n */\n\n\nmodule.exports = function (proto) {\n  /**\n   * Keep display aspect ratio\n   *\n   * This method is useful when converting an input with non-square pixels to an output format\n   * that does not support non-square pixels.  It rescales the input so that the display aspect\n   * ratio is the same.\n   *\n   * @method FfmpegCommand#keepDAR\n   * @category Video size\n   * @aliases keepPixelAspect,keepDisplayAspect,keepDisplayAspectRatio\n   *\n   * @return FfmpegCommand\n   */\n  proto.keepPixelAspect = // Only for compatibility, this is not about keeping _pixel_ aspect ratio\n  proto.keepDisplayAspect = proto.keepDisplayAspectRatio = proto.keepDAR = function () {\n    return this.videoFilters([{\n      filter: 'scale',\n      options: {\n        w: 'if(gt(sar,1),iw*sar,iw)',\n        h: 'if(lt(sar,1),ih/sar,ih)'\n      }\n    }, {\n      filter: 'setsar',\n      options: '1'\n    }]);\n  };\n  /**\n   * Set output size\n   *\n   * The 'size' parameter can have one of 4 forms:\n   * - 'X%': rescale to xx % of the original size\n   * - 'WxH': specify width and height\n   * - 'Wx?': specify width and compute height from input aspect ratio\n   * - '?xH': specify height and compute width from input aspect ratio\n   *\n   * Note: both dimensions will be truncated to multiples of 2.\n   *\n   * @method FfmpegCommand#size\n   * @category Video size\n   * @aliases withSize,setSize\n   *\n   * @param {String} size size string, eg. '33%', '320x240', '320x?', '?x240'\n   * @return FfmpegCommand\n   */\n\n\n  proto.withSize = proto.setSize = proto.size = function (size) {\n    var filters = createSizeFilters(this._currentOutput, 'size', size);\n\n    this._currentOutput.sizeFilters.clear();\n\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n  /**\n   * Set output aspect ratio\n   *\n   * @method FfmpegCommand#aspect\n   * @category Video size\n   * @aliases withAspect,withAspectRatio,setAspect,setAspectRatio,aspectRatio\n   *\n   * @param {String|Number} aspect aspect ratio (number or 'X:Y' string)\n   * @return FfmpegCommand\n   */\n\n\n  proto.withAspect = proto.withAspectRatio = proto.setAspect = proto.setAspectRatio = proto.aspect = proto.aspectRatio = function (aspect) {\n    var a = Number(aspect);\n\n    if (isNaN(a)) {\n      var match = aspect.match(/^(\\d+):(\\d+)$/);\n\n      if (match) {\n        a = Number(match[1]) / Number(match[2]);\n      } else {\n        throw new Error('Invalid aspect ratio: ' + aspect);\n      }\n    }\n\n    var filters = createSizeFilters(this._currentOutput, 'aspect', a);\n\n    this._currentOutput.sizeFilters.clear();\n\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n  /**\n   * Enable auto-padding the output\n   *\n   * @method FfmpegCommand#autopad\n   * @category Video size\n   * @aliases applyAutopadding,applyAutoPadding,applyAutopad,applyAutoPad,withAutopadding,withAutoPadding,withAutopad,withAutoPad,autoPad\n   *\n   * @param {Boolean} [pad=true] enable/disable auto-padding\n   * @param {String} [color='black'] pad color\n   */\n\n\n  proto.applyAutopadding = proto.applyAutoPadding = proto.applyAutopad = proto.applyAutoPad = proto.withAutopadding = proto.withAutoPadding = proto.withAutopad = proto.withAutoPad = proto.autoPad = proto.autopad = function (pad, color) {\n    // Allow autopad(color)\n    if (typeof pad === 'string') {\n      color = pad;\n      pad = true;\n    } // Allow autopad() and autopad(undefined, color)\n\n\n    if (typeof pad === 'undefined') {\n      pad = true;\n    }\n\n    var filters = createSizeFilters(this._currentOutput, 'pad', pad ? color || 'black' : false);\n\n    this._currentOutput.sizeFilters.clear();\n\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n};","map":{"version":3,"sources":["/Users/jonkim/my-app/node_modules/fluent-ffmpeg/lib/options/videosize.js"],"names":["getScalePadFilters","width","height","aspect","color","filter","options","w","h","x","y","createSizeFilters","output","key","value","data","sizeData","fixedSize","size","match","fixedWidth","fixedHeight","percentRatio","ratio","Number","Math","round","pad","Error","module","exports","proto","keepPixelAspect","keepDisplayAspect","keepDisplayAspectRatio","keepDAR","videoFilters","withSize","setSize","filters","_currentOutput","sizeFilters","clear","withAspect","withAspectRatio","setAspect","setAspectRatio","aspectRatio","a","isNaN","applyAutopadding","applyAutoPadding","applyAutopad","applyAutoPad","withAutopadding","withAutoPadding","withAutopad","withAutoPad","autoPad","autopad"],"mappings":"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","sourcesContent":["/*jshint node:true*/\n'use strict';\n\n/*\n *! Size helpers\n */\n\n\n/**\n * Return filters to pad video to width*height,\n *\n * @param {Number} width output width\n * @param {Number} height output height\n * @param {Number} aspect video aspect ratio (without padding)\n * @param {Number} color padding color\n * @return scale/pad filters\n * @private\n */\nfunction getScalePadFilters(width, height, aspect, color) {\n  /*\n    let a be the input aspect ratio, A be the requested aspect ratio\n\n    if a > A, padding is done on top and bottom\n    if a < A, padding is done on left and right\n   */\n\n  return [\n    /*\n      In both cases, we first have to scale the input to match the requested size.\n      When using computed width/height, we truncate them to multiples of 2\n     */\n    {\n      filter: 'scale',\n      options: {\n        w: 'if(gt(a,' + aspect + '),' + width + ',trunc(' + height + '*a/2)*2)',\n        h: 'if(lt(a,' + aspect + '),' + height + ',trunc(' + width + '/a/2)*2)'\n      }\n    },\n\n    /*\n      Then we pad the scaled input to match the target size\n      (here iw and ih refer to the padding input, i.e the scaled output)\n     */\n\n    {\n      filter: 'pad',\n      options: {\n        w: width,\n        h: height,\n        x: 'if(gt(a,' + aspect + '),0,(' + width + '-iw)/2)',\n        y: 'if(lt(a,' + aspect + '),0,(' + height + '-ih)/2)',\n        color: color\n      }\n    }\n  ];\n}\n\n\n/**\n * Recompute size filters\n *\n * @param {Object} output\n * @param {String} key newly-added parameter name ('size', 'aspect' or 'pad')\n * @param {String} value newly-added parameter value\n * @return filter string array\n * @private\n */\nfunction createSizeFilters(output, key, value) {\n  // Store parameters\n  var data = output.sizeData = output.sizeData || {};\n  data[key] = value;\n\n  if (!('size' in data)) {\n    // No size requested, keep original size\n    return [];\n  }\n\n  // Try to match the different size string formats\n  var fixedSize = data.size.match(/([0-9]+)x([0-9]+)/);\n  var fixedWidth = data.size.match(/([0-9]+)x\\?/);\n  var fixedHeight = data.size.match(/\\?x([0-9]+)/);\n  var percentRatio = data.size.match(/\\b([0-9]{1,3})%/);\n  var width, height, aspect;\n\n  if (percentRatio) {\n    var ratio = Number(percentRatio[1]) / 100;\n    return [{\n      filter: 'scale',\n      options: {\n        w: 'trunc(iw*' + ratio + '/2)*2',\n        h: 'trunc(ih*' + ratio + '/2)*2'\n      }\n    }];\n  } else if (fixedSize) {\n    // Round target size to multiples of 2\n    width = Math.round(Number(fixedSize[1]) / 2) * 2;\n    height = Math.round(Number(fixedSize[2]) / 2) * 2;\n\n    aspect = width / height;\n\n    if (data.pad) {\n      return getScalePadFilters(width, height, aspect, data.pad);\n    } else {\n      // No autopad requested, rescale to target size\n      return [{ filter: 'scale', options: { w: width, h: height }}];\n    }\n  } else if (fixedWidth || fixedHeight) {\n    if ('aspect' in data) {\n      // Specified aspect ratio\n      width = fixedWidth ? fixedWidth[1] : Math.round(Number(fixedHeight[1]) * data.aspect);\n      height = fixedHeight ? fixedHeight[1] : Math.round(Number(fixedWidth[1]) / data.aspect);\n\n      // Round to multiples of 2\n      width = Math.round(width / 2) * 2;\n      height = Math.round(height / 2) * 2;\n\n      if (data.pad) {\n        return getScalePadFilters(width, height, data.aspect, data.pad);\n      } else {\n        // No autopad requested, rescale to target size\n        return [{ filter: 'scale', options: { w: width, h: height }}];\n      }\n    } else {\n      // Keep input aspect ratio\n\n      if (fixedWidth) {\n        return [{\n          filter: 'scale',\n          options: {\n            w: Math.round(Number(fixedWidth[1]) / 2) * 2,\n            h: 'trunc(ow/a/2)*2'\n          }\n        }];\n      } else {\n        return [{\n          filter: 'scale',\n          options: {\n            w: 'trunc(oh*a/2)*2',\n            h: Math.round(Number(fixedHeight[1]) / 2) * 2\n          }\n        }];\n      }\n    }\n  } else {\n    throw new Error('Invalid size specified: ' + data.size);\n  }\n}\n\n\n/*\n *! Video size-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Keep display aspect ratio\n   *\n   * This method is useful when converting an input with non-square pixels to an output format\n   * that does not support non-square pixels.  It rescales the input so that the display aspect\n   * ratio is the same.\n   *\n   * @method FfmpegCommand#keepDAR\n   * @category Video size\n   * @aliases keepPixelAspect,keepDisplayAspect,keepDisplayAspectRatio\n   *\n   * @return FfmpegCommand\n   */\n  proto.keepPixelAspect = // Only for compatibility, this is not about keeping _pixel_ aspect ratio\n  proto.keepDisplayAspect =\n  proto.keepDisplayAspectRatio =\n  proto.keepDAR = function() {\n    return this.videoFilters([\n      {\n        filter: 'scale',\n        options: {\n          w: 'if(gt(sar,1),iw*sar,iw)',\n          h: 'if(lt(sar,1),ih/sar,ih)'\n        }\n      },\n      {\n        filter: 'setsar',\n        options: '1'\n      }\n    ]);\n  };\n\n\n  /**\n   * Set output size\n   *\n   * The 'size' parameter can have one of 4 forms:\n   * - 'X%': rescale to xx % of the original size\n   * - 'WxH': specify width and height\n   * - 'Wx?': specify width and compute height from input aspect ratio\n   * - '?xH': specify height and compute width from input aspect ratio\n   *\n   * Note: both dimensions will be truncated to multiples of 2.\n   *\n   * @method FfmpegCommand#size\n   * @category Video size\n   * @aliases withSize,setSize\n   *\n   * @param {String} size size string, eg. '33%', '320x240', '320x?', '?x240'\n   * @return FfmpegCommand\n   */\n  proto.withSize =\n  proto.setSize =\n  proto.size = function(size) {\n    var filters = createSizeFilters(this._currentOutput, 'size', size);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n\n\n  /**\n   * Set output aspect ratio\n   *\n   * @method FfmpegCommand#aspect\n   * @category Video size\n   * @aliases withAspect,withAspectRatio,setAspect,setAspectRatio,aspectRatio\n   *\n   * @param {String|Number} aspect aspect ratio (number or 'X:Y' string)\n   * @return FfmpegCommand\n   */\n  proto.withAspect =\n  proto.withAspectRatio =\n  proto.setAspect =\n  proto.setAspectRatio =\n  proto.aspect =\n  proto.aspectRatio = function(aspect) {\n    var a = Number(aspect);\n    if (isNaN(a)) {\n      var match = aspect.match(/^(\\d+):(\\d+)$/);\n      if (match) {\n        a = Number(match[1]) / Number(match[2]);\n      } else {\n        throw new Error('Invalid aspect ratio: ' + aspect);\n      }\n    }\n\n    var filters = createSizeFilters(this._currentOutput, 'aspect', a);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n\n\n  /**\n   * Enable auto-padding the output\n   *\n   * @method FfmpegCommand#autopad\n   * @category Video size\n   * @aliases applyAutopadding,applyAutoPadding,applyAutopad,applyAutoPad,withAutopadding,withAutoPadding,withAutopad,withAutoPad,autoPad\n   *\n   * @param {Boolean} [pad=true] enable/disable auto-padding\n   * @param {String} [color='black'] pad color\n   */\n  proto.applyAutopadding =\n  proto.applyAutoPadding =\n  proto.applyAutopad =\n  proto.applyAutoPad =\n  proto.withAutopadding =\n  proto.withAutoPadding =\n  proto.withAutopad =\n  proto.withAutoPad =\n  proto.autoPad =\n  proto.autopad = function(pad, color) {\n    // Allow autopad(color)\n    if (typeof pad === 'string') {\n      color = pad;\n      pad = true;\n    }\n\n    // Allow autopad() and autopad(undefined, color)\n    if (typeof pad === 'undefined') {\n      pad = true;\n    }\n\n    var filters = createSizeFilters(this._currentOutput, 'pad', pad ? color || 'black' : false);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}