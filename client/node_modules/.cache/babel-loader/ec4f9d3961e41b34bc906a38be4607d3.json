{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nconst stream_1 = require(\"stream\");\n\nconst url_1 = require(\"url\");\n\nconst miniget_1 = __importDefault(require(\"miniget\"));\n\nconst m3u8_parser_1 = __importDefault(require(\"./m3u8-parser\"));\n\nconst dash_mpd_parser_1 = __importDefault(require(\"./dash-mpd-parser\"));\n\nconst queue_1 = __importDefault(require(\"./queue\"));\n\nconst parse_time_1 = require(\"./parse-time\");\n\nconst supportedParsers = {\n  'm3u8': m3u8_parser_1.default,\n  'dash-mpd': dash_mpd_parser_1.default\n};\n\nlet m3u8stream = (playlistURL, options = {}) => {\n  const stream = new stream_1.PassThrough();\n  const chunkReadahead = options.chunkReadahead || 3;\n  const liveBuffer = options.liveBuffer || 20000; // 20 seconds\n\n  const requestOptions = options.requestOptions;\n  const Parser = supportedParsers[options.parser || (/\\.mpd$/.test(playlistURL) ? 'dash-mpd' : 'm3u8')];\n\n  if (!Parser) {\n    throw TypeError(`parser '${options.parser}' not supported`);\n  }\n\n  let begin = 0;\n\n  if (typeof options.begin !== 'undefined') {\n    begin = typeof options.begin === 'string' ? parse_time_1.humanStr(options.begin) : Math.max(options.begin - liveBuffer, 0);\n  }\n\n  const forwardEvents = req => {\n    for (let event of ['abort', 'request', 'response', 'redirect', 'retry', 'reconnect']) {\n      req.on(event, stream.emit.bind(stream, event));\n    }\n  };\n\n  let currSegment;\n  const streamQueue = new queue_1.default((req, callback) => {\n    currSegment = req; // Count the size manually, since the `content-length` header is not\n    // always there.\n\n    let size = 0;\n    req.on('data', chunk => size += chunk.length);\n    req.pipe(stream, {\n      end: false\n    });\n    req.on('end', () => callback(undefined, size));\n  }, {\n    concurrency: 1\n  });\n  let segmentNumber = 0;\n  let downloaded = 0;\n  const requestQueue = new queue_1.default((segment, callback) => {\n    let options = Object.assign({}, requestOptions);\n\n    if (segment.range) {\n      options.headers = Object.assign({}, options.headers, {\n        Range: `bytes=${segment.range.start}-${segment.range.end}`\n      });\n    }\n\n    let req = miniget_1.default(url_1.resolve(playlistURL, segment.url), options);\n    req.on('error', callback);\n    forwardEvents(req);\n    streamQueue.push(req, (err, size) => {\n      downloaded += +size;\n      stream.emit('progress', {\n        num: ++segmentNumber,\n        size: size,\n        duration: segment.duration,\n        url: segment.url\n      }, requestQueue.total, downloaded);\n      callback();\n    });\n  }, {\n    concurrency: chunkReadahead\n  });\n\n  const onError = err => {\n    if (ended) {\n      return;\n    }\n\n    stream.emit('error', err); // Stop on any error.\n\n    stream.end();\n  }; // When to look for items again.\n\n\n  let refreshThreshold;\n  let minRefreshTime;\n  let refreshTimeout;\n  let fetchingPlaylist = true;\n  let ended = false;\n  let isStatic = false;\n  let lastRefresh;\n\n  const onQueuedEnd = err => {\n    currSegment = null;\n\n    if (err) {\n      onError(err);\n    } else if (!fetchingPlaylist && !ended && !isStatic && requestQueue.tasks.length + requestQueue.active <= refreshThreshold) {\n      let ms = Math.max(0, minRefreshTime - (Date.now() - lastRefresh));\n      fetchingPlaylist = true;\n      refreshTimeout = setTimeout(refreshPlaylist, ms);\n    } else if ((ended || isStatic) && !requestQueue.tasks.length && !requestQueue.active) {\n      stream.end();\n    }\n  };\n\n  let currPlaylist;\n  let lastSeq;\n  let starttime = 0;\n\n  const refreshPlaylist = () => {\n    lastRefresh = Date.now();\n    currPlaylist = miniget_1.default(playlistURL, requestOptions);\n    currPlaylist.on('error', onError);\n    forwardEvents(currPlaylist);\n    const parser = currPlaylist.pipe(new Parser(options.id));\n    parser.on('starttime', a => {\n      if (starttime) {\n        return;\n      }\n\n      starttime = a;\n\n      if (typeof options.begin === 'string' && begin >= 0) {\n        begin += starttime;\n      }\n    });\n    parser.on('endlist', () => {\n      isStatic = true;\n    });\n    parser.on('endearly', currPlaylist.unpipe.bind(currPlaylist, parser));\n    let addedItems = [];\n\n    const addItem = item => {\n      if (!item.init) {\n        if (item.seq <= lastSeq) {\n          return;\n        }\n\n        lastSeq = item.seq;\n      }\n\n      begin = item.time;\n      requestQueue.push(item, onQueuedEnd);\n      addedItems.push(item);\n    };\n\n    let tailedItems = [],\n        tailedItemsDuration = 0;\n    parser.on('item', item => {\n      let timedItem = Object.assign({\n        time: starttime\n      }, item);\n\n      if (begin <= timedItem.time) {\n        addItem(timedItem);\n      } else {\n        tailedItems.push(timedItem);\n        tailedItemsDuration += timedItem.duration; // Only keep the last `liveBuffer` of items.\n\n        while (tailedItems.length > 1 && tailedItemsDuration - tailedItems[0].duration > liveBuffer) {\n          tailedItemsDuration -= tailedItems.shift().duration;\n        }\n      }\n\n      starttime += timedItem.duration;\n    });\n    parser.on('end', () => {\n      currPlaylist = null; // If we are too ahead of the stream, make sure to get the\n      // latest available items with a small buffer.\n\n      if (!addedItems.length && tailedItems.length) {\n        tailedItems.forEach(item => {\n          addItem(item);\n        });\n      } // Refresh the playlist when remaining segments get low.\n\n\n      refreshThreshold = Math.max(1, Math.ceil(addedItems.length * 0.01)); // Throttle refreshing the playlist by looking at the duration\n      // of live items added on this refresh.\n\n      minRefreshTime = addedItems.reduce((total, item) => item.duration + total, 0);\n      fetchingPlaylist = false;\n      onQueuedEnd();\n    });\n  };\n\n  refreshPlaylist();\n\n  stream.end = () => {\n    ended = true;\n    streamQueue.die();\n    requestQueue.die();\n    clearTimeout(refreshTimeout);\n    currPlaylist === null || currPlaylist === void 0 ? void 0 : currPlaylist.destroy();\n    currSegment === null || currSegment === void 0 ? void 0 : currSegment.destroy();\n    stream_1.PassThrough.prototype.end.call(stream, null);\n  };\n\n  return stream;\n};\n\nm3u8stream.parseTimestamp = parse_time_1.humanStr;\nmodule.exports = m3u8stream;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,KAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,SAAA,CAAA,CAAA;;AACA,MAAA,aAAA,GAAA,eAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,SAAA,CAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAqCA,MAAM,gBAAgB,GAAG;AACvB,UAAQ,aAAA,CAAA,OADe;AAEvB,cAAY,iBAAA,CAAA;AAFW,CAAzB;;AAKA,IAAI,UAAU,GAAI,CAAC,WAAD,EAAsB,OAAA,GAA8B,EAApD,KAA6E;AAC7F,QAAM,MAAM,GAAG,IAAI,QAAA,CAAA,WAAJ,EAAf;AACA,QAAM,cAAc,GAAG,OAAO,CAAC,cAAR,IAA0B,CAAjD;AACA,QAAM,UAAU,GAAG,OAAO,CAAC,UAAR,IAAsB,KAAzC,CAH6F,CAG7C;;AAChD,QAAM,cAAc,GAAG,OAAO,CAAC,cAA/B;AACA,QAAM,MAAM,GAAG,gBAAgB,CAAC,OAAO,CAAC,MAAR,KAAmB,SAAS,IAAT,CAAc,WAAd,IAA6B,UAA7B,GAA0C,MAA7D,CAAD,CAA/B;;AACA,MAAI,CAAC,MAAL,EAAa;AACX,UAAM,SAAS,CAAC,WAAW,OAAO,CAAC,MAAM,iBAA1B,CAAf;AACD;;AACD,MAAI,KAAK,GAAG,CAAZ;;AACA,MAAI,OAAO,OAAO,CAAC,KAAf,KAAyB,WAA7B,EAA0C;AACxC,IAAA,KAAK,GAAG,OAAO,OAAO,CAAC,KAAf,KAAyB,QAAzB,GACN,YAAA,CAAA,QAAA,CAAS,OAAO,CAAC,KAAjB,CADM,GAEN,IAAI,CAAC,GAAL,CAAS,OAAO,CAAC,KAAR,GAAgB,UAAzB,EAAqC,CAArC,CAFF;AAGD;;AAED,QAAM,aAAa,GAAI,GAAD,IAAwB;AAC5C,SAAK,IAAI,KAAT,IAAkB,CAAC,OAAD,EAAU,SAAV,EAAqB,UAArB,EAAiC,UAAjC,EAA6C,OAA7C,EAAsD,WAAtD,CAAlB,EAAsF;AACpF,MAAA,GAAG,CAAC,EAAJ,CAAO,KAAP,EAAc,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAiB,MAAjB,EAAyB,KAAzB,CAAd;AACD;AACF,GAJD;;AAMA,MAAI,WAAJ;AACA,QAAM,WAAW,GAAG,IAAI,OAAA,CAAA,OAAJ,CAAU,CAAC,GAAD,EAAM,QAAN,KAAwB;AACpD,IAAA,WAAW,GAAG,GAAd,CADoD,CAEpD;AACA;;AACA,QAAI,IAAI,GAAG,CAAX;AACA,IAAA,GAAG,CAAC,EAAJ,CAAO,MAAP,EAAgB,KAAD,IAAmB,IAAI,IAAI,KAAK,CAAC,MAAhD;AACA,IAAA,GAAG,CAAC,IAAJ,CAAS,MAAT,EAAiB;AAAE,MAAA,GAAG,EAAE;AAAP,KAAjB;AACA,IAAA,GAAG,CAAC,EAAJ,CAAO,KAAP,EAAc,MAAM,QAAQ,CAAC,SAAD,EAAY,IAAZ,CAA5B;AACD,GARmB,EAQjB;AAAE,IAAA,WAAW,EAAE;AAAf,GARiB,CAApB;AAUA,MAAI,aAAa,GAAG,CAApB;AACA,MAAI,UAAU,GAAG,CAAjB;AACA,QAAM,YAAY,GAAG,IAAI,OAAA,CAAA,OAAJ,CAAU,CAAC,OAAD,EAAgB,QAAhB,KAA8C;AAC3E,QAAI,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,cAAlB,CAAd;;AACA,QAAI,OAAO,CAAC,KAAZ,EAAmB;AACjB,MAAA,OAAO,CAAC,OAAR,GAAkB,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAO,CAAC,OAA1B,EAAmC;AACnD,QAAA,KAAK,EAAE,SAAS,OAAO,CAAC,KAAR,CAAc,KAAK,IAAI,OAAO,CAAC,KAAR,CAAc,GAAG;AADL,OAAnC,CAAlB;AAGD;;AACD,QAAI,GAAG,GAAG,SAAA,CAAA,OAAA,CAAQ,KAAA,CAAA,OAAA,CAAW,WAAX,EAAwB,OAAO,CAAC,GAAhC,CAAR,EAA8C,OAA9C,CAAV;AACA,IAAA,GAAG,CAAC,EAAJ,CAAO,OAAP,EAAgB,QAAhB;AACA,IAAA,aAAa,CAAC,GAAD,CAAb;AACA,IAAA,WAAW,CAAC,IAAZ,CAAiB,GAAjB,EAAsB,CAAC,GAAD,EAAM,IAAN,KAAc;AAClC,MAAA,UAAU,IAAI,CAAC,IAAf;AACA,MAAA,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB;AACtB,QAAA,GAAG,EAAE,EAAE,aADe;AAEtB,QAAA,IAAI,EAAE,IAFgB;AAGtB,QAAA,QAAQ,EAAE,OAAO,CAAC,QAHI;AAItB,QAAA,GAAG,EAAE,OAAO,CAAC;AAJS,OAAxB,EAKG,YAAY,CAAC,KALhB,EAKuB,UALvB;AAMA,MAAA,QAAQ;AACT,KATD;AAUD,GApBoB,EAoBlB;AAAE,IAAA,WAAW,EAAE;AAAf,GApBkB,CAArB;;AAsBA,QAAM,OAAO,GAAI,GAAD,IAAqB;AACnC,QAAI,KAAJ,EAAW;AAAE;AAAS;;AACtB,IAAA,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,GAArB,EAFmC,CAGnC;;AACA,IAAA,MAAM,CAAC,GAAP;AACD,GALD,CAzD6F,CAgE7F;;;AACA,MAAI,gBAAJ;AACA,MAAI,cAAJ;AACA,MAAI,cAAJ;AACA,MAAI,gBAAgB,GAAG,IAAvB;AACA,MAAI,KAAK,GAAG,KAAZ;AACA,MAAI,QAAQ,GAAG,KAAf;AACA,MAAI,WAAJ;;AAEA,QAAM,WAAW,GAAI,GAAD,IAAsB;AACxC,IAAA,WAAW,GAAG,IAAd;;AACA,QAAI,GAAJ,EAAS;AACP,MAAA,OAAO,CAAC,GAAD,CAAP;AACD,KAFD,MAEO,IAAI,CAAC,gBAAD,IAAqB,CAAC,KAAtB,IAA+B,CAAC,QAAhC,IACT,YAAY,CAAC,KAAb,CAAmB,MAAnB,GAA4B,YAAY,CAAC,MAAzC,IAAmD,gBAD9C,EACgE;AACrE,UAAI,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,cAAc,IAAI,IAAI,CAAC,GAAL,KAAa,WAAjB,CAA1B,CAAT;AACA,MAAA,gBAAgB,GAAG,IAAnB;AACA,MAAA,cAAc,GAAG,UAAU,CAAC,eAAD,EAAkB,EAAlB,CAA3B;AACD,KALM,MAKA,IAAI,CAAC,KAAK,IAAI,QAAV,KACT,CAAC,YAAY,CAAC,KAAb,CAAmB,MADX,IACqB,CAAC,YAAY,CAAC,MADvC,EAC+C;AACpD,MAAA,MAAM,CAAC,GAAP;AACD;AACF,GAbD;;AAeA,MAAI,YAAJ;AACA,MAAI,OAAJ;AACA,MAAI,SAAS,GAAG,CAAhB;;AAEA,QAAM,eAAe,GAAG,MAAW;AACjC,IAAA,WAAW,GAAG,IAAI,CAAC,GAAL,EAAd;AACA,IAAA,YAAY,GAAG,SAAA,CAAA,OAAA,CAAQ,WAAR,EAAqB,cAArB,CAAf;AACA,IAAA,YAAY,CAAC,EAAb,CAAgB,OAAhB,EAAyB,OAAzB;AACA,IAAA,aAAa,CAAC,YAAD,CAAb;AACA,UAAM,MAAM,GAAG,YAAY,CAAC,IAAb,CAAkB,IAAI,MAAJ,CAAW,OAAO,CAAC,EAAnB,CAAlB,CAAf;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,WAAV,EAAwB,CAAD,IAAc;AACnC,UAAI,SAAJ,EAAe;AAAE;AAAS;;AAC1B,MAAA,SAAS,GAAG,CAAZ;;AACA,UAAI,OAAO,OAAO,CAAC,KAAf,KAAyB,QAAzB,IAAqC,KAAK,IAAI,CAAlD,EAAqD;AACnD,QAAA,KAAK,IAAI,SAAT;AACD;AACF,KAND;AAOA,IAAA,MAAM,CAAC,EAAP,CAAU,SAAV,EAAqB,MAAK;AAAG,MAAA,QAAQ,GAAG,IAAX;AAAkB,KAA/C;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,UAAV,EAAsB,YAAY,CAAC,MAAb,CAAoB,IAApB,CAAyB,YAAzB,EAAuC,MAAvC,CAAtB;AAEA,QAAI,UAAU,GAAU,EAAxB;;AACA,UAAM,OAAO,GAAI,IAAD,IAA0B;AACxC,UAAI,CAAC,IAAI,CAAC,IAAV,EAAgB;AACd,YAAI,IAAI,CAAC,GAAL,IAAY,OAAhB,EAAyB;AAAE;AAAS;;AACpC,QAAA,OAAO,GAAG,IAAI,CAAC,GAAf;AACD;;AACD,MAAA,KAAK,GAAG,IAAI,CAAC,IAAb;AACA,MAAA,YAAY,CAAC,IAAb,CAAkB,IAAlB,EAAwB,WAAxB;AACA,MAAA,UAAU,CAAC,IAAX,CAAgB,IAAhB;AACD,KARD;;AAUA,QAAI,WAAW,GAAgB,EAA/B;AAAA,QAAmC,mBAAmB,GAAG,CAAzD;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,MAAV,EAAmB,IAAD,IAAe;AAC/B,UAAI,SAAS,GAAA,MAAA,CAAA,MAAA,CAAA;AAAK,QAAA,IAAI,EAAE;AAAX,OAAA,EAAyB,IAAzB,CAAb;;AACA,UAAI,KAAK,IAAI,SAAS,CAAC,IAAvB,EAA6B;AAC3B,QAAA,OAAO,CAAC,SAAD,CAAP;AACD,OAFD,MAEO;AACL,QAAA,WAAW,CAAC,IAAZ,CAAiB,SAAjB;AACA,QAAA,mBAAmB,IAAI,SAAS,CAAC,QAAjC,CAFK,CAGL;;AACA,eAAO,WAAW,CAAC,MAAZ,GAAqB,CAArB,IACL,mBAAmB,GAAG,WAAW,CAAC,CAAD,CAAX,CAAe,QAArC,GAAgD,UADlD,EAC8D;AAC5D,UAAA,mBAAmB,IAAK,WAAW,CAAC,KAAZ,GAAkC,QAA1D;AACD;AACF;;AACD,MAAA,SAAS,IAAI,SAAS,CAAC,QAAvB;AACD,KAdD;AAgBA,IAAA,MAAM,CAAC,EAAP,CAAU,KAAV,EAAiB,MAAK;AACpB,MAAA,YAAY,GAAG,IAAf,CADoB,CAEpB;AACA;;AACA,UAAI,CAAC,UAAU,CAAC,MAAZ,IAAsB,WAAW,CAAC,MAAtC,EAA8C;AAC5C,QAAA,WAAW,CAAC,OAAZ,CAAqB,IAAD,IAAS;AAAG,UAAA,OAAO,CAAC,IAAD,CAAP;AAAgB,SAAhD;AACD,OANmB,CAQpB;;;AACA,MAAA,gBAAgB,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,IAAL,CAAU,UAAU,CAAC,MAAX,GAAoB,IAA9B,CAAZ,CAAnB,CAToB,CAWpB;AACA;;AACA,MAAA,cAAc,GACZ,UAAU,CAAC,MAAX,CAAmB,CAAC,KAAD,EAAQ,IAAR,KAAiB,IAAI,CAAC,QAAL,GAAgB,KAApD,EAA4D,CAA5D,CADF;AAGA,MAAA,gBAAgB,GAAG,KAAnB;AACA,MAAA,WAAW;AACZ,KAlBD;AAmBD,GA/DD;;AAgEA,EAAA,eAAe;;AAEf,EAAA,MAAM,CAAC,GAAP,GAAa,MAAW;AACtB,IAAA,KAAK,GAAG,IAAR;AACA,IAAA,WAAW,CAAC,GAAZ;AACA,IAAA,YAAY,CAAC,GAAb;AACA,IAAA,YAAY,CAAC,cAAD,CAAZ;AACA,IAAA,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAA,YAAY,CAAE,OAAd,EAAA;AACA,IAAA,WAAW,KAAA,IAAX,IAAA,WAAW,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAA,WAAW,CAAE,OAAb,EAAA;AACA,IAAA,QAAA,CAAA,WAAA,CAAY,SAAZ,CAAsB,GAAtB,CAA0B,IAA1B,CAA+B,MAA/B,EAAuC,IAAvC;AACD,GARD;;AAUA,SAAO,MAAP;AACD,CAzKD;;AA0KA,UAAU,CAAC,cAAX,GAA4B,YAAA,CAAA,QAA5B;AAEA,MAAA,CAAA,OAAA,GAAS,UAAT","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst stream_1 = require(\"stream\");\nconst url_1 = require(\"url\");\nconst miniget_1 = __importDefault(require(\"miniget\"));\nconst m3u8_parser_1 = __importDefault(require(\"./m3u8-parser\"));\nconst dash_mpd_parser_1 = __importDefault(require(\"./dash-mpd-parser\"));\nconst queue_1 = __importDefault(require(\"./queue\"));\nconst parse_time_1 = require(\"./parse-time\");\nconst supportedParsers = {\n    'm3u8': m3u8_parser_1.default,\n    'dash-mpd': dash_mpd_parser_1.default,\n};\nlet m3u8stream = ((playlistURL, options = {}) => {\n    const stream = new stream_1.PassThrough();\n    const chunkReadahead = options.chunkReadahead || 3;\n    const liveBuffer = options.liveBuffer || 20000; // 20 seconds\n    const requestOptions = options.requestOptions;\n    const Parser = supportedParsers[options.parser || (/\\.mpd$/.test(playlistURL) ? 'dash-mpd' : 'm3u8')];\n    if (!Parser) {\n        throw TypeError(`parser '${options.parser}' not supported`);\n    }\n    let begin = 0;\n    if (typeof options.begin !== 'undefined') {\n        begin = typeof options.begin === 'string' ?\n            parse_time_1.humanStr(options.begin) :\n            Math.max(options.begin - liveBuffer, 0);\n    }\n    const forwardEvents = (req) => {\n        for (let event of ['abort', 'request', 'response', 'redirect', 'retry', 'reconnect']) {\n            req.on(event, stream.emit.bind(stream, event));\n        }\n    };\n    let currSegment;\n    const streamQueue = new queue_1.default((req, callback) => {\n        currSegment = req;\n        // Count the size manually, since the `content-length` header is not\n        // always there.\n        let size = 0;\n        req.on('data', (chunk) => size += chunk.length);\n        req.pipe(stream, { end: false });\n        req.on('end', () => callback(undefined, size));\n    }, { concurrency: 1 });\n    let segmentNumber = 0;\n    let downloaded = 0;\n    const requestQueue = new queue_1.default((segment, callback) => {\n        let options = Object.assign({}, requestOptions);\n        if (segment.range) {\n            options.headers = Object.assign({}, options.headers, {\n                Range: `bytes=${segment.range.start}-${segment.range.end}`,\n            });\n        }\n        let req = miniget_1.default(url_1.resolve(playlistURL, segment.url), options);\n        req.on('error', callback);\n        forwardEvents(req);\n        streamQueue.push(req, (err, size) => {\n            downloaded += +size;\n            stream.emit('progress', {\n                num: ++segmentNumber,\n                size: size,\n                duration: segment.duration,\n                url: segment.url,\n            }, requestQueue.total, downloaded);\n            callback();\n        });\n    }, { concurrency: chunkReadahead });\n    const onError = (err) => {\n        if (ended) {\n            return;\n        }\n        stream.emit('error', err);\n        // Stop on any error.\n        stream.end();\n    };\n    // When to look for items again.\n    let refreshThreshold;\n    let minRefreshTime;\n    let refreshTimeout;\n    let fetchingPlaylist = true;\n    let ended = false;\n    let isStatic = false;\n    let lastRefresh;\n    const onQueuedEnd = (err) => {\n        currSegment = null;\n        if (err) {\n            onError(err);\n        }\n        else if (!fetchingPlaylist && !ended && !isStatic &&\n            requestQueue.tasks.length + requestQueue.active <= refreshThreshold) {\n            let ms = Math.max(0, minRefreshTime - (Date.now() - lastRefresh));\n            fetchingPlaylist = true;\n            refreshTimeout = setTimeout(refreshPlaylist, ms);\n        }\n        else if ((ended || isStatic) &&\n            !requestQueue.tasks.length && !requestQueue.active) {\n            stream.end();\n        }\n    };\n    let currPlaylist;\n    let lastSeq;\n    let starttime = 0;\n    const refreshPlaylist = () => {\n        lastRefresh = Date.now();\n        currPlaylist = miniget_1.default(playlistURL, requestOptions);\n        currPlaylist.on('error', onError);\n        forwardEvents(currPlaylist);\n        const parser = currPlaylist.pipe(new Parser(options.id));\n        parser.on('starttime', (a) => {\n            if (starttime) {\n                return;\n            }\n            starttime = a;\n            if (typeof options.begin === 'string' && begin >= 0) {\n                begin += starttime;\n            }\n        });\n        parser.on('endlist', () => { isStatic = true; });\n        parser.on('endearly', currPlaylist.unpipe.bind(currPlaylist, parser));\n        let addedItems = [];\n        const addItem = (item) => {\n            if (!item.init) {\n                if (item.seq <= lastSeq) {\n                    return;\n                }\n                lastSeq = item.seq;\n            }\n            begin = item.time;\n            requestQueue.push(item, onQueuedEnd);\n            addedItems.push(item);\n        };\n        let tailedItems = [], tailedItemsDuration = 0;\n        parser.on('item', (item) => {\n            let timedItem = Object.assign({ time: starttime }, item);\n            if (begin <= timedItem.time) {\n                addItem(timedItem);\n            }\n            else {\n                tailedItems.push(timedItem);\n                tailedItemsDuration += timedItem.duration;\n                // Only keep the last `liveBuffer` of items.\n                while (tailedItems.length > 1 &&\n                    tailedItemsDuration - tailedItems[0].duration > liveBuffer) {\n                    tailedItemsDuration -= tailedItems.shift().duration;\n                }\n            }\n            starttime += timedItem.duration;\n        });\n        parser.on('end', () => {\n            currPlaylist = null;\n            // If we are too ahead of the stream, make sure to get the\n            // latest available items with a small buffer.\n            if (!addedItems.length && tailedItems.length) {\n                tailedItems.forEach((item) => { addItem(item); });\n            }\n            // Refresh the playlist when remaining segments get low.\n            refreshThreshold = Math.max(1, Math.ceil(addedItems.length * 0.01));\n            // Throttle refreshing the playlist by looking at the duration\n            // of live items added on this refresh.\n            minRefreshTime =\n                addedItems.reduce(((total, item) => item.duration + total), 0);\n            fetchingPlaylist = false;\n            onQueuedEnd();\n        });\n    };\n    refreshPlaylist();\n    stream.end = () => {\n        ended = true;\n        streamQueue.die();\n        requestQueue.die();\n        clearTimeout(refreshTimeout);\n        currPlaylist === null || currPlaylist === void 0 ? void 0 : currPlaylist.destroy();\n        currSegment === null || currSegment === void 0 ? void 0 : currSegment.destroy();\n        stream_1.PassThrough.prototype.end.call(stream, null);\n    };\n    return stream;\n});\nm3u8stream.parseTimestamp = parse_time_1.humanStr;\nmodule.exports = m3u8stream;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}